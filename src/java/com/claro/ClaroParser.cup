package com.claro;

import com.claro.ClaroParserException;
import com.claro.compiler_backends.interpreted.ScopedHeap;
import com.claro.intermediate_representation.*;
import com.claro.intermediate_representation.expressions.*;
import com.claro.intermediate_representation.expressions.bool.*;
import com.claro.intermediate_representation.expressions.numeric.*;
import com.claro.intermediate_representation.expressions.procedures.functions.*;
import com.claro.intermediate_representation.expressions.procedures.methods.*;
import com.claro.intermediate_representation.expressions.term.*;
import com.claro.intermediate_representation.statements.*;
import com.claro.intermediate_representation.statements.contracts.*;
import com.claro.intermediate_representation.statements.user_defined_type_def_stmts.*;
import com.claro.intermediate_representation.types.TypeProvider;
import com.claro.intermediate_representation.types.TypeProvider.ImmediateTypeProvider;
import com.claro.intermediate_representation.types.Type;
import com.claro.intermediate_representation.types.Types;
import com.claro.runtime_utilities.injector.InjectedKey;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.base.Strings;
import java_cup.runtime.Symbol;
import java.lang.Math;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Stack;
import java.util.stream.Stream;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import lombok.Data;

action code {:
  AtomicReference<TypeProvider> returnTypeHolder;

  int indentationLevel = 1;

  private String getIndents(int level) {
    StringBuilder res = new StringBuilder();
    for(int i = 0; i < level; i++) {
      res.append("\t");
    }
    return res.toString();
  }

  private Expr constructBinaryExpr(Expr a, LexedValue<String> op, Integer opleft, Integer opright, Expr b, Function<Supplier<String>, BiFunction<Integer, Integer, Expr>> constructor) {
    Supplier<String> currentLinesSupplier =
      joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(op.currentInputLine, opright), new Line(b.currentLine, b.currentLineNumber));
    int startCol = min(a.startCol, opleft, b.startCol);
    int endCol = max(a.endCol, opleft + op.len, b.endCol);

    return constructor.apply(currentLinesSupplier).apply(startCol, endCol);
  }

  private CollectionSubscriptExpr constructCollectionSubscriptExpr(Expr l, LexedValue<String> lb, int lbleft, int lbright, Expr e, LexedValue<String> rb, int rbleft, int rbright) {
     Supplier<String> currentLinesSupplier =
        joinExprLines(new Line(l.currentLine, l.currentLineNumber), new Line(lb.currentInputLine, lbright), new Line(e.currentLine, e.currentLineNumber), new Line(rb.currentInputLine, rbright));
     int startCol = min(l.startCol, lbleft, e.startCol, rbleft);
     int endCol = max(l.endCol, lbleft + lb.len, e.endCol, rbleft + rb.len);

     return new CollectionSubscriptExpr(l, e, currentLinesSupplier, rbright, startCol, endCol);
  }

  private InputExpr constructInputExpr(
    Optional<LexedValue<String>> prompt, int promptleft, int promptright, LexedValue<String> i, int ileft, int iright, LexedValue<String> lp, int lpleft, int lpright, LexedValue<String> rp, int rpleft, int rpright
  ) {
     Supplier<String> currentLinesSupplier =
        prompt.isPresent()
        ? joinExprLines(new Line(i.currentInputLine, iright), new Line(lp.currentInputLine, lpright), new Line(prompt.get().currentInputLine, promptright), new Line(rp.currentInputLine, rpright))
        : joinExprLines(new Line(i.currentInputLine, iright), new Line(lp.currentInputLine, lpright), new Line(rp.currentInputLine, rpright));
     int startCol = min(ileft, lpleft, prompt.isPresent() ? promptleft : Integer.MAX_VALUE, rpleft);
     int endCol = max(ileft + i.len, lpleft + lp.len, prompt.isPresent() ? promptleft + prompt.get().len : -1, rpleft + rp.len);

     return new InputExpr(prompt.map(p -> p.val), currentLinesSupplier, rpright, startCol, endCol);
  }

  private Expr constructSetOrTuple(LexedValue<String> lp, int lpleft, int lpright, Expr head, LexedValue<String> c, int cleft, int cright, Symbol tailValues, LexedValue<String> rp, int rpleft, int rpright, BiFunction<ImmutableList<Expr>, Supplier<String>, BiFunction<Integer, Integer, Expr>> constructor) {
    Supplier<String> currentLinesSupplier =
       joinExprLines(new Line(lp.currentInputLine, lpright), new Line(head.currentLine, head.currentLineNumber), new Line(c.currentInputLine, cright), new Line(((LexedValue) tailValues.value).currentInputLine, tailValues.right), new Line(rp.currentInputLine, rpright));
    int startCol = min(lpleft, head.startCol, cleft, tailValues.left, rpleft);
    int endCol = max(lpleft + lp.len, head.endCol, cleft + c.len, tailValues.left + ((LexedValue) tailValues.value).len, rpleft + rp.len);

    ImmutableList.Builder<Expr> values = ImmutableList.builder();
    values.add(head);
    values.addAll(((LexedValue<ImmutableList.Builder<Expr>>) tailValues.value).val.build().reverse());
    return constructor.apply(values.build(), currentLinesSupplier).apply(startCol, endCol);
  }

  private Symbol constructBuiltinType(LexedValue<String> lb, int lbleft, int lbright, Symbol t, LexedValue<String> rb, int rbleft, int rbright, Function<LexedValue<TypeProvider>, TypeProvider> typeProviderConstructor) {
    LexedValue<TypeProvider> tLexedVal = (LexedValue<TypeProvider>) t.value;
    Supplier<String> currentLinesSupplier =
      joinExprLines(new Line(lb.currentInputLine, lbright), new Line(tLexedVal.currentInputLine, t.right), new Line(rb.currentInputLine, rbright));
    int startCol = min(lbleft, t.left, rbleft);
    int endCol = max(lbleft + lb.len, t.left + tLexedVal.len, rbleft + rb.len);

    return new Symbol(
      -1,
      startCol,
      endCol, // line number
      new LexedValue(
        typeProviderConstructor.apply(tLexedVal),
        currentLinesSupplier,
        endCol - startCol)
      );
  }

  private ContractProcedureImplementationStmt constructContractProcImplStmtForGenericProcDefStmt(
      GenericFunctionDefinitionStmt f) {
    return new ContractProcedureImplementationStmt(
        f.functionName,
              (canonName, scopedHeap) -> {
          String origName = f.functionName;
          f.functionName = canonName;
          if (scopedHeap == null) {
            // In this case we're updating the name specifically for the sake of creating a name suitable for
                  // codegen, so that means we also need to update the monorphizations.
                  f.genericProcedureDefStmt.procedureName = canonName;
          } else {
            try {
              f.registerGenericProcedureTypeProvider(scopedHeap);
            } catch (Exception e) {
              throw new RuntimeException(e);
            }
          }
          return f;
        });
  }
:}

parser code {:
  public String generatedClassName = "CompiledClaroProgram";  // default to be overridden.
  public String package_string = "";  // default to be overridden.
  public Consumer<String> printerDelegate = System.out::println;

  public int errorsFound = 0;
  public static Stack<Runnable> errorMessages = new Stack<>();

  @Override
  public void report_error(String message, Object info) {
    errorsFound++;
    Symbol currSymbol = (Symbol) info;
    LexedValue<?> lexedValue = (LexedValue) currSymbol.value;

    errorMessages.push(
      () -> {
        System.err.print(String.format("%s.claro:%s: ", generatedClassName, currSymbol.right + 1));
        System.err.println("Unexpected token <" + lexedValue.val + ">");
        String currentInputLineString = lexedValue.currentInputLine.get();
        if (Character.isWhitespace(currentInputLineString.charAt(currentInputLineString.length() - 1))) {
          int trailingWhitespaceStart = currentInputLineString.length();
          while (Character.isWhitespace(currentInputLineString.charAt(--trailingWhitespaceStart))); // This is just cute for the sake of it....barf...but I'm keeping it lol.
          System.err.println(currentInputLineString.substring(0, trailingWhitespaceStart + 1));
        } else {
          System.err.println(lexedValue.currentInputLine.get());
        }
        System.err.println(Strings.repeat(" ", currSymbol.left) + '^');
      });
  }

  @Override
  public void syntax_error(Symbol cur_token) {
    this.report_error("Syntax error", cur_token);
  }

  @Data
  static class Line {
    Supplier<String> inputLineSupplier;
    int inputLineNumber;

    Line(StringBuilder inputLine, int inputLineNumber) {
      this(() -> inputLine.toString(), inputLineNumber);
    }

    Line(Expr e) {
      this(e.currentLine, e.currentLineNumber);
    }

    Line(Symbol s) {
      this(((LexedValue<?>)s.value).currentInputLine, s.right);
    }

    Line(Supplier<String> inputLineSupplier, int inputLineNumber) {
      this.inputLineSupplier = inputLineSupplier;
      this.inputLineNumber = inputLineNumber;
    }
  }

  private Supplier<String> joinExprLines(Line ... linesToJoin) {
    return () -> {
        StringBuilder res = new StringBuilder(linesToJoin[0].inputLineSupplier.get());
        int prevLineNum = linesToJoin[0].inputLineNumber;
        for (int i = 1; i < linesToJoin.length; i++) {
          Line curr = linesToJoin[i];
          if (curr.inputLineNumber != prevLineNum) {
            prevLineNum = curr.inputLineNumber;
            res.append(curr.inputLineSupplier.get());
          }
        }
        return res.toString();
    };
  }

  // Super obnoxious code...but for the sake of hacking together input text annotations for nonterminal grammar matches
  // so that we can plumb it up into the AST, this code aggregates data from multiple Symbols into a single one.
  private <T> Symbol chainSymbols(T value, Symbol ... symbols) {
    Stream<Symbol> symbolStream = Arrays.stream(symbols);
    int minStartCol = Integer.MAX_VALUE; // min column
    int maxEndCol = Integer.MIN_VALUE; // max column
    int maxLine = Integer.MIN_VALUE; // max line
    for (int i = 0; i<symbols.length; i++) {
      minStartCol = Math.min(symbols[i].left, minStartCol);
      maxEndCol = Math.max(symbols[i].left + ((LexedValue)symbols[i].value).len, maxEndCol);
      maxLine = Math.max(symbols[i].right, maxLine);
    }
    int aggregateLen = maxEndCol - minStartCol;

    Supplier<String> inputLinesSupplier = () -> {
      StringBuilder inputLines = new StringBuilder();
      symbolStream.map(s -> ((LexedValue)s.value).currentInputLine).forEach(inputLines::append);
      return inputLines.toString();
    };
    return new Symbol(
      -1, // Really I just have no better value to put in here.
      minStartCol,
      maxLine,
      new LexedValue<T>(value, inputLinesSupplier, aggregateLen)
    );
  }

  private static int min(int ... nums) {
    int currMin = Integer.MAX_VALUE;
    for (int x : nums) {
      currMin = Math.min(x, currMin);
    }
    return currMin;
  }

  private static int max(int ... nums) {
    int currMax = Integer.MIN_VALUE;
    for (int x : nums) {
      currMax = Math.max(x, currMax);
    }
    return currMax;
  }
:}

terminal LexedValue<String>  LPAR, RPAR;
terminal LexedValue<String>  LCURLY, RCURLY, LBRACKET, RBRACKET;
terminal LexedValue<String>  EXPONENTIATE;
terminal LexedValue<String>  MULTIPLY, DIVIDE, MODULUS;
terminal LexedValue<String>  PLUS, MINUS;
terminal LexedValue<String>  INCREMENT, DECREMENT;
terminal LexedValue<String>  SEMICOLON;
terminal LexedValue<String>  COLON;
terminal LexedValue<String>  COMMA;
terminal LexedValue<String>  BAR;
terminal LexedValue<String>  EQUALS, NOT_EQUALS;
terminal LexedValue<String>  UNDERSCORE;
terminal LexedValue<String>  VAR, ASSIGNMENT;
terminal LexedValue<String>  L_ANGLE_BRACKET, R_ANGLE_BRACKET, LTE, GTE;
terminal LexedValue<String>  OR, AND, NOT;
terminal LexedValue<String>  IN;
terminal LexedValue<String>  ARROW, UP_ARROW, PIPE_ARROW;
terminal LexedValue<Boolean> TRUE, FALSE;
// An integer is also a terminal, but it's of type Integer.
terminal LexedValue<Integer> INTEGER;
// A float is also a terminal, but it's of type Double.
terminal LexedValue<Double>  FLOAT;
// A string is also a terminal, but it's of type String.
terminal LexedValue<String>  STRING, FMT_STRING_PART;
// A variable identifier is just a sequence of chars.
terminal LexedValue<String>  IDENTIFIER;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal LexedValue<String>  LOG_PREFIX;
// This grammar also has a builtin print() function for printing expr values.
terminal LexedValue<String>  PRINT;
// This grammar also has a builtin numeric() function for casting booleans to doubles.
terminal LexedValue<String>  NUMERIC_BOOL;
// This grammar also has a builtin input() function for reading a line from stdin.
terminal LexedValue<String>  INPUT;
// This grammar also has a builtin isInputReady() function for checking whether a line is ready to be read on stdin.
terminal LexedValue<String>  IS_INPUT_READY;
// This grammar also has a builtin len() function for getting the length of an Iterable.
terminal LexedValue<String>  LEN;
// This grammar also has a builtin type() function for getting the type of an Expr.
terminal LexedValue<String>  TYPE;
// This grammar also has a builtin append() function for appending an element to a List.
terminal LexedValue<String>  APPEND;
terminal LexedValue<String>  IF, ELSE;
terminal LexedValue<String>  WHILE;
// Builtin Types (with keywords instead of symbolic notation, e.g. list is [<type>]).
terminal LexedValue<String>  INT_TYPE, FLOAT_TYPE, BOOLEAN_TYPE, STRING_TYPE, TUPLE_TYPE, STRUCT_TYPE,
                 ONEOF, FUNCTION_TYPE, CONSUMER_FUNCTION_TYPE, PROVIDER_FUNCTION_TYPE, LAMBDA;
terminal LexedValue<String>  ALIAS;
terminal LexedValue<String>  RETURN;
terminal LexedValue<String>  IMMUTABLE;
terminal LexedValue<String>  DOT;
// TODO(steving) Need to complete undo this hack for DOTBUILD and BUILDER.
terminal LexedValue<String>  BUILDER, DOTBUILD;
terminal LexedValue<String>  MODULE, BIND, TO, AS, USING;
terminal LexedValue<String>  FUTURE, BLOCKING_GET, BLOCKING, MAYBE_BLOCKING, GRAPH, ROOT, NODE, LEFT_ARROW, AT;
terminal LexedValue<String>  CONTRACT, IMPLEMENT, REQUIRES, COLON_COLON;

// DEBUGGING keywords which should be removed when we want a real release....
terminal LexedValue<String>  DEBUG_DUMP_SCOPE;

// Declare which type will be returned by each nonterminal grammar production.
nonterminal ProgramNode                        program;
nonterminal Expr                               expr;
nonterminal ParenthesizedExpr                  parenthesized_expr;
nonterminal Symbol/*ImmutableList<ImmutableList.Builder>*/  fmt_string;
nonterminal Term                               term;
nonterminal Term                               primitive;
nonterminal IdentifierReferenceTerm            identifier;
nonterminal FloatTerm                          float;
nonterminal IntegerTerm                        integer;
nonterminal Stmt                               stmt;
nonterminal StmtListNode                       stmt_list;
nonterminal StmtListNode                       stmts_and_defs_list;
nonterminal ListExpr                           list;
nonterminal MapExpr                            map;
nonterminal ImmutableList.Builder/*<ImmutableList<Expr>>*/ map_initializer_kv_list;
nonterminal TupleExpr                          tuple;
nonterminal SetExpr                            set;
nonterminal CollectionSubscriptExpr            collection_subscript;
nonterminal Symbol/*ImmutableList.Builder<Expr>*/  args_list;
nonterminal IfStmt                             if_else_chain_stmt;
nonterminal IfStmt                             if_stmt;
nonterminal IfStmt                             else_if_stmt_chain;
nonterminal IfStmt                             else_if_stmt;
nonterminal StmtListNode                       else_stmt;
nonterminal WhileStmt                          while_stmt;
nonterminal AliasStmt                          alias_stmt;
nonterminal PrintStmt                          print;
nonterminal ShowTypeStmt                       show_type;
nonterminal DeclarationStmt                    identifier_declaration;
nonterminal AssignmentStmt                     identifier_assignment;
nonterminal TrashcanAssignmentStmt             trashcan_assignment;
nonterminal IncrementExpr                      identifier_increment;
nonterminal IncrementStmt                      identifier_increment_stmt;
nonterminal DecrementExpr                      identifier_decrement;
nonterminal DecrementStmt                      identifier_decrement_stmt;
nonterminal ListElementAssignmentStmt          list_element_assignment;
nonterminal AppendElementToListStmt            list_append_stmt;
nonterminal StructDefinitionStmt               struct_definition_stmt;
nonterminal FunctionDefinitionStmt             function_definition_stmt;
nonterminal GenericFunctionDefinitionStmt      generic_function_definition_stmt;
nonterminal LambdaExpr                         lambda_function_expr;
nonterminal CastExpr/*wrapping LambdaExpr*/    typed_lambda_function_expr;
nonterminal Symbol/*ImmutableMap.Builder<String, TypeProvider>*/ function_args_types_list;
nonterminal Symbol/*ImmutableList.Builder<String>*/  identifier_list;
nonterminal ImmutableList<String>              generic_blocking_on;
nonterminal ImmutableList.Builder<String>      identifier_bar_sep_list;
nonterminal TypeProvider                       maybe_blocking_procedure_types;
nonterminal ImmutableMap.Builder<String, TypeProvider> procedure_args_w_generic_blocking;
nonterminal ConsumerFunctionDefinitionStmt     consumer_function_definition_stmt;
nonterminal GenericFunctionDefinitionStmt      generic_consumer_function_definition_stmt;
nonterminal ProviderFunctionDefinitionStmt     provider_function_definition_stmt;
nonterminal GenericFunctionDefinitionStmt      generic_provider_function_definition_stmt;
nonterminal GraphFunctionDefinitionStmt        graph_function_definition_stmt;
nonterminal GraphProviderDefinitionStmt        graph_provider_definition_stmt;
nonterminal GraphConsumerDefinitionStmt        graph_consumer_definition_stmt;
nonterminal GraphNodeDefinitionStmt            root_node;
nonterminal GraphNodeDefinitionStmt            non_root_node;
nonterminal ImmutableList.Builder<GraphNodeDefinitionStmt> non_root_nodes_list;
nonterminal GraphNodeReferenceExpr             node_reference;
nonterminal ContractDefinitionStmt             contract_definition_stmt;
nonterminal ImmutableList.Builder<ContractProcedureSignatureDefinitionStmt> contract_signature_defs_list;
nonterminal ContractProcedureSignatureDefinitionStmt contract_procedure_signature_definition_stmt;
nonterminal ContractImplementationStmt         contract_implementation_stmt;
nonterminal ImmutableList.Builder<ContractProcedureImplementationStmt> contract_implementations_list;
// Unfortunately IntelliJ is starting to take a dump on this file since it's gotten massive, so it will no longer
// correctly parse this type even though JCup and Java are handling the file like a champ.
nonterminal ImmutableListMultimap.Builder/*<String, ImmutableList<Type>>*/  required_contracts;
nonterminal PipeChainStmt                      pipe_chain_stmt;
// This is just because Java is hot garbage and doesn't have tuples. The first entry will be a sink stmt.
// The second entry will be an ImmutableList.Builder<Expr>. The Expr will be required to contain some
// backreference to the value piped from the previous expr.
// TODO(steving) Implement PipeChainBackreferenceTerm for `^`. This will be sort of like an IdentifierReferenceTerm
//  except that it will also need to be able to either make itself a codegen inlining of the prior expr, or it will
//  need to reference a generated identifier for an intermediate temporary.
nonterminal ImmutableList<Object>              pipe_chain;
nonterminal BuilderMethodCallExpr              builder_method_call_expr;
nonterminal BuilderFullBuildMethodCallExpr     builder_full_build;
nonterminal Symbol/*<ImmutableMap.Builder<String, Expr>>*/ builder_setter_call;
nonterminal Symbol/*ImmutableMap.Builder<String, Expr>*/ builder_setter_chain;
nonterminal ReturnStmt                         return_stmt;
nonterminal FunctionCallExpr                   function_call_expr;
nonterminal ProviderFunctionCallExpr           provider_function_call_expr;
nonterminal ConsumerFunctionCallStmt           consumer_function_call_stmt;
nonterminal InputExpr                          input;
nonterminal IsInputReadyExpr                   is_input_ready;
nonterminal Expr/*BoolExpr*/                   bool_expr;
nonterminal Expr/*BoolExpr*/                   equality;
nonterminal Expr/*BoolExpr*/                   inequality;
nonterminal Expr/*BoolExpr*/                   bool_arithmetic;
// TODO(steving) In order to support the delayed parsing of all user-defined types, just replace this type with
// TODO(steving) Function<ScopedHeap, TypeProvider> or some other equivalent functional interface and then you'll be good to add
// TODO(steving) a new compiler phase that filters a StmtList for all of its type definitions (e.g. StructDefinitionStmt)
// TODO(steving) and parses all of those before moving on to the other stmts in the StmtList.
nonterminal Symbol/*TypeProvider*/             builtin_type;
nonterminal Symbol/*ImmutableList<TypeProvider>*/  builtin_types_list;
nonterminal Symbol/*ImmutableList.Builder<TypeProvider>*/ backwards_builtin_types_list;
nonterminal Stmt                               debug_stmts;
nonterminal ModuleDefinitionStmt               module_definition_stmt;
nonterminal StmtListNode                       bind_stmts_list;
nonterminal BindStmt                           bind_stmt;
nonterminal UsingBlockStmt                     using_block_stmt;
nonterminal Symbol/*ImmutableList.Builder<InjectedKey>*/ injected_keys_list;

// Lower precedence things at the top, higher precedence things at the bottom.
// ...but also I've basically put no thought whatsoever into the order these ACTUALLY appear in.
precedence left IN;
precedence left COMMA;
precedence left IDENTIFIER;
precedence left SEMICOLON;
precedence left ASSIGNMENT;
precedence left COLON;
precedence left EQUALS, NOT_EQUALS;
precedence left AND, OR, NOT;
precedence left L_ANGLE_BRACKET, R_ANGLE_BRACKET, LTE, GTE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MODULUS;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX, IF, ELSE;
precedence left WHILE;

// This is where the grammar starts.
program ::=
    stmts_and_defs_list:s
    {:
       RESULT = new ProgramNode(s, package_string, generatedClassName);
    :}
  ;

// TODO(steving) Add procedure defs to this target so that they also can only be used at the top level.
stmts_and_defs_list ::=
    stmt:s stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(s, tail); :}
  | module_definition_stmt:m stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(m, tail); :}
  | contract_definition_stmt:c stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(c, tail); :}
  | contract_implementation_stmt:c stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(c, tail); :}
  | generic_function_definition_stmt:f stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(f, tail); :}
  | generic_consumer_function_definition_stmt:f stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(f, tail); :}
  | generic_provider_function_definition_stmt:f stmts_and_defs_list:tail
    {: RESULT = new StmtListNode(f, tail); :}

  // We'll allow files with only a single one of these following stmts as well.
  | stmt:s
    {: RESULT = new StmtListNode(s); :}
  | module_definition_stmt:m
    {: RESULT = new StmtListNode(m); :}
  | contract_definition_stmt:c
    {: RESULT = new StmtListNode(c); :}
  | contract_implementation_stmt:c
    {: RESULT = new StmtListNode(c); :}
  | generic_function_definition_stmt:f
    {: RESULT = new StmtListNode(f); :}
  | generic_consumer_function_definition_stmt:f
    {: RESULT = new StmtListNode(f); :}
  | generic_provider_function_definition_stmt:f
    {: RESULT = new StmtListNode(f); :}
  ;

stmt_list ::=
    stmt:head stmt_list:tail
    {: RESULT = new StmtListNode(head, tail); :}
  | stmt:s
    {: RESULT = new StmtListNode(s); :}
  | debug_stmts:d
    {: RESULT = new StmtListNode(d); :}
  ;

debug_stmts ::=
    DEBUG_DUMP_SCOPE LPAR RPAR SEMICOLON
    {:
       RESULT =
         new PrintStmt(
           new StringTerm(null, ()-> "", 0,0,0) {
             @Override
             public Object generateInterpretedOutput(ScopedHeap scopedHeap) {
               return scopedHeap;
             }
           },
           printerDelegate
         );
    :}
  ;

stmt ::=
    print:p
    {: RESULT = p; :}
  | show_type:s
    {: RESULT = s; :}
  | identifier_declaration:d
    {: RESULT = d; :}
  | identifier_assignment:a
    {: RESULT = a; :}
  | trashcan_assignment:t
    {: RESULT = t; :}
  | identifier_increment_stmt:i
    {: RESULT = i; :}
  | identifier_decrement_stmt:i
    {: RESULT = i; :}
  | list_element_assignment:l
    {: RESULT = l; :}
  | list_append_stmt:la
    {: RESULT = la; :}
  | if_else_chain_stmt:i
    {: RESULT = i; :}
  | while_stmt:w
    {: RESULT = w; :}
  | struct_definition_stmt:s
    {: RESULT = s; :}
  | function_definition_stmt:f
    {: RESULT = f; :}
  | consumer_function_definition_stmt:f
    {: RESULT = f; :}
  | provider_function_definition_stmt:pf
    {: RESULT = pf; :}
  | consumer_function_call_stmt:cf
    {: RESULT = cf; :}
  | graph_function_definition_stmt:gf
    {: RESULT = gf; :}
  | graph_provider_definition_stmt:gf
    {: RESULT = gf; :}
  | graph_consumer_definition_stmt:gf
    {: RESULT = gf; :}
  | return_stmt:r
    {: RESULT = r; :}
  | alias_stmt:a
    {: RESULT = a; :}
  | using_block_stmt:u
    {: RESULT = u; :}
  | pipe_chain_stmt:p
    {: RESULT = p; :}
  ;

module_definition_stmt ::=
    MODULE IDENTIFIER:i LCURLY bind_stmts_list:b RCURLY
    {: RESULT = new ModuleDefinitionStmt(i.val, b); :}
  | MODULE IDENTIFIER:i USING LPAR identifier_list:modules RPAR LCURLY bind_stmts_list:b RCURLY
    {:
      ImmutableList<String> moduleList =
        ((LexedValue<ImmutableList.Builder<String>>)modules.value).val.build().reverse();
      RESULT = new ModuleDefinitionStmt(i.val, Optional.of(moduleList), b);
    :}
  ;

bind_stmts_list ::=
    bind_stmt:head bind_stmts_list:tail
    {: RESULT = new StmtListNode(head, tail); :}
  | bind_stmt:s
    {: RESULT = new StmtListNode(s); :}
  ;

bind_stmt ::=
    BIND IDENTIFIER:i COLON builtin_type:t TO expr:e SEMICOLON
    {: RESULT = new BindStmt(i.val, ((LexedValue<TypeProvider>) t.value).val, e); :}
  ;

using_block_stmt ::=
    USING LPAR identifier_list:modules RPAR LCURLY stmt_list:s RCURLY
    {:
       ImmutableList<String> moduleList =
         ((LexedValue<ImmutableList.Builder<String>>)modules.value).val.build().reverse();
       RESULT = new UsingBlockStmt(moduleList, s, true);
    :}
  ;

print ::=
    PRINT LPAR expr:e RPAR SEMICOLON
    {: RESULT = new PrintStmt(e, printerDelegate); :}
  ;

show_type ::=
    TYPE LPAR expr:e RPAR SEMICOLON
    {: RESULT = new ShowTypeStmt(e); :}
  ;

identifier_declaration ::=
    VAR IDENTIFIER:identifier ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, e); :}
  | VAR IDENTIFIER:identifier COLON builtin_type:t SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, ((LexedValue<TypeProvider>) t.value).val); :}
  | VAR IDENTIFIER:identifier COLON builtin_type:t ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, ((LexedValue<TypeProvider>) t.value).val, e); :}

  // Blocking variants.
  | VAR IDENTIFIER:identifier COLON builtin_type:t BLOCKING_GET expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, ((LexedValue<TypeProvider>) t.value).val, e, /*allowVariableHiding=*/false, /*blocking=*/true); :}
  | VAR IDENTIFIER:identifier BLOCKING_GET expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, e, /*blocking=*/true); :}
  ;

alias_stmt ::=
    ALIAS IDENTIFIER:alias COLON builtin_type:aliased_type
    {:
       LexedValue<TypeProvider> aliasedTypeLexedVal = (LexedValue<TypeProvider>) aliased_type.value;
       RESULT = new AliasStmt(alias.val, aliasedTypeLexedVal.val);
    :}
  ;

builtin_type ::=
    INT_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          new LexedValue(
            (TypeProvider) ImmediateTypeProvider.of(Types.INTEGER),
            t.currentInputLine,
            t.len)
       );
    :}
  | FLOAT_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          new LexedValue(
            (TypeProvider) ImmediateTypeProvider.of(Types.FLOAT),
            t.currentInputLine,
            t.len)
       );
    :}
  | BOOLEAN_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          new LexedValue(
            (TypeProvider) ImmediateTypeProvider.of(Types.BOOLEAN),
            t.currentInputLine,
            t.len)
       );
    :}
  | STRING_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          new LexedValue(
            (TypeProvider) ImmediateTypeProvider.of(Types.STRING),
            t.currentInputLine,
            t.len)
       );
    :}
  | LBRACKET:lb builtin_type:t RBRACKET:rb
    {:
       RESULT = constructBuiltinType(
           lb, lbleft, lbright, t, rb, rbleft, rbright,
           tLexedVal -> (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.ListType.forValueType(tLexedVal.val.resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
           });
    :}
  | LCURLY:lb builtin_type:t RCURLY:rb
    {:
       RESULT = constructBuiltinType(
           lb, lbleft, lbright, t, rb, rbleft, rbright,
           tLexedVal -> (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.SetType.forValueType(tLexedVal.val.resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
           });
    :}
  | LCURLY:la builtin_type:key COLON:c builtin_type:value RCURLY:ra
    // Maps are defined like {string:int} to avoid a new keyword `map` since I'd like to not impair functional style,
    // where map is a well known function.
    {:
       LexedValue<TypeProvider> keyLexedVal = (LexedValue<TypeProvider>) key.value;
       LexedValue<TypeProvider> valueLexedVal = (LexedValue<TypeProvider>) value.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(la.currentInputLine, laright), new Line(keyLexedVal.currentInputLine, key.right), new Line(c.currentInputLine, cright), new Line(valueLexedVal.currentInputLine, value.right), new Line(ra.currentInputLine, raright));
       int startCol = min(laleft, key.left, cleft, value.left, raleft);
       int endCol = max(laleft + la.len, key.left + keyLexedVal.len, cleft + c.len, value.left + valueLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.MapType.forKeyValueTypes(keyLexedVal.val.resolveType(scopedHeap), valueLexedVal.val.resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
              },
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | ONEOF:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg_types.left + argTypesLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.OneofType.forVariantTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argLexedVal.currentInputLine, arg.right), new Line(a.currentInputLine, aright), new Line(outputTypeLexedVal.currentInputLine, output_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg.left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg.left + argLexedVal.len, aleft + a.len, output_type.left + outputTypeLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.val.resolveType(scopedHeap)), outputTypeLexedVal.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(b1.currentInputLine, b1right), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(b2.currentInputLine, b2right), new Line(a.currentInputLine, aright), new Line(outputTypeLexedVal.currentInputLine, output_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, b1left, arg_types.left, b2left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, b1left + b1.len, arg_types.left + argTypesLexedVal.len, b2left + b2.len, aleft + a.len, output_type.left + outputTypeLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argLexedVal.currentInputLine, arg.right), new Line(a.currentInputLine, aright), new Line(outputTypeLexedVal.currentInputLine, output_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg.left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg.left + argLexedVal.len, aleft + a.len, output_type.left + outputTypeLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.val.resolveType(scopedHeap)), outputTypeLexedVal.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(b1.currentInputLine, b1right), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(b2.currentInputLine, b2right), new Line(a.currentInputLine, aright), new Line(outputTypeLexedVal.currentInputLine, output_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, b1left, arg_types.left, b2left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, b1left + b1.len, arg_types.left + argTypesLexedVal.len, b2left + b2.len, aleft + a.len, output_type.left + outputTypeLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg_types.left + argTypesLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg_types.left + argTypesLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | PROVIDER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:return_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> returnTypeProvider = (LexedValue<TypeProvider>) return_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(returnTypeProvider.currentInputLine, return_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, return_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, return_type.left + returnTypeProvider.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(returnTypeProvider.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING PROVIDER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:return_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> returnTypeProvider = (LexedValue<TypeProvider>) return_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(returnTypeProvider.currentInputLine, return_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, return_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, return_type.left + returnTypeProvider.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(returnTypeProvider.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | TUPLE_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg_types.left + argTypesLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.TupleType.forValueTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUTURE:f L_ANGLE_BRACKET:la builtin_type:wrapped R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> wrappedTypeProvider = (LexedValue<TypeProvider>) wrapped.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(f.currentInputLine, fright), new Line(la.currentInputLine, laright), new Line(wrappedTypeProvider.currentInputLine, wrapped.right), new Line(ra.currentInputLine, raright));
       int startCol = min(fleft, laleft, wrapped.left, raleft);
       int endCol = max(fleft + f.len, laleft + la.len, wrapped.left + wrappedTypeProvider.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.FutureType.wrapping(wrappedTypeProvider.val.resolveType(scopedHeap)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:type_name
    {:
       RESULT = new Symbol(
          -1,
          type_nameleft,
          type_nameright, // line number
          new LexedValue(
            TypeProvider.Util.getTypeByName(type_name.val, /*isTypeDefinition=*/true),
            type_name.currentInputLine,
            type_name.len)
       );
    :}
  ;

builtin_types_list ::=
    backwards_builtin_types_list:b
    {:
       LexedValue<ImmutableList.Builder<TypeProvider>> bLexedValue = (LexedValue<ImmutableList.Builder<TypeProvider>>) b.value;
       RESULT = new Symbol(
          -1,
          b.left,
          b.right, // line number
          new LexedValue(
            bLexedValue.val.build().reverse(),
            bLexedValue.currentInputLine,
            bLexedValue.len)
       );
    :}
  ;

backwards_builtin_types_list ::=
    builtin_type:t COMMA:c backwards_builtin_types_list:tail
    {:
       LexedValue<TypeProvider> tLexedVal = (LexedValue<TypeProvider>)t.value;
       LexedValue<ImmutableList.Builder<TypeProvider>> tailLexedVal = (LexedValue<ImmutableList.Builder<TypeProvider>>)tail.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(tLexedVal.currentInputLine, t.right), new Line(c.currentInputLine, cright), new Line(tailLexedVal.currentInputLine, tail.right));
       int startCol = min(t.left, cleft, tail.left);
       int endCol = max(t.left + tLexedVal.len, cleft + c.len, tail.left + tailLexedVal.len);

       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          new LexedValue(
            tailLexedVal.val.add(tLexedVal.val),
            currentLinesSupplier,
            tailLexedVal.len)
       );
    :}
  | builtin_type:t
    {:
       RESULT = new Symbol(
          -1,
          t.left,
          t.right, // line number
          new LexedValue(
            ImmutableList.<TypeProvider>builder().add(((LexedValue<TypeProvider>) t.value).val),
            ((LexedValue)t.value).currentInputLine,
            ((LexedValue)t.value).len)
       );
    :}
  ;

identifier_assignment ::=
    IDENTIFIER:identifier ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new AssignmentStmt(identifier.val, e); :}
  ;

trashcan_assignment ::=
    UNDERSCORE ASSIGNMENT identifier:identifier SEMICOLON
    {: RESULT = new TrashcanAssignmentStmt(identifier); :}
  | UNDERSCORE ASSIGNMENT function_call_expr:function_call SEMICOLON
    {: RESULT = new TrashcanAssignmentStmt(function_call); :}
  | UNDERSCORE ASSIGNMENT provider_function_call_expr:provider_call SEMICOLON
    {: RESULT = new TrashcanAssignmentStmt(provider_call); :}
  | UNDERSCORE ASSIGNMENT input:input_call SEMICOLON
    {: RESULT = new TrashcanAssignmentStmt(input_call); :}

  | // These only exist to allow you to still call procedures with return type generics.
    UNDERSCORE ASSIGNMENT LPAR:lp builtin_type:asserted_type RPAR:rp function_call_expr:function_call SEMICOLON
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(((LexedValue)asserted_type.value).currentInputLine, asserted_type.right), new Line(rp.currentInputLine, rpright), new Line(function_call.currentLine, function_call.currentLineNumber));
       int startCol = min(lpleft, asserted_type.left, rpleft, function_call.startCol);
       int endCol = max(lpleft + lp.len, asserted_type.left + ((LexedValue)asserted_type.value).len, rpleft + rp.len, function_call.endCol);

       RESULT = new TrashcanAssignmentStmt(new CastExpr(((LexedValue<TypeProvider>)asserted_type.value).val, function_call, currentLinesSupplier, function_call.currentLineNumber, startCol, endCol));
    :}
  | UNDERSCORE ASSIGNMENT LPAR:lp builtin_type:asserted_type RPAR:rp provider_function_call_expr:provider_call SEMICOLON
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(((LexedValue)asserted_type.value).currentInputLine, asserted_type.right), new Line(rp.currentInputLine, rpright), new Line(provider_call.currentLine, provider_call.currentLineNumber));
       int startCol = min(lpleft, asserted_type.left, rpleft, provider_call.startCol);
       int endCol = max(lpleft + lp.len, asserted_type.left + ((LexedValue)asserted_type.value).len, rpleft + rp.len, provider_call.endCol);

       RESULT = new TrashcanAssignmentStmt(new CastExpr(((LexedValue<TypeProvider>)asserted_type.value).val, provider_call, currentLinesSupplier, provider_call.currentLineNumber, startCol, endCol));
    :}
  ;

identifier_increment_stmt ::=
    identifier_increment:i SEMICOLON
    {: RESULT = new IncrementStmt(i); :}
  ;

identifier_increment ::=
    INCREMENT:inc identifier:i
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(inc.currentInputLine, incright), new Line(i.currentLine, i.currentLineNumber));
       int startCol = min(incleft, i.startCol);
       int endCol = max(incleft + inc.len, i.endCol);

       RESULT = new IncrementExpr(i, /*preIncrement=*/true, currentLinesSupplier, i.currentLineNumber, startCol, endCol);
    :}
  | identifier:i INCREMENT:inc
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(i.currentLine, i.currentLineNumber), new Line(inc.currentInputLine, incright));
       int startCol = min(i.startCol, incleft);
       int endCol = max(i.endCol, incleft + inc.len);

       RESULT = new IncrementExpr(i, /*preIncrement=*/false, currentLinesSupplier, incright, startCol, endCol);
    :}
  ;

identifier_decrement_stmt ::=
    identifier_decrement:i SEMICOLON
    {: RESULT = new DecrementStmt(i); :}
  ;

identifier_decrement ::=
    DECREMENT:d identifier:i
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(d.currentInputLine, dright), new Line(i.currentLine, i.currentLineNumber));
       int startCol = min(dleft, i.startCol);
       int endCol = max(dleft + d.len, i.endCol);

       RESULT = new DecrementExpr(i, /*preDecrement=*/true, currentLinesSupplier, i.currentLineNumber, startCol, endCol);
    :}
  | identifier:i DECREMENT:d
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(i.currentLine, i.currentLineNumber), new Line(d.currentInputLine, dright));
       int startCol = min(i.startCol, dleft);
       int endCol = max(i.endCol, dleft + d.len);

       RESULT = new DecrementExpr(i, /*preDecrement=*/false, currentLinesSupplier, dright, startCol, endCol);
    :}
  ;

list_element_assignment ::=
    collection_subscript:l ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new ListElementAssignmentStmt(l, e); :}
  ;

list_append_stmt ::=
    APPEND LPAR expr:l COMMA expr:e RPAR SEMICOLON
    {: RESULT = new AppendElementToListStmt(l, e); :}
  ;

// In reality, right now expr is taking on multiple types and this is unchecked. Runtime failures are allowed in this
// language at the moment. Fix this later, for now, explicit casting between bool and number have to be done carefully.
expr ::=
    MINUS:m expr:e
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(m.currentInputLine, mright), new Line(e.currentLine, e.currentLineNumber));
       int startCol = min(mleft, e.startCol);
       int endCol = max(mleft + m.len, e.endCol);

       RESULT = new NegateNumericExpr(e, currentLinesSupplier, e.currentLineNumber, startCol, endCol);
    :}
  | expr:a PLUS:p expr:b
    {:
       RESULT = constructBinaryExpr(a, p, pleft, pright, b, (currentLinesSupplier) -> (startCol, endCol) -> new AddNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | identifier_increment:i
    {: RESULT = i; :}
  | identifier_decrement:i
    {: RESULT = i; :}
  | expr:a MINUS:m expr:b
    {:
       RESULT = constructBinaryExpr(a, m, mleft, mright, b, (currentLinesSupplier) -> (startCol, endCol) -> new SubtractNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a MULTIPLY:m expr:b
    {:
       RESULT = constructBinaryExpr(a, m, mleft, mright, b, (currentLinesSupplier) -> (startCol, endCol) -> new MultiplyNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a DIVIDE:d expr:b
    {:
       RESULT = constructBinaryExpr(a, d, dleft, dright, b, (currentLinesSupplier) -> (startCol, endCol) -> new DivideNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a MODULUS:m expr:b
    {:
       RESULT = constructBinaryExpr(a, m, mleft, mright, b, (currentLinesSupplier) -> (startCol, endCol) -> new ModulusNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a EXPONENTIATE:ex expr:b
    {:
       RESULT = constructBinaryExpr(a, ex, exleft, exright, b, (currentLinesSupplier) -> (startCol, endCol) -> new ExponentiateNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a IN:in expr:b
    {:
       RESULT = constructBinaryExpr(a, in, inleft, inright, b, (currentLinesSupplier) -> (startCol, endCol) -> new InBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | parenthesized_expr:p
    {: RESULT = p; :}
  | LOG_PREFIX:log float:float_base LPAR:lp expr:arg RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(log.currentInputLine, logright), new Line(float_base.currentLine, float_base.currentLineNumber), new Line(lp.currentInputLine, lpright), new Line(arg.currentLine, arg.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(logleft, float_base.startCol, lpleft, arg.startCol, rpleft);
       int endCol = max(logleft + log.len, float_base.endCol, lpleft + lp.len, arg.endCol, rpleft + rp.len);

       RESULT = new LogNumericExpr(arg, float_base, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | LOG_PREFIX:log integer:int_base LPAR:lp expr:arg RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(log.currentInputLine, logright), new Line(int_base.currentLine, int_base.currentLineNumber), new Line(lp.currentInputLine, lpright), new Line(arg.currentLine, arg.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(logleft, int_base.startCol, lpleft, arg.startCol, rpleft);
       int endCol = max(logleft + log.len, int_base.endCol, lpleft + lp.len, arg.endCol, rpleft + rp.len);

       RESULT = new LogNumericExpr(arg, int_base, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | NUMERIC_BOOL:num LPAR:lp expr:b RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(num.currentInputLine, numright), new Line(lp.currentInputLine, lpright), new Line(b.currentLine, b.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(numleft, lpleft, b.startCol, rpleft);
       int endCol = max(numleft + num.len, lpleft + lp.len, b.endCol, rpleft + rp.len);

       RESULT = new NumericBoolNumericExpr(b, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | input:i
    {: RESULT = i; :}
  | is_input_ready:i
    {: RESULT = i; :}
  | list:l
    {: RESULT = l; :}
  | map:m
    {: RESULT = m; :}
  | collection_subscript:l
    {: RESULT = l; :}
  | LEN:len LPAR:lp expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(len.currentInputLine, lenright), new Line(lp.currentInputLine, lpright), new Line(e.currentLine, e.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(lenleft, lpleft, e.startCol, rpleft);
       int endCol = max(lenleft + len.len, lpleft + lp.len, e.endCol, rpleft + rp.len);

       RESULT = new LenExpr(e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | bool_expr:b
    {: RESULT = b; :}
  | fmt_string:fs_symbol
    {:
       LexedValue<ImmutableList<ImmutableList.Builder>> fsLexedValue = (LexedValue<ImmutableList<ImmutableList.Builder>>) fs_symbol.value;
       ImmutableList<ImmutableList.Builder> fs = fsLexedValue.val;
       RESULT = new FormatStringExpr(fs.get(0).build().reverse(), fs.get(1).build().reverse(), fsLexedValue.currentInputLine, fs_symbol.right, fs_symbol.left, fs_symbol.left + fsLexedValue.len);
    :}
  | term:t
    {: RESULT = t; :}
  | function_call_expr:f
    {: RESULT = f; :}
  | lambda_function_expr:lf
    {: RESULT = lf; :}
  | typed_lambda_function_expr:tlf
    {: RESULT = tlf; :}
  | provider_function_call_expr:pf
    {: RESULT = pf; :}
  | builder_method_call_expr:b
    {: RESULT = b; :}
  | builder_full_build:b
    {: RESULT = b; :}
  | tuple:t
    {: RESULT = t; :}
  | set:s
    {: RESULT = s; :}
  | LPAR:lp builtin_type:asserted_type RPAR:rp expr:casted_expr
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(((LexedValue)asserted_type.value).currentInputLine, asserted_type.right), new Line(rp.currentInputLine, rpright), new Line(casted_expr.currentLine, casted_expr.currentLineNumber));
       int startCol = min(lpleft, asserted_type.left, rpleft, casted_expr.startCol);
       int endCol = max(lpleft + lp.len, asserted_type.left + ((LexedValue)asserted_type.value).len, rpleft + rp.len, casted_expr.endCol);

       RESULT = new CastExpr(((LexedValue<TypeProvider>)asserted_type.value).val, casted_expr, currentLinesSupplier, casted_expr.currentLineNumber, startCol, endCol);
    :}
  | error:e
    // TODO(steving) This is super helpful, do the same thing for stmts.
    // There's been some syntax error in an expression somewhere.. meaning that this expression is getting thrown away
    // in order to continue checking for other errors in the input program. So "repair" the program by giving it some
    // arbitrary Expr that won't complain a second time during AST type checking.
    {:
       RESULT = new Expr(ImmutableList.of(), () -> {throw new RuntimeException("Internal Compiler Error: Should be unreachable.");}, -1, -1, -1) {
          public Type getValidatedExprType(ScopedHeap unused) {
            return Types.UNDECIDED;
          }
          public StringBuilder generateJavaSourceBodyOutput(ScopedHeap unused) {
            return new StringBuilder();
          }
          public Object generateInterpretedOutput(ScopedHeap unused) {
            return null;
          }
          public void logTypeError(Exception unused) {
            // Intentionally do not re-log this error.
          }
       };
    :}
  ;

parenthesized_expr ::=
    LPAR:lp expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(e.currentLine, e.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(lpleft, e.startCol, rpleft);
       int endCol = max(lpleft + lp.len, e.endCol, rpleft + rp.len);

       RESULT = new ParenthesizedExpr(e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  ;

input ::=
    INPUT:i LPAR:lp STRING:prompt RPAR:rp
    {:
       RESULT = constructInputExpr(Optional.of(prompt), promptleft, promptright, i, ileft, iright, lp, lpleft, lpright, rp, rpleft, rpright);
    :}
  | INPUT:i LPAR:lp RPAR:rp
    {:
       RESULT = constructInputExpr(Optional.empty(), -1, -1, i, ileft, iright, lp, lpleft, lpright, rp, rpleft, rpright);
    :}
  ;

is_input_ready ::=
    IS_INPUT_READY LPAR RPAR
    {:
       RESULT = new IsInputReadyExpr();
    :}
  ;

list ::=
    LBRACKET:lb args_list:args RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lb.currentInputLine, lbright), new Line(((LexedValue) args.value).currentInputLine, args.right), new Line(rb.currentInputLine, rbright));
       int startCol = min(lbleft, args.left, rbleft);
       int endCol = max(lbleft + lb.len, args.left + ((LexedValue) args.value).len, rbleft + rb.len);

       // Notice that we reverse the list before handing it to the ListExpr node because it was collected backwards.
       RESULT = new ListExpr(((LexedValue<ImmutableList.Builder<Expr>>) args.value).val.build().reverse(), currentLinesSupplier, rbright, startCol, endCol);
    :}
  | LBRACKET:lb RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lb.currentInputLine, lbright), new Line(rb.currentInputLine, rbright));
       int startCol = min(lbleft, rbleft);
       int endCol = max(lbleft + lb.len, rbleft + rb.len);

       RESULT = new ListExpr(currentLinesSupplier, rbright, startCol, endCol);
    :}
  ;

map ::=
    LCURLY:lc RCURLY:rc
    {:
      RESULT = new MapExpr(ImmutableList.of(), joinExprLines(new Line(lc.currentInputLine, lcright), new Line(rc.currentInputLine, rcright)), rcright, min(lcleft, rcleft), max(lcleft + lc.len, rcleft + rc.len));
    :}
  | LCURLY:lc map_initializer_kv_list:initializer RCURLY:rc
    {:
      RESULT = new MapExpr(initializer.build().reverse(), joinExprLines(new Line(lc.currentInputLine, lcright), new Line(rc.currentInputLine, rcright)), rcright, min(lcleft, rcleft), max(lcleft + lc.len, rcleft + rc.len));
    :}
  ;

map_initializer_kv_list ::=
    expr:k COLON expr:v COMMA map_initializer_kv_list:tail
    {:
      RESULT = tail.add(ImmutableList.of(k, v));
    :}
  | expr:k COLON expr:v
    {:
      RESULT = ImmutableList.builder().add(ImmutableList.of(k, v));
    :}
  ;

tuple ::=
    // Tuples distinguish themselves from parenthesized expressions by having at least one comma.
    LPAR:lp expr:head COMMA:c args_list:tailValues RPAR:rp
    {:
       RESULT = (TupleExpr) constructSetOrTuple(lp, lpleft, lpright, head, c, cleft, cright, tailValues, rp, rpleft, rpright, (values, lines) -> (startCol, endCol) -> new TupleExpr(values, lines, rpright, startCol, endCol));
    :}
  ;

set ::=
    // Sets distinguish themselves from parenthesized expressions by having at least one comma, and tuples by {} instead of ().
    LCURLY:lp expr:head COMMA:c args_list:tailValues RCURLY:rp
    {:
       RESULT = (SetExpr) constructSetOrTuple(lp, lpleft, lpright, head, c, cleft, cright, tailValues, rp, rpleft, rpright, (values, lines) -> (startCol, endCol) -> new SetExpr(values, lines, rpright, startCol, endCol));
    :}
  ;

args_list ::=
    expr:head COMMA:c args_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(head.currentLine, head.currentLineNumber), new Line(c.currentInputLine, cright), new Line(((LexedValue)tail.value).currentInputLine, tail.right));
       int startCol = min(head.startCol, cleft, tail.left);
       int endCol = max(head.endCol, cleft + c.len, tail.left + ((LexedValue) tail.value).len);

       // Notice that we're building this list in reverse order, just by the order of the parser recursively identifying
       // each expr in the list.
       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableList.Builder<Expr>>) tail.value).val.add(head),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | expr:e
    {:
       RESULT = new Symbol(
          -1,
          e.startCol,
          e.currentLineNumber, // line number
          new LexedValue(
            ImmutableList.<Expr>builder().add(e),
            e.currentLine,
            e.endCol - e.startCol)
       );
    :}
  ;

collection_subscript ::=
    // Support arbitrarily repeated subscripting. CollectionSubscriptExpr node will check that there's the right levels of
    // nesting available for the given number of subscripts in this specific context.
    collection_subscript:l LBRACKET:lb expr:e RBRACKET:rb
    {:
       RESULT = constructCollectionSubscriptExpr(l, lb, lbleft, lbright, e, rb, rbleft, rbright);
    :}
  | list:l LBRACKET:lb expr:e RBRACKET:rb
    {:
       RESULT = constructCollectionSubscriptExpr(l, lb, lbleft, lbright, e, rb, rbleft, rbright);
    :}
  | term:t LBRACKET:lb expr:e RBRACKET:rb
    {:
       RESULT = constructCollectionSubscriptExpr(t, lb, lbleft, lbright, e, rb, rbleft, rbright);
    :}
  | function_call_expr:f LBRACKET:lb expr:e RBRACKET:rb
    {:
       RESULT = constructCollectionSubscriptExpr(f, lb, lbleft, lbright, e, rb, rbleft, rbright);
    :}
  | provider_function_call_expr:f LBRACKET:lb expr:e RBRACKET:rb
    {:
       RESULT = constructCollectionSubscriptExpr(f, lb, lbleft, lbright, e, rb, rbleft, rbright);
    :}
  | parenthesized_expr:p LBRACKET:lb expr:e RBRACKET:rb
    {:
       RESULT = constructCollectionSubscriptExpr(p, lb, lbleft, lbright, e, rb, rbleft, rbright);
    :}
  ;

bool_expr ::=
    equality:b
    {: RESULT = b; :}
  | inequality:b
    {: RESULT = b; :}
  | bool_arithmetic:b
    {: RESULT = b; :}
  ;

// This calculator can evaluate an equality check of expressions.
equality ::=
    expr:a EQUALS:e expr:b
    {:
       RESULT = constructBinaryExpr(a, e, eleft, eright, b, (currentLinesSupplier) -> (startCol, endCol) -> new EqualsBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a NOT_EQUALS:ne expr:b
    {:
       RESULT = constructBinaryExpr(a, ne, neleft, neright, b, (currentLinesSupplier) -> (startCol, endCol) -> new NotEqualsBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  ;

if_else_chain_stmt ::=
    if_stmt:leading_if_stmt else_if_stmt_chain:else_if_chain
    {:
       leading_if_stmt.setNextCondition(else_if_chain);
       RESULT = leading_if_stmt;
    :}
  | if_stmt:if_stmt else_stmt:trailing_else_stmt
    {:
       if_stmt.setTerminalElseClause(trailing_else_stmt);
       RESULT = if_stmt;
    :}
  | if_stmt:if_stmt
    {: RESULT = if_stmt; :}
  ;

if_stmt ::=
    IF LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new IfStmt(e, stmt_list); :}
  ;

else_if_stmt_chain ::=
    else_if_stmt:head else_if_stmt_chain:tail
    {:
       head.setNextCondition(tail);
       RESULT = head;
    :}
  | else_if_stmt:else_if_stmt else_stmt:trailing_else_stmt
    {:
       else_if_stmt.setTerminalElseClause(trailing_else_stmt);
       RESULT = else_if_stmt;
    :}
  | else_if_stmt:else_if_stmt
    {: RESULT = else_if_stmt; :}
  ;

else_if_stmt ::=
    ELSE if_stmt:else_if_stmt
    {: RESULT = else_if_stmt; :}
  ;

// We can simply return the StmtListNode itself because this is actually gonna be run by the IfStmt it's associated
// with.
else_stmt ::=
    ELSE LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = stmt_list; :}
  ;

while_stmt ::=
    WHILE LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new WhileStmt(e, stmt_list); :}
  ;

struct_definition_stmt ::=
    STRUCT_TYPE IDENTIFIER:name LCURLY function_args_types_list:backwards_field_types RCURLY
    {:
       // This is a named struct definition. You can construct multiple instances of this type.
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_field_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       RESULT = new StructDefinitionStmt(name.val, fieldTypesMap, /*immutable=*/ false);
    :}
  | LCURLY function_args_types_list:backwards_field_types RCURLY
    {:
       // This is an anonymous struct definition. Can construct once, but it'll be a unique type.
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_field_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       RESULT = new StructDefinitionStmt(fieldTypesMap, /*immutable=*/ false);
    :}
  | IMMUTABLE STRUCT_TYPE IDENTIFIER:name LCURLY function_args_types_list:backwards_field_types RCURLY
    {:
       // This is a named struct definition. You can construct multiple instances of this type.
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_field_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       RESULT = new StructDefinitionStmt(name.val, fieldTypesMap, /*immutable=*/ true);
    :}
  | IMMUTABLE LCURLY function_args_types_list:backwards_field_types RCURLY
    {:
       // This is an anonymous struct definition. Can construct once, but it'll be a unique type.
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_field_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       RESULT = new StructDefinitionStmt(fieldTypesMap, /*immutable=*/ true);
    :}
  ;

function_definition_stmt ::=
   FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new FunctionDefinitionStmt(name.val, argTypesMap, outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new FunctionDefinitionStmt(name.val, argTypesMap, Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
    :}
  | BLOCKING FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new FunctionDefinitionStmt(name.val, argTypesMap, outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR BLOCKING FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new FunctionDefinitionStmt(name.val, argTypesMap, Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new FunctionDefinitionStmt(name.val, argTypesMap, outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new FunctionDefinitionStmt(name.val, argTypesMap, Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  ;

generic_function_definition_stmt ::=
   FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(name.val, /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
 | REQUIRES LPAR required_contracts:required_contracts RPAR FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.val, (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
 | BLOCKING FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(name.val, /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
   :}
 | REQUIRES LPAR required_contracts:required_contracts RPAR BLOCKING FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
   {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.val, (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
   :}
  | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.val, /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  | REQUIRES LPAR required_contracts:required_contracts RPAR generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
     // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     returnTypeHolder.set(outputTypeProvider);
     returnTypeHolder = null;
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.val, (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  ;

generic_blocking_on ::=
    BLOCKING COLON identifier_bar_sep_list:i
    {:
      RESULT = i.build().reverse();
    :}
  ;

identifier_bar_sep_list ::=
    IDENTIFIER:i BAR identifier_bar_sep_list:b
    {:
      RESULT = b.add(i.val);
    :}
  | IDENTIFIER:i
    {:
      RESULT = ImmutableList.<String>builder().add(i.val);
    :}
  ;

maybe_blocking_procedure_types ::=
    MAYBE_BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.val.resolveType(scopedHeap)), outputTypeLexedVal.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING PROVIDER_FUNCTION_TYPE:p L_ANGLE_BRACKET:la builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(outputTypeLexedVal.val.resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  ;

// TODO(steving) I need to enable generic functions to be generic over only a partial subset of the required
// TODO(steving) Contract's type params.
required_contracts ::=
    IDENTIFIER:contract_name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET COMMA required_contracts:tail
    {:
      ImmutableList<Type> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse().stream()
          .map(g -> Types.$GenericTypeParam.forTypeParamName(g)).collect(ImmutableList.toImmutableList());
      RESULT = tail.put(contract_name.val, genericTypesList);
    :}
  | IDENTIFIER:contract_name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET
    {:
      ImmutableList<Type> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse().stream()
          .map(g -> Types.$GenericTypeParam.forTypeParamName(g)).collect(ImmutableList.toImmutableList());
      RESULT = ImmutableListMultimap.<String, ImmutableList<Type>>builder().put(contract_name.val, genericTypesList);
    :}
  ;

lambda_function_expr ::=
    IDENTIFIER:arg_name ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(a.currentInputLine, aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(arg_nameleft, aleft, implicit_return_exprleft);
      int endCol = max(arg_nameleft + arg_name.len, aleft + a.len, implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(ImmutableList.of(arg_name.val), new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_expr.currentLineNumber, startCol, endCol);
    :}
  | IDENTIFIER:arg_name ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(a.currentInputLine, aright), new Line(lc.currentInputLine, lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.currentInputLine, rcright));
      int startCol = min(arg_nameleft, aleft, lcleft, rcleft);
      int endCol = max(arg_nameleft + arg_name.len, aleft + a.len, lcleft + lc.len, rcleft + rc.len);

      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      RESULT = new LambdaExpr(ImmutableList.of(arg_name.val), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  | LAMBDA:lam LPAR:lp IDENTIFIER:first_arg_name COMMA:c identifier_list:arg_names RPAR:rp ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lam.currentInputLine, lamright), new Line(lp.currentInputLine, lpright), new Line(first_arg_name.currentInputLine, first_arg_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue) arg_names.value).currentInputLine, arg_namesright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(lamleft, lpleft, first_arg_nameleft, cleft, arg_names.left, rpleft, aleft, implicit_return_exprleft);
      int endCol = max(lamleft + lam.len, lpleft + lp.len, first_arg_nameleft + first_arg_name.len, cleft + c.len, arg_names.left + ((LexedValue)arg_names.value).len, rpleft + rp.len, aleft + a.len, implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(((LexedValue<ImmutableList.Builder<String>>)arg_names.value).val.add(first_arg_name.val).build().reverse(), new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_exprright, startCol, endCol);
    :}
  | LAMBDA:lam LPAR:lp IDENTIFIER:first_arg_name COMMA:c identifier_list:arg_names RPAR:rp ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lam.currentInputLine, lamright), new Line(lp.currentInputLine, lpright), new Line(first_arg_name.currentInputLine, first_arg_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue)arg_names.value).currentInputLine, arg_namesright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(lc.currentInputLine, lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.currentInputLine, rcright));
      int startCol = min(lamleft, lpleft, first_arg_nameleft, cleft, arg_names.left, rpleft, aleft, lcleft, rcleft);
      int endCol = max(lamleft + lam.len, lpleft + lp.len, first_arg_nameleft + first_arg_name.len, cleft + c.len, arg_names.left + ((LexedValue)arg_names.value).len, rpleft + rp.len, aleft + a.len, lcleft + lc.len, rcleft + rc.len);

      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      RESULT = new LambdaExpr(((LexedValue<ImmutableList.Builder<String>>)arg_names.value).val.add(first_arg_name.val).build().reverse(), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  | LPAR:lp RPAR:rp ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lp.currentInputLine, lpright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(lpleft, rpleft, aleft, implicit_return_expr.startCol);
      int endCol = max(lpleft + lp.len, rpleft + rp.len, aleft + a.len, implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_expr.currentLineNumber, startCol, endCol);
    :}
  | LPAR:lp RPAR:rp ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
       // We won't throw type errors at this level for the StmtListNode itself (that'll be handled on the Exprs contained w/in)
       // so intentionally ignore the StmtListNode here for error lines. Pointers may be slightly off if programmer has
       // terrible indentation but in that case, fuck em.
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(lc.currentInputLine, lcright), new Line(() -> "...", aright + 2 > rcright ? aright : aright + 1), new Line(rc.currentInputLine, rcright));
       int startCol = min(lpleft, rpleft, aleft, lcleft, rcleft);
       int endCol = max(lpleft + lp.len, rpleft + rp.len, aleft + a.len, lcleft + lc.len, rcleft + rc.len);

       // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
       RESULT = new LambdaExpr(stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  ;

// TODO(steving) Lambda syntax has been complicated by parsing constraints. I don't actually want the `lambda` keyword
// TODO(steving) EVER. Figure out a way to actually define all lambda forms w/o ever using `lambda` keyword.
typed_lambda_function_expr ::=
    LPAR:lp function_args_types_list:backwards_arg_types RPAR:rp ARROW:a builtin_type:return_type LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {: // FUNCTION
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(((LexedValue) backwards_arg_types.value).currentInputLine, backwards_arg_types.right), new Line(a.currentInputLine, aright), new Line(((LexedValue) return_type.value).currentInputLine, return_type.right), new Line(lc.currentInputLine, lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.currentInputLine, rcright));
      int startCol = min(lpleft, backwards_arg_types.left, rpleft, aleft, return_type.left, lcleft, rcleft);
      int endCol = max(lpleft + lp.len, backwards_arg_types.left + ((LexedValue) backwards_arg_types.value).len, aleft + a.len, lcleft + lc.len, rcleft + rc.len);

      ImmutableMap<String, TypeProvider> args =
        ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build();
      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      LambdaExpr lambda = new LambdaExpr(args.keySet().asList().reverse(), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
      RESULT = new CastExpr(
        (scopedHeap) ->
          Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(
            args.values().asList().reverse().stream().map(argTypeProvider -> argTypeProvider.resolveType(scopedHeap))
              .collect(ImmutableList.toImmutableList()),
            ((LexedValue<TypeProvider>) return_type.value).val.resolveType(scopedHeap),
            /*explicitlyAnnotatedBlocking=*/ false),
        lambda,
        currentLinesSupplier, rcright, startCol, endCol
      );
    :}
  | LAMBDA:lam LPAR:lp function_args_types_list:backwards_arg_types RPAR:rp ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {: // CONSUMER
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lp.currentInputLine, lpright), new Line(((LexedValue) backwards_arg_types.value).currentInputLine, backwards_arg_types.right), new Line(lp.currentInputLine, lpright), new Line(a.currentInputLine, aright), new Line(lc.currentInputLine, lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.currentInputLine, rcright));
      int startCol = min(lpleft, backwards_arg_types.left, rpleft, aleft, lcleft, rcleft);
      int endCol = max(lpleft + lp.len, backwards_arg_types.left + ((LexedValue)backwards_arg_types.value).len, rpleft + rp.len, aleft + a.len, lcleft + lc.len, rcleft + rc.len);

      ImmutableMap<String, TypeProvider> args =
        ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build();
      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      LambdaExpr lambda = new LambdaExpr(args.keySet().asList().reverse(), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
      RESULT = new CastExpr(
        (scopedHeap) ->
          Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(
            args.values().asList().reverse().stream().map(argTypeProvider -> argTypeProvider.resolveType(scopedHeap))
              .collect(ImmutableList.toImmutableList()),
            /*explicitlyAnnotatedBlocking=*/ false),
        lambda,
        currentLinesSupplier, rcright, startCol, endCol
      );
    :}
  | LAMBDA LPAR:lp RPAR:rp ARROW:a builtin_type:return_type LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {: // PROVIDER
       // We won't throw type errors at this level for the StmtListNode itself (that'll be handled on the Exprs contained w/in)
       // so intentionally ignore the StmtListNode here for error lines. Pointers may be slightly off if programmer has
       // terrible indentation but in that case, *shrug*.
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(((LexedValue) return_type.value).currentInputLine, return_type.right), new Line(lc.currentInputLine, lcright), new Line(() -> "...", aright + 2 > rcright ? aright : aright + 1), new Line(rc.currentInputLine, rcright));
       int startCol = min(lpleft, rpleft, aleft, return_type.left, lcleft, rcleft);
       int endCol = max(lpleft + lp.len, rpleft + rp.len, aleft + a.len, return_type.left + ((LexedValue) return_type.value).len, lcleft + lc.len, rcleft + rc.len);

       // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
       LambdaExpr lambda = new LambdaExpr(stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
       RESULT = new CastExpr(
         (scopedHeap) ->
           Types.ProcedureType.ProviderType.typeLiteralForReturnType(
             ((LexedValue<TypeProvider>) return_type.value).val.resolveType(scopedHeap),
             /*explicitlyAnnotatedBlocking=*/ false),
         lambda,
         currentLinesSupplier, rcright, startCol, endCol
       );
    :}
  ;

identifier_list ::=
    IDENTIFIER:arg_name COMMA:c identifier_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue)tail.value).currentInputLine, tail.right));
       int startCol = min(arg_nameleft, cleft);
       int endCol = max(arg_nameleft + arg_name.len, cleft + c.len);
       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableList.Builder<String>>)tail.value).val.add(arg_name.val),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name
    {:
       RESULT = new Symbol(
          -1,
          arg_nameleft,
          arg_nameright, // line number
          new LexedValue(
            ImmutableList.<String>builder().add(arg_name.val),
            arg_name.currentInputLine,
            arg_name.len)
       );
    :}
  ;

consumer_function_definition_stmt ::=
    CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new ConsumerFunctionDefinitionStmt(name.val, argTypesMap, stmt_list, /*explicitlyAnnotatedBlocking=*/false);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
        ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new ConsumerFunctionDefinitionStmt(name.val, argTypesMap, Optional.of(injectedKeysList), stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
    :}
  | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new ConsumerFunctionDefinitionStmt(name.val, argTypesMap, stmt_list, /*explicitlyAnnotatedBlocking=*/true);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
        ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new ConsumerFunctionDefinitionStmt(name.val, argTypesMap, Optional.of(injectedKeysList), stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new ConsumerFunctionDefinitionStmt(name.val, argTypesMap, Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
        ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new ConsumerFunctionDefinitionStmt(name.val, argTypesMap, Optional.of(injectedKeysList), stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  ;

generic_consumer_function_definition_stmt ::=
   CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
   {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(name.val, /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
 | REQUIRES LPAR required_contracts:required_contracts RPAR CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
   {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.val, (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
   :}
 | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
   {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(name.val, /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
   :}
 | REQUIRES LPAR required_contracts:required_contracts RPAR BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
   {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.val, (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
   :}
  | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.val, /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  | REQUIRES LPAR required_contracts:required_contracts RPAR generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
     // This production matched a function defined by a list of statements followed by a return Expr to eval.
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new GenericFunctionDefinitionStmt(
        name.val, (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, argTypesMap, /*optionalInjectedKeysTypes=*/Optional.empty(), stmt_list, /*explicitlyAnnotatedBlocking=*/null, Optional.of(generic_blocking_on));
    :}
  ;

provider_function_definition_stmt ::=
    PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      RESULT = new ProviderFunctionDefinitionStmt(name.val, outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new ProviderFunctionDefinitionStmt(name.val, Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false);
    :}
  | BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      RESULT = new ProviderFunctionDefinitionStmt(name.val, outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new ProviderFunctionDefinitionStmt(name.val, Optional.of(injectedKeysList), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true);
    :}
  ;

generic_provider_function_definition_stmt ::=
    PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;

       ImmutableList<String> genericTypesList =
         ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
      RESULT = new GenericFunctionDefinitionStmt(name.val, /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, ImmutableMap.of(), /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
    :}
  | REQUIRES LPAR required_contracts:required_contracts RPAR PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;

       ImmutableList<String> genericTypesList =
         ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
      RESULT = new GenericFunctionDefinitionStmt(name.val, (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, ImmutableMap.of(), /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/false, Optional.empty());
    :}
  | BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;

       ImmutableList<String> genericTypesList =
         ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
      RESULT = new GenericFunctionDefinitionStmt(name.val, /*requiredContracts=*/ImmutableListMultimap.of(), genericTypesList, ImmutableMap.of(), /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  | REQUIRES LPAR required_contracts:required_contracts RPAR BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;

       ImmutableList<String> genericTypesList =
         ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
      RESULT = new GenericFunctionDefinitionStmt(name.val, (ImmutableListMultimap<String,ImmutableList<Type>>) required_contracts.build(), genericTypesList, ImmutableMap.of(), /*optionalInjectedKeysTypes=*/Optional.empty(), outputTypeProvider, stmt_list, /*explicitlyAnnotatedBlocking=*/true, Optional.empty());
    :}
  ;

injected_keys_list ::=
    IDENTIFIER:key_name COLON:colon builtin_type:t COMMA:comma injected_keys_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentInputLine, key_nameright), new Line(colon.currentInputLine, colonright), new Line(((LexedValue) t.value).currentInputLine, t.right), new Line(comma.currentInputLine, commaright), new Line(((LexedValue) tail.value).currentInputLine, tail.right));
       int startCol = min(key_nameleft, colonleft, t.left, commaleft, tail.left);
       int endCol = max(key_nameleft + key_name.len, colonleft + colon.len, t.left + ((LexedValue) t.value).len, commaleft + comma.len, tail.left + ((LexedValue) tail.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableList.Builder<InjectedKey>>) tail.value).val
              .add(new InjectedKey(key_name.val, ((LexedValue<TypeProvider>) t.value).val, Optional.empty())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:key_name COLON:colon builtin_type:t AS IDENTIFIER:alias COMMA:comma injected_keys_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentInputLine, key_nameright), new Line(colon.currentInputLine, colonright), new Line(((LexedValue) t.value).currentInputLine, t.right), new Line(comma.currentInputLine, commaright), new Line(((LexedValue) tail.value).currentInputLine, tail.right));
       int startCol = min(key_nameleft, colonleft, t.left, commaleft, tail.left);
       int endCol = max(key_nameleft + key_name.len, colonleft + colon.len, t.left + ((LexedValue) t.value).len, commaleft + comma.len, tail.left + ((LexedValue) tail.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableList.Builder<InjectedKey>>) tail.value).val
              .add(new InjectedKey(key_name.val, ((LexedValue<TypeProvider>) t.value).val, Optional.of(alias.val))),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:key_name COLON:c builtin_type:t
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentInputLine, key_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue) t.value).currentInputLine, t.right));
       int startCol = min(key_nameleft, cleft, t.left);
       int endCol = max(key_nameleft + key_name.len, cleft + c.len, t.left + ((LexedValue) t.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ImmutableList.<InjectedKey>builder().add(new InjectedKey(key_name.val, ((LexedValue<TypeProvider>) t.value).val, Optional.empty())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:key_name COLON:c builtin_type:t AS IDENTIFIER:alias
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentInputLine, key_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue) t.value).currentInputLine, t.right));
       int startCol = min(key_nameleft, cleft, t.left);
       int endCol = max(key_nameleft + key_name.len, cleft + c.len, t.left + ((LexedValue) t.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ImmutableList.<InjectedKey>builder().add(new InjectedKey(key_name.val, ((LexedValue<TypeProvider>) t.value).val, Optional.of(alias.val))),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

// TODO(steving) Be less lazy and don't bother using a Map where we should just be using a List of pairs....but Java is so garbage it doesn't have tuples so.....
// Note that we're again building this up backwards for convenience (remember that all guava collections respect ordering).
function_args_types_list ::=
    IDENTIFIER:arg_name COLON:colon builtin_type:t COMMA:comma function_args_types_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(colon.currentInputLine, colonright), new Line(((LexedValue) t.value).currentInputLine, t.right), new Line(comma.currentInputLine, commaright), new Line(((LexedValue) tail.value).currentInputLine, tail.right));
       int startCol = min(arg_nameleft, colonleft, t.left, commaleft, tail.left);
       int endCol = max(arg_nameleft + arg_name.len, colonleft + colon.len, t.left + ((LexedValue) t.value).len, commaleft + comma.len, tail.left + ((LexedValue) tail.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) tail.value).val.put(arg_name.val, ((LexedValue<TypeProvider>) t.value).val),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name COLON:c builtin_type:t
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue) t.value).currentInputLine, t.right));
       int startCol = min(arg_nameleft, cleft, t.left);
       int endCol = max(arg_nameleft + arg_name.len, cleft + c.len, t.left + ((LexedValue) t.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ImmutableMap.<String, TypeProvider>builder().put(arg_name.val, ((LexedValue<TypeProvider>) t.value).val),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

procedure_args_w_generic_blocking ::=
    IDENTIFIER:arg_name COLON maybe_blocking_procedure_types:maybe_blocking_proc COMMA procedure_args_w_generic_blocking:args_w_generic_blocking
    {:
      RESULT = args_w_generic_blocking.put(arg_name.val, maybe_blocking_proc);
    :}
  | IDENTIFIER:arg_name COLON builtin_type:t COMMA procedure_args_w_generic_blocking:args_w_generic_blocking
    {:
      RESULT = args_w_generic_blocking.put(arg_name.val, ((LexedValue<TypeProvider>) t.value).val);
    :}
  | IDENTIFIER:arg_name COLON maybe_blocking_procedure_types:maybe_blocking_proc
    {:
      RESULT = ImmutableMap.<String, TypeProvider>builder().put(arg_name.val, maybe_blocking_proc);
    :}
  | IDENTIFIER:arg_name COLON builtin_type:t
    {:
      RESULT = ImmutableMap.<String, TypeProvider>builder().put(arg_name.val, ((LexedValue<TypeProvider>) t.value).val);
    :}
  ;

return_stmt ::=
    RETURN expr:e SEMICOLON
    {:
      // All ReturnStmts belonging to the same procedure expect the same return type. Use this container to
      // act as a placeholder for the procedure to inject that context once the parsing bubbles back up.
      if (returnTypeHolder == null) {
        returnTypeHolder = new AtomicReference<>(); // Start it off empty.
      }
      RESULT = new ReturnStmt(e, returnTypeHolder);
    :}
  ;

// Just to make sure that graphs are somewhat consistent, you must either choose between putting the root node as the
// first or last node definition in the graph body. Let's encourage ordering these sanely because it can be hard to
// trace declarative code without a pattern.
graph_function_definition_stmt ::=
    GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphFunctionDefinitionStmt(
          name.val,
          argTypesMap,
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphFunctionDefinitionStmt(
          name.val,
          argTypesMap,
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new GraphFunctionDefinitionStmt(
          name.val,
          argTypesMap,
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
       RESULT = new GraphFunctionDefinitionStmt(
          name.val,
          argTypesMap,
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  ;

// Just to make sure that graphs are somewhat consistent, you must either choose between putting the root node as the
// first or last node definition in the graph body. Let's encourage ordering these sanely because it can be hard to
// trace declarative code without a pattern.
graph_provider_definition_stmt ::=
    GRAPH PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphProviderDefinitionStmt(
          name.val,
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | GRAPH PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphProviderDefinitionStmt(
          name.val,
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new GraphProviderDefinitionStmt(
          name.val,
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
       RESULT = new GraphProviderDefinitionStmt(
          name.val,
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  ;

graph_consumer_definition_stmt ::=
    GRAPH CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

       RESULT = new GraphConsumerDefinitionStmt(
          name.val,
          argTypesMap,
          root,
          non_root_nodes.build().reverse());
    :}
  | GRAPH CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

       RESULT = new GraphConsumerDefinitionStmt(
          name.val,
          argTypesMap,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new GraphConsumerDefinitionStmt(
          name.val,
          argTypesMap,
          Optional.of(injectedKeysList),
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
       RESULT = new GraphConsumerDefinitionStmt(
          name.val,
          argTypesMap,
          Optional.of(injectedKeysList),
          root,
          non_root_nodes.build().reverse());
    :}
  ;

root_node ::=
    ROOT IDENTIFIER:name LEFT_ARROW expr:expr SEMICOLON
    {: RESULT = new GraphNodeDefinitionStmt(name.val, expr); :}
  ;

non_root_node ::=
    NODE IDENTIFIER:name LEFT_ARROW expr:expr SEMICOLON
    {: RESULT = new GraphNodeDefinitionStmt(name.val, expr); :}
  ;

non_root_nodes_list ::=
    non_root_node:node non_root_nodes_list:tail
    {: RESULT = tail.add(node); :}
  | non_root_node:node
    {: RESULT = ImmutableList.<GraphNodeDefinitionStmt>builder().add(node); :}
  ;

node_reference ::=
    AT IDENTIFIER:identifier
    {: RESULT = new GraphNodeReferenceExpr(identifier.val, identifier.currentInputLine, identifierright, identifierleft, identifierleft + identifier.len); :}
  ;

contract_definition_stmt ::=
    CONTRACT IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LCURLY contract_signature_defs_list:contract_signature_defs_backwards RCURLY
    {:
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
      RESULT = new ContractDefinitionStmt(name.val, genericTypesList, contract_signature_defs_backwards.build().reverse());
    :}
  ;

contract_signature_defs_list ::=
    contract_procedure_signature_definition_stmt:signature contract_signature_defs_list:tail
    {:
      RESULT = tail.add(signature);
    :}
  | contract_procedure_signature_definition_stmt:signature
    {:
      RESULT = ImmutableList.<ContractProcedureSignatureDefinitionStmt>builder().add(signature);
    :}
  ;

contract_procedure_signature_definition_stmt ::=
   // FUNCTIONS
   FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), Optional.of(genericTypesList));
   :}
 | BLOCKING FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.of(genericTypesList));
   :}
 | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), Optional.of(genericTypesList));
   :}

   // CONSUMERS
 | CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), Optional.of(genericTypesList));
   :}
 | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.of(genericTypesList));
   :}
 | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).val.build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), Optional.of(genericTypesList));
   :}

   // PROVIDERS
 | PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.empty(), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.val, Optional.empty(), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
  ;

contract_implementation_stmt ::=
    IMPLEMENT IDENTIFIER:contract_name L_ANGLE_BRACKET builtin_types_list:concrete_types R_ANGLE_BRACKET AS IDENTIFIER:implementation_name LCURLY contract_implementations_list:contract_impls RCURLY
    {:
       RESULT = new ContractImplementationStmt(contract_name.val, implementation_name.val, ((LexedValue<ImmutableList<TypeProvider>>) concrete_types.value).val, contract_impls.build().reverse());
    :}
  ;

contract_implementations_list ::=
    function_definition_stmt:f contract_implementations_list:tail
    {: RESULT = tail.add(new ContractProcedureImplementationStmt(f)); :}
  | consumer_function_definition_stmt:c contract_implementations_list:tail
    {: RESULT = tail.add(new ContractProcedureImplementationStmt(c)); :}
  | provider_function_definition_stmt:p contract_implementations_list:tail
    {: RESULT = tail.add(new ContractProcedureImplementationStmt(p)); :}
  | generic_function_definition_stmt:f contract_implementations_list:tail
    {: RESULT = tail.add(constructContractProcImplStmtForGenericProcDefStmt(f)); :}
  | generic_consumer_function_definition_stmt:c contract_implementations_list:tail
    {: RESULT = tail.add(constructContractProcImplStmtForGenericProcDefStmt(c)); :}

  | function_definition_stmt:f
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(new ContractProcedureImplementationStmt(f)); :}
  | consumer_function_definition_stmt:c
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(new ContractProcedureImplementationStmt(c)); :}
  | provider_function_definition_stmt:p
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(new ContractProcedureImplementationStmt(p)); :}
  | generic_function_definition_stmt:f
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(constructContractProcImplStmtForGenericProcDefStmt(f)); :}
  | generic_consumer_function_definition_stmt:c
    {: RESULT = ImmutableList.<ContractProcedureImplementationStmt>builder().add(constructContractProcImplStmtForGenericProcDefStmt(c)); :}
  ;

pipe_chain_stmt ::=
    expr:source pipe_chain:p
    {:
       RESULT =
        new PipeChainStmt(
          source,
          ((ImmutableList.Builder<Object>) p.get(1)).build().reverse(), // chain exprs
          (Stmt) p.get(0) // sink stmt
        );
    :}
  ;

pipe_chain ::=
    PIPE_ARROW:a expr:expr pipe_chain:p
    {:
       // Finally, add the current expr in the pipe chain to the list builder where I'm collecting exprs.
       ((ImmutableList.Builder<Object>) p.get(1)).add(expr);
       RESULT = p;
    :}
  | PIPE_ARROW consumer_function_call_stmt:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW identifier_assignment:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW identifier_declaration:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW list_element_assignment:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW list_append_stmt:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  | PIPE_ARROW print:sink
    {:
       RESULT =
          ImmutableList.builder()
           .add(sink)
           .add(ImmutableList.builder())
           .build();
    :}
  ;

function_call_expr ::=
    IDENTIFIER:function_name LPAR:l args_list:args RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(function_name.currentInputLine, function_nameright), new Line(l.currentInputLine, lright), new Line(args), new Line(r.currentInputLine, rright));
       int startCol = min(function_nameleft, lleft, args.left, rleft);
       int endCol = max(function_nameleft + function_name.len, lleft + l.len, args.left + ((LexedValue)args.value).len, rleft + r.len);
       RESULT = new FunctionCallExpr(function_name.val, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).val.build().reverse(), currentLinesSupplier, rright, startCol, endCol);
    :}
  | IDENTIFIER:contract_name COLON_COLON IDENTIFIER:function_name LPAR:l args_list:args RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(function_name.currentInputLine, function_nameright), new Line(l.currentInputLine, lright), new Line(args), new Line(r.currentInputLine, rright));
       int startCol = min(function_nameleft, lleft, args.left, rleft);
       int endCol = max(function_nameleft + function_name.len, lleft + l.len, args.left + ((LexedValue)args.value).len, rleft + r.len);
       RESULT =
        new ContractFunctionCallExpr(
          contract_name.val,
          function_name.val,
          ((LexedValue<ImmutableList.Builder<Expr>>)args.value).val.build().reverse(),
          currentLinesSupplier, rright, startCol, endCol);
    :}
  ;

provider_function_call_expr ::=
    IDENTIFIER:provider_name LPAR:l RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(provider_name.currentInputLine, provider_nameright), new Line(l.currentInputLine, lright), new Line(r.currentInputLine, rright));
       int startCol = min(provider_nameleft, lleft, rleft);
       int endCol = max(provider_nameleft + provider_name.len, lleft + l.len, rleft + r.len);
       RESULT = new ProviderFunctionCallExpr(provider_name.val, currentLinesSupplier, rright, startCol, endCol);
    :}
  | IDENTIFIER:contract_name COLON_COLON IDENTIFIER:provider_name LPAR:l RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(provider_name.currentInputLine, provider_nameright), new Line(l.currentInputLine, lright), new Line(r.currentInputLine, rright));
       int startCol = min(provider_nameleft, lleft, rleft);
       int endCol = max(provider_nameleft + provider_name.len, lleft + l.len, rleft + r.len);
       RESULT = new ContractProviderFunctionCallExpr(contract_name.val, provider_name.val, currentLinesSupplier, rright, startCol, endCol);
    :}
  ;

consumer_function_call_stmt ::=
    IDENTIFIER:consumer_name LPAR args_list:args RPAR SEMICOLON
    {: RESULT = new ConsumerFunctionCallStmt(consumer_name.val, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).val.build().reverse()); :}
  | IDENTIFIER:contract_name COLON_COLON IDENTIFIER:consumer_name LPAR:l args_list:args RPAR:r SEMICOLON
    {: RESULT = new ContractConsumerFunctionCallStmt(contract_name.val, consumer_name.val, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).val.build().reverse()); :}
  ;

// TODO(steving) Generalize this to use the same approach as method calls.
// TODO(steving) We have no classes yet - so do this once classes & methods exist.
builder_full_build ::=
    builder_method_call_expr:b DOTBUILD:d
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(b), new Line(d.currentInputLine, dright));
       int startCol = Math.min(b.startCol, dleft);
       int endCol = Math.max(b.endCol, dleft + d.len);
       RESULT = new BuilderFullBuildMethodCallExpr(b, currentLinesSupplier, dright, startCol, endCol);
    :}
  ;

builder_method_call_expr ::=
    IDENTIFIER:built_type_name DOT:d BUILDER:b LPAR:l RPAR:r
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(built_type_name.currentInputLine, built_type_nameright), new Line(d.currentInputLine, dright), new Line(b.currentInputLine, bright), new Line(l.currentInputLine, lright), new Line(r.currentInputLine, rright));
       int startCol = min(built_type_nameleft, dleft, bleft, lleft, rleft);
       int endCol = max(built_type_nameleft + built_type_name.len, dleft + d.len, bleft + b.len, lleft + l.len, rleft + r.len);
       RESULT = new BuilderMethodCallExpr(built_type_name.val, currentLinesSupplier, rright, startCol, endCol);
    :}
  | IDENTIFIER:built_type_name DOT:d BUILDER:b LPAR:l RPAR:r builder_setter_chain:set_field_values
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(built_type_name.currentInputLine, built_type_nameright), new Line(d.currentInputLine, dright), new Line(b.currentInputLine, bright), new Line(l.currentInputLine, lright), new Line(r.currentInputLine, rright), new Line(set_field_values));
       int startCol = min(built_type_nameleft, dleft, bleft, lleft, rleft, set_field_valuesleft);
       int endCol = max(built_type_nameleft + built_type_name.len, dleft + d.len, bleft + b.len, lleft + l.len, rleft + r.len, set_field_values.left + ((LexedValue)set_field_values.value).len);
       RESULT = new BuilderMethodCallExpr(built_type_name.val, ((LexedValue<ImmutableMap.Builder<String, Expr>>)set_field_values.value).val.build(), currentLinesSupplier, set_field_valuesright, startCol, endCol);
    :}
  ;

builder_setter_call ::=
    DOT:dot IDENTIFIER:set_field_name LPAR:lpar expr:e RPAR:rpar
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(dot.currentInputLine, dotright), new Line(set_field_name.currentInputLine, set_field_nameright), new Line(lpar.currentInputLine, lparright), new Line(e), new Line(lpar.currentInputLine, lparright));
       int startCol = min(dotleft, set_field_nameleft, lparleft, e.startCol, rparleft);
       int endCol = max(dotleft + dot.len, set_field_nameleft + set_field_name.len, lparleft + lpar.len, e.endCol, rparleft + rpar.len);
       RESULT = new Symbol(
          -1,
          startCol,
          rparright, // rpar's line number
          new LexedValue(
            ImmutableMap.<String, Expr>builder().put(set_field_name.val, e),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

builder_setter_chain ::=
    builder_setter_call:head builder_setter_chain:tail
    {:
       ImmutableMap.Builder<String, Expr> headMapBuilder = ((LexedValue<ImmutableMap.Builder<String, Expr>>)head.value).val;
       ImmutableMap<String, Expr> tailMap = ((LexedValue<ImmutableMap.Builder<String, Expr>>)tail.value).val.build();
       RESULT = chainSymbols(headMapBuilder.putAll(tailMap), head, tail);
    :}
  | builder_setter_call:setter_call
    {: RESULT = setter_call; :}
  ;

inequality ::=
    expr:a L_ANGLE_BRACKET:l expr:b
    {:
       RESULT = constructBinaryExpr(a, l, lleft, lright, b, (currentLinesSupplier) -> (startCol, endCol) -> new LessThanBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a R_ANGLE_BRACKET:r expr:b
    {:
       RESULT = constructBinaryExpr(a, r, rleft, rright, b, (currentLinesSupplier) -> (startCol, endCol) -> new GreaterThanBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a LTE:lte expr:b
    {:
       RESULT = constructBinaryExpr(a, lte, lteleft, lteright, b, (currentLinesSupplier) -> (startCol, endCol) -> new LessThanOrEqualToBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a GTE:gte expr:b
    {:
       RESULT = constructBinaryExpr(a, gte, gteleft, gteright, b, (currentLinesSupplier) -> (startCol, endCol) -> new GreaterThanOrEqualToBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  ;

bool_arithmetic ::=
    expr:a AND:and expr:b
    {:
       RESULT = constructBinaryExpr(a, and, andleft, andright, b, (currentLinesSupplier) -> (startCol, endCol) -> new AndBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | expr:a OR:or expr:b
    {:
       RESULT = constructBinaryExpr(a, or, orleft, orright, b, (currentLinesSupplier) -> (startCol, endCol) -> new OrBoolExpr(a, b, currentLinesSupplier, bright, startCol, endCol));
    :}
  | NOT:n expr:a
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(n.currentInputLine, nright), new Line(a));
       int startCol = Math.min(nleft, a.startCol);
       int endCol = Math.max(a.endCol, nleft + n.len);
       RESULT = new NotBoolExpr(a, currentLinesSupplier, a.currentLineNumber, startCol, endCol);
    :}
  ;

fmt_string ::=
    FMT_STRING_PART:fs expr:e fmt_string:fswt
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(fs.currentInputLine, fsright), new Line(e.currentLine, e.currentLineNumber), new Line(((LexedValue) fswt.value).currentInputLine, fswt.right));
       int startCol = min(fsleft, e.startCol, fswt.left);
       int endCol = max(fsleft + fs.len, e.endCol, fswt.left + ((LexedValue) fswt.value).len);

       ImmutableList<ImmutableList.Builder> fswtList = ((LexedValue<ImmutableList<ImmutableList.Builder>>)fswt.value).val;
       fswtList.get(0).add(fs.val);
       fswtList.get(1).add(e);

       RESULT = new Symbol(
          -1,
          startCol,
          fswt.right, // line number
          new LexedValue(
            fswtList,
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FMT_STRING_PART:fs expr:e STRING:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(fs.currentInputLine, fsright), new Line(e.currentLine, e.currentLineNumber), new Line(tail.currentInputLine, tailright));
       int startCol = min(fsleft, e.startCol, tailleft);
       int endCol = max(fsleft + fs.len, e.endCol, tailleft + tail.len);

       RESULT = new Symbol(
          -1,
          startCol,
          tailright, // line number
          new LexedValue(
            ImmutableList.of(ImmutableList.builder().add(tail.val).add(fs.val), ImmutableList.builder().add(e)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

// The last production 'term' closes the grammar. It's a primitive or identifier reference.
term ::=
    primitive:p
    {: RESULT = p; :}
  | identifier:i
    {: RESULT = i; :}
  | node_reference:nr
    {: RESULT = nr; :}
  | UP_ARROW:a
    {:
       RESULT =
        new PipeChainBackreferenceTerm(
          a.currentInputLine,
          aright,
          aleft,
          aleft + a.len
        );
    :}
  ;

identifier ::=
    IDENTIFIER:identifier
    {: RESULT = new IdentifierReferenceTerm(identifier.val, identifier.currentInputLine, identifierright, identifierleft, identifierleft + identifier.len); :}
  ;

primitive ::=
    float:f
    {: RESULT = f; :}
  | integer:i
    {: RESULT = i; :}
  | STRING:s
    {: RESULT = new StringTerm(s.val, s.currentInputLine, sright, sleft, sleft + s.len); :}
  | TRUE:t
    {: RESULT = new TrueTerm(t.currentInputLine, tright, tleft, tleft + t.len); :}
  | FALSE:f
    {: RESULT = new FalseTerm(f.currentInputLine, fright, fleft, fleft + f.len); :}
  ;

float ::=
    FLOAT:f
    {: RESULT = new FloatTerm(f.val, f.currentInputLine, fright, fleft, fleft + f.len); :}
  ;

integer ::=
    INTEGER:i
    {: RESULT = new IntegerTerm(i.val, i.currentInputLine, iright, ileft, ileft + i.len); :}
  ;
