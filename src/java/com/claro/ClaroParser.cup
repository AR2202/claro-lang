package com.claro;

import com.claro.ClaroParserException;
import com.claro.compiler_backends.interpreted.ScopedHeap;
import com.claro.intermediate_representation.*;
import com.claro.intermediate_representation.expressions.*;
import com.claro.intermediate_representation.expressions.bool.*;
import com.claro.intermediate_representation.expressions.numeric.*;
import com.claro.intermediate_representation.expressions.procedures.functions.*;
import com.claro.intermediate_representation.expressions.procedures.methods.*;
import com.claro.intermediate_representation.expressions.term.*;
import com.claro.intermediate_representation.statements.*;
import com.claro.intermediate_representation.statements.user_defined_type_def_stmts.*;
import com.claro.intermediate_representation.types.TypeProvider;
import com.claro.intermediate_representation.types.TypeProvider.ImmediateTypeProvider;
import com.claro.intermediate_representation.types.Type;
import com.claro.intermediate_representation.types.Types;
import com.claro.runtime_utilities.injector.InjectedKey;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.base.Strings;
import java_cup.runtime.Symbol;
import java.lang.Math;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Stack;
import java.util.stream.Stream;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Supplier;
import lombok.Data;

/*
 * Copyright (C) 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parser for a simple calculator.
 *
 * <p>The grammar defines a simple arihmetic expressions that supports the addition,
 * subtraction, multiplication, division, exponentiation, logarithms and parentheses.
 *
 * @author Jason Steving, derived from a simpler example by Régis Décamps
 */

action code {:
  AtomicReference<TypeProvider> returnTypeHolder;

  int indentationLevel = 1;

  private String getIndents(int level) {
    StringBuilder res = new StringBuilder();
    for(int i = 0; i < level; i++) {
      res.append("\t");
    }
    return res.toString();
  }
:}

parser code {:
  public String generatedClassName = "CompiledClaroProgram";  // default to be overridden.
  public String package_string = "";  // default to be overridden.
  public Consumer<String> printerDelegate = System.out::println;

  public int errorsFound = 0;
  public static Stack<Runnable> errorMessages = new Stack<>();

  @Override
  public void report_error(String message, Object info) {
    errorsFound++;
    Symbol currSymbol = (Symbol) info;
    LexedValue<?> lexedValue = (LexedValue) currSymbol.value;

    errorMessages.push(
      () -> {
        System.err.print(String.format("%s.claro:%s: ", generatedClassName, currSymbol.right + 1));
        System.err.println("Unexpected token <" + lexedValue.val + ">");
        String currentInputLineString = lexedValue.currentInputLine.get();
        if (Character.isWhitespace(currentInputLineString.charAt(currentInputLineString.length() - 1))) {
          int trailingWhitespaceStart = currentInputLineString.length();
          while (Character.isWhitespace(currentInputLineString.charAt(--trailingWhitespaceStart))); // This is just cute for the sake of it....barf...but I'm keeping it lol.
          System.err.println(currentInputLineString.substring(0, trailingWhitespaceStart + 1));
        } else {
          System.err.println(lexedValue.currentInputLine.get());
        }
        System.err.println(Strings.repeat(" ", currSymbol.left) + '^');
      });
  }

  @Override
  public void syntax_error(Symbol cur_token) {
    this.report_error("Syntax error", cur_token);
  }

  @Data
  static class Line {
    Supplier<String> inputLineSupplier;
    int inputLineNumber;

    Line(StringBuilder inputLine, int inputLineNumber) {
      this(() -> inputLine.toString(), inputLineNumber);
    }

    Line(Expr e) {
      this(e.currentLine, e.currentLineNumber);
    }

    Line(Symbol s) {
      this(((LexedValue<?>)s.value).currentInputLine, s.right);
    }

    Line(Supplier<String> inputLineSupplier, int inputLineNumber) {
      this.inputLineSupplier = inputLineSupplier;
      this.inputLineNumber = inputLineNumber;
    }
  }

  private Supplier<String> joinExprLines(Line ... linesToJoin) {
    return () -> {
        StringBuilder res = new StringBuilder(linesToJoin[0].inputLineSupplier.get());
        int prevLineNum = linesToJoin[0].inputLineNumber;
        for (int i = 1; i < linesToJoin.length; i++) {
          Line curr = linesToJoin[i];
          if (curr.inputLineNumber != prevLineNum) {
            prevLineNum = curr.inputLineNumber;
            res.append(curr.inputLineSupplier.get());
          }
        }
        return res.toString();
    };
  }

  // Super obnoxious code...but for the sake of hacking together input text annotations for nonterminal grammar matches
  // so that we can plumb it up into the AST, this code aggregates data from multiple Symbols into a single one.
  private <T> Symbol chainSymbols(T value, Symbol ... symbols) {
    Stream<Symbol> symbolStream = Arrays.stream(symbols);
    int minStartCol = Integer.MAX_VALUE; // min column
    int maxEndCol = Integer.MIN_VALUE; // max column
    int maxLine = Integer.MIN_VALUE; // max line
    for (int i = 0; i<symbols.length; i++) {
      minStartCol = Math.min(symbols[i].left, minStartCol);
      maxEndCol = Math.max(symbols[i].left + ((LexedValue)symbols[i].value).len, maxEndCol);
      maxLine = Math.max(symbols[i].right, maxLine);
    }
    int aggregateLen = maxEndCol - minStartCol;

    Supplier<String> inputLinesSupplier = () -> {
      StringBuilder inputLines = new StringBuilder();
      symbolStream.map(s -> ((LexedValue)s.value).currentInputLine).forEach(inputLines::append);
      return inputLines.toString();
    };
    return new Symbol(
      -1, // Really I just have no better value to put in here.
      minStartCol,
      maxLine,
      new LexedValue<T>(value, inputLinesSupplier, aggregateLen)
    );
  }

  private static int min(int ... nums) {
    int currMin = Integer.MAX_VALUE;
    for (int x : nums) {
      currMin = Math.min(x, currMin);
    }
    return currMin;
  }

  private static int max(int ... nums) {
    int currMax = Integer.MIN_VALUE;
    for (int x : nums) {
      currMax = Math.max(x, currMax);
    }
    return currMax;
  }
:}

terminal LexedValue<String>  LPAR, RPAR;
terminal LexedValue<String>  LCURLY, RCURLY, LBRACKET, RBRACKET;
terminal LexedValue<String>  EXPONENTIATE;
terminal LexedValue<String>  MULTIPLY, DIVIDE;
terminal LexedValue<String>  PLUS, MINUS;
terminal LexedValue<String>  INCREMENT, DECREMENT;
terminal LexedValue<String>  SEMICOLON;
terminal LexedValue<String>  COLON;
terminal LexedValue<String>  COMMA;
terminal LexedValue<String>  BAR;
terminal LexedValue<String>  EQUALS, NOT_EQUALS;
terminal LexedValue<String>  UNDERSCORE;
terminal LexedValue<String>  VAR, ASSIGNMENT;
terminal LexedValue<String>  L_ANGLE_BRACKET, R_ANGLE_BRACKET, LTE, GTE;
terminal LexedValue<String>  OR, AND, NOT;
terminal LexedValue<String>  ARROW;
terminal LexedValue<Boolean> TRUE, FALSE;
// An integer is also a terminal, but it's of type Integer.
terminal LexedValue<Integer> INTEGER;
// A float is also a terminal, but it's of type Double.
terminal LexedValue<Double>  FLOAT;
// A string is also a terminal, but it's of type String.
terminal LexedValue<String>  STRING, FMT_STRING_PART;
// A variable identifier is just a sequence of chars.
terminal LexedValue<String>  IDENTIFIER;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal LexedValue<String>  LOG_PREFIX;
// This grammar also has a builtin print() function for printing expr values.
terminal LexedValue<String>  PRINT;
// This grammar also has a builtin numeric() function for casting booleans to doubles.
terminal LexedValue<String>  NUMERIC_BOOL;
// This grammar also has a builtin input() functino for reading a number from stdin.
terminal LexedValue<String>  INPUT;
// This grammar also has a builtin len() function for getting the length of an Iterable.
terminal LexedValue<String>  LEN;
// This grammar also has a builtin type() function for getting the type of an Expr.
terminal LexedValue<String>  TYPE;
terminal LexedValue<String>  IF, ELSE;
terminal LexedValue<String>  WHILE;
// Builtin Types (with keywords instead of symbolic notation, e.g. list is [<type>]).
terminal LexedValue<String>  INT_TYPE, FLOAT_TYPE, BOOLEAN_TYPE, STRING_TYPE, TUPLE_TYPE, STRUCT_TYPE,
                 FUNCTION_TYPE, CONSUMER_FUNCTION_TYPE, PROVIDER_FUNCTION_TYPE, LAMBDA;
terminal LexedValue<String>  ALIAS;
terminal LexedValue<String>  RETURN;
terminal LexedValue<String>  IMMUTABLE;
terminal LexedValue<String>  DOT;
// TODO(steving) Need to complete undo this hack for DOTBUILD and BUILDER.
terminal LexedValue<String>  BUILDER, DOTBUILD;
terminal LexedValue<String>  MODULE, BIND, TO, AS, USING;
terminal LexedValue<String>  FUTURE, BLOCKING_GET, GRAPH, ROOT, NODE, LEFT_ARROW, AT;

// DEBUGGING keywords which should be removed when we want a real release....
terminal LexedValue<String>  DEBUG_DUMP_SCOPE;

// Declare which type will be returned by each nonterminal grammar production.
nonterminal ProgramNode                        program;
nonterminal Expr                               expr;
nonterminal ParenthesizedExpr                  parenthesized_expr;
nonterminal Symbol/*ImmutableList<ImmutableList.Builder>*/  fmt_string;
nonterminal Term                               term;
nonterminal Term                               primitive;
nonterminal IdentifierReferenceTerm            identifier;
nonterminal FloatTerm                          float;
nonterminal IntegerTerm                        integer;
nonterminal Stmt                               stmt;
nonterminal StmtListNode                       stmt_list;
nonterminal StmtListNode                       stmts_and_module_defs_list;
nonterminal ListExpr                           list;
nonterminal TupleExpr                          tuple;
nonterminal CollectionSubscriptExpr            collection_subscript;
nonterminal Symbol/*ImmutableList.Builder<Expr>*/  args_list;
nonterminal IfStmt                             if_else_chain_stmt;
nonterminal IfStmt                             if_stmt;
nonterminal IfStmt                             else_if_stmt_chain;
nonterminal IfStmt                             else_if_stmt;
nonterminal StmtListNode                       else_stmt;
nonterminal WhileStmt                          while_stmt;
nonterminal AliasStmt                          alias_stmt;
nonterminal PrintStmt                          print;
nonterminal ShowTypeStmt                       show_type;
nonterminal DeclarationStmt                    identifier_declaration;
nonterminal AssignmentStmt                     identifier_assignment;
nonterminal TrashcanAssignmentStmt             trashcan_assignment;
nonterminal IncrementExpr                      identifier_increment;
nonterminal IncrementStmt                      identifier_increment_stmt;
nonterminal DecrementExpr                      identifier_decrement;
nonterminal DecrementStmt                      identifier_decrement_stmt;
nonterminal ListElementAssignmentStmt          list_element_assignment;
nonterminal StructDefinitionStmt               struct_definition_stmt;
nonterminal FunctionDefinitionStmt             function_definition_stmt;
nonterminal LambdaExpr                         lambda_function_expr;
nonterminal Symbol/*ImmutableMap.Builder<String, TypeProvider>*/ function_args_types_list;
nonterminal Symbol/*ImmutableList.Builder<String>*/  identifier_list;
nonterminal ConsumerFunctionDefinitionStmt     consumer_function_definition_stmt;
nonterminal ProviderFunctionDefinitionStmt     provider_function_definition_stmt;
nonterminal GraphFunctionDefinitionStmt        graph_function_definition_stmt;
nonterminal GraphNodeDefinitionStmt            root_node;
nonterminal GraphNodeDefinitionStmt            non_root_node;
nonterminal ImmutableList.Builder<GraphNodeDefinitionStmt> non_root_nodes_list;
nonterminal GraphNodeReferenceExpr             node_reference;
nonterminal BuilderMethodCallExpr              builder_method_call_expr;
nonterminal BuilderFullBuildMethodCallExpr     builder_full_build;
nonterminal Symbol/*<ImmutableMap.Builder<String, Expr>>*/ builder_setter_call;
nonterminal Symbol/*ImmutableMap.Builder<String, Expr>*/ builder_setter_chain;
nonterminal ReturnStmt                         return_stmt;
nonterminal FunctionCallExpr                   function_call_expr;
nonterminal ProviderFunctionCallExpr           provider_function_call_expr;
nonterminal ConsumerFunctionCallStmt           consumer_function_call_stmt;
nonterminal InputExpr                          input;
nonterminal BoolExpr                           bool_expr;
nonterminal BoolExpr                           equality;
nonterminal BoolExpr                           inequality;
nonterminal BoolExpr                           bool_arithmetic;
// TODO(steving) In order to support the delayed parsing of all user-defined types, just replace this type with
// TODO(steving) Function<ScopedHeap, TypeProvider> or some other equivalent functional interface and then you'll be good to add
// TODO(steving) a new compiler phase that filters a StmtList for all of its type definitions (e.g. StructDefinitionStmt)
// TODO(steving) and parses all of those before moving on to the other stmts in the StmtList.
nonterminal Symbol/*TypeProvider*/             builtin_type;
nonterminal Symbol/*ImmutableList<TypeProvider>*/  builtin_types_list;
nonterminal Symbol/*ImmutableList.Builder<TypeProvider>*/ backwards_builtin_types_list;
nonterminal Stmt                               debug_stmts;
nonterminal ModuleDefinitionStmt               module_definition_stmt;
nonterminal StmtListNode                       bind_stmts_list;
nonterminal BindStmt                           bind_stmt;
nonterminal UsingBlockStmt                     using_block_stmt;
nonterminal Symbol/*ImmutableList.Builder<InjectedKey>*/ injected_keys_list;

// Lower precedence things at the top, higher precedence things at the bottom.
// ...but also I've basically put no thought whatsoever into the order these ACTUALLY appear in.
precedence left COMMA;
precedence left IDENTIFIER;
precedence left SEMICOLON;
precedence left ASSIGNMENT;
precedence left COLON;
precedence left EQUALS, NOT_EQUALS;
precedence left AND, OR, NOT;
precedence left L_ANGLE_BRACKET, R_ANGLE_BRACKET, LTE, GTE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX, IF, ELSE;
precedence left WHILE;

// This is where the grammar starts.
program ::=
    stmts_and_module_defs_list:s
    {:
       RESULT = new ProgramNode(s, package_string, generatedClassName);
    :}
  ;

// TODO(steving) Add procedure defs to this target so that they also can only be used at the top level.
stmts_and_module_defs_list ::=
    module_definition_stmt:m stmts_and_module_defs_list:tail
    {: RESULT = new StmtListNode(m, tail); :}
  | stmt:s stmts_and_module_defs_list:tail
    {: RESULT = new StmtListNode(s, tail); :}
  | stmt:s
    {: RESULT = new StmtListNode(s); :}
  | module_definition_stmt:m
    {: RESULT = new StmtListNode(m); :}
  ;

stmt_list ::=
    stmt:head stmt_list:tail
    {: RESULT = new StmtListNode(head, tail); :}
  | stmt:s
    {: RESULT = new StmtListNode(s); :}
  | debug_stmts:d
    {: RESULT = new StmtListNode(d); :}
  ;

debug_stmts ::=
    DEBUG_DUMP_SCOPE LPAR RPAR SEMICOLON
    {:
       RESULT =
         new PrintStmt(
           new StringTerm(null, ()-> "", 0,0,0) {
             @Override
             public Object generateInterpretedOutput(ScopedHeap scopedHeap) {
               return scopedHeap;
             }
           },
           printerDelegate
         );
    :}
  ;

stmt ::=
    print:p
    {: RESULT = p; :}
  | show_type:s
    {: RESULT = s; :}
  | identifier_declaration:d
    {: RESULT = d; :}
  | identifier_assignment:a
    {: RESULT = a; :}
  | identifier_increment_stmt:i
    {: RESULT = i; :}
  | identifier_decrement_stmt:i
    {: RESULT = i; :}
  | list_element_assignment:l
    {: RESULT = l; :}
  | if_else_chain_stmt:i
    {: RESULT = i; :}
  | while_stmt:w
    {: RESULT = w; :}
  | struct_definition_stmt:s
    {: RESULT = s; :}
  | function_definition_stmt:f
    {: RESULT = f; :}
  | consumer_function_definition_stmt:f
    {: RESULT = f; :}
  | provider_function_definition_stmt:pf
    {: RESULT = pf; :}
  | consumer_function_call_stmt:cf
    {: RESULT = cf; :}
  | graph_function_definition_stmt:gf
    {: RESULT = gf; :}
  | return_stmt:r
    {: RESULT = r; :}
  | alias_stmt:a
    {: RESULT = a; :}
  | using_block_stmt:u
    {: RESULT = u; :}
  ;

module_definition_stmt ::=
    MODULE IDENTIFIER:i LCURLY bind_stmts_list:b RCURLY
    {: RESULT = new ModuleDefinitionStmt(i.val, b); :}
  | MODULE IDENTIFIER:i USING LPAR identifier_list:modules RPAR LCURLY bind_stmts_list:b RCURLY
    {:
      ImmutableList<String> moduleList =
        ((LexedValue<ImmutableList.Builder<String>>)modules.value).val.build().reverse();
      RESULT = new ModuleDefinitionStmt(i.val, Optional.of(moduleList), b);
    :}
  ;

bind_stmts_list ::=
    bind_stmt:head bind_stmts_list:tail
    {: RESULT = new StmtListNode(head, tail); :}
  | bind_stmt:s
    {: RESULT = new StmtListNode(s); :}
  ;

bind_stmt ::=
    BIND IDENTIFIER:i COLON builtin_type:t TO expr:e SEMICOLON
    {: RESULT = new BindStmt(i.val, ((LexedValue<TypeProvider>) t.value).val, e); :}
  ;

using_block_stmt ::=
    USING LPAR identifier_list:modules RPAR LCURLY stmt_list:s RCURLY
    {:
       ImmutableList<String> moduleList =
         ((LexedValue<ImmutableList.Builder<String>>)modules.value).val.build().reverse();
       RESULT = new UsingBlockStmt(moduleList, s, true);
    :}
  ;

print ::=
    PRINT LPAR expr:e RPAR SEMICOLON
    {: RESULT = new PrintStmt(e, printerDelegate); :}
  ;

show_type ::=
    TYPE LPAR expr:e RPAR SEMICOLON
    {: RESULT = new ShowTypeStmt(e); :}
  ;

identifier_declaration ::=
    VAR IDENTIFIER:identifier ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, e); :}
  | VAR IDENTIFIER:identifier COLON builtin_type:t SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, ((LexedValue<TypeProvider>) t.value).val); :}
  | VAR IDENTIFIER:identifier COLON builtin_type:t ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, ((LexedValue<TypeProvider>) t.value).val, e); :}

  // Blocking variants.
  | VAR IDENTIFIER:identifier COLON builtin_type:t BLOCKING_GET expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, ((LexedValue<TypeProvider>) t.value).val, e, /*allowVariableHiding=*/false, /*blocking=*/true); :}
  | VAR IDENTIFIER:identifier BLOCKING_GET expr:e SEMICOLON
    {: RESULT = new DeclarationStmt(identifier.val, e, /*blocking=*/true); :}
  ;

alias_stmt ::=
    ALIAS IDENTIFIER:alias COLON builtin_type:aliased_type
    {:
       LexedValue<TypeProvider> aliasedTypeLexedVal = (LexedValue<TypeProvider>) aliased_type.value;
       RESULT = new AliasStmt(alias.val, aliasedTypeLexedVal.val);
    :}
  ;

builtin_type ::=
    INT_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          new LexedValue(
            (TypeProvider) ImmediateTypeProvider.of(Types.INTEGER),
            t.currentInputLine,
            t.len)
       );
    :}
  | FLOAT_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          new LexedValue(
            (TypeProvider) ImmediateTypeProvider.of(Types.FLOAT),
            t.currentInputLine,
            t.len)
       );
    :}
  | BOOLEAN_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          new LexedValue(
            (TypeProvider) ImmediateTypeProvider.of(Types.BOOLEAN),
            t.currentInputLine,
            t.len)
       );
    :}
  | STRING_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          new LexedValue(
            (TypeProvider) ImmediateTypeProvider.of(Types.STRING),
            t.currentInputLine,
            t.len)
       );
    :}
  | LBRACKET:lb builtin_type:t RBRACKET:rb
    {:
       LexedValue<TypeProvider> tLexedVal = (LexedValue<TypeProvider>) t.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lb.currentInputLine, lbright), new Line(tLexedVal.currentInputLine, t.right), new Line(rb.currentInputLine, rbright));
       int startCol = min(lbleft, t.left, rbleft);
       int endCol = max(lbleft + lb.len, t.left + tLexedVal.len, rbleft + rb.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ListType.forValueType(tLexedVal.val.resolveType(scopedHeap)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argLexedVal.currentInputLine, arg.right), new Line(a.currentInputLine, aright), new Line(outputTypeLexedVal.currentInputLine, output_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg.left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg.left + argLexedVal.len, aleft + a.len, output_type.left + outputTypeLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.val.resolveType(scopedHeap)), outputTypeLexedVal.val.resolveType(scopedHeap)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(b1.currentInputLine, b1right), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(b2.currentInputLine, b2right), new Line(a.currentInputLine, aright), new Line(outputTypeLexedVal.currentInputLine, output_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, b1left, arg_types.left, b2left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, b1left + b1.len, arg_types.left + argTypesLexedVal.len, b2left + b2.len, aleft + a.len, output_type.left + outputTypeLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.val.resolveType(scopedHeap)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg_types.left + argTypesLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | PROVIDER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:return_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> returnTypeProvider = (LexedValue<TypeProvider>) return_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(returnTypeProvider.currentInputLine, return_type.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, return_type.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, return_type.left + returnTypeProvider.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(returnTypeProvider.val.resolveType(scopedHeap)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | TUPLE_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.currentInputLine, tright), new Line(la.currentInputLine, laright), new Line(argTypesLexedVal.currentInputLine, arg_types.right), new Line(ra.currentInputLine, raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.len, laleft + la.len, arg_types.left + argTypesLexedVal.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.TupleType.forValueTypes(argTypesLexedVal.val.stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BUILDER:b L_ANGLE_BRACKET:la IDENTIFIER:built_type_name R_ANGLE_BRACKET:ra
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(b.currentInputLine, bright), new Line(la.currentInputLine, laright), new Line(built_type_name.currentInputLine, built_type_nameright), new Line(ra.currentInputLine, raright));
       int startCol = min(bleft, laleft, built_type_nameleft, raleft);
       int endCol = max(bleft + b.len, laleft + la.len, built_type_nameleft + built_type_name.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            Types.BuilderType.forStructTypeName(built_type_name.val),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUTURE:f L_ANGLE_BRACKET:la builtin_type:wrapped R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> wrappedTypeProvider = (LexedValue<TypeProvider>) wrapped.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(f.currentInputLine, fright), new Line(la.currentInputLine, laright), new Line(wrappedTypeProvider.currentInputLine, wrapped.right), new Line(ra.currentInputLine, raright));
       int startCol = min(fleft, laleft, wrapped.left, raleft);
       int endCol = max(fleft + f.len, laleft + la.len, wrapped.left + wrappedTypeProvider.len, raleft + ra.len);

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          new LexedValue(
            (TypeProvider) (scopedHeap) -> Types.FutureType.wrapping(wrappedTypeProvider.val.resolveType(scopedHeap)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:type_name
    {:
       RESULT = new Symbol(
          -1,
          type_nameleft,
          type_nameright, // line number
          new LexedValue(
            TypeProvider.Util.getTypeByName(type_name.val, /*isTypeDefinition=*/true),
            type_name.currentInputLine,
            type_name.len)
       );
    :}
  ;

builtin_types_list ::=
    backwards_builtin_types_list:b
    {:
       LexedValue<ImmutableList.Builder<TypeProvider>> bLexedValue = (LexedValue<ImmutableList.Builder<TypeProvider>>) b.value;
       RESULT = new Symbol(
          -1,
          b.left,
          b.right, // line number
          new LexedValue(
            bLexedValue.val.build().reverse(),
            bLexedValue.currentInputLine,
            bLexedValue.len)
       );
    :}
  ;

backwards_builtin_types_list ::=
    builtin_type:t COMMA:c backwards_builtin_types_list:tail
    {:
       LexedValue<TypeProvider> tLexedVal = (LexedValue<TypeProvider>)t.value;
       LexedValue<ImmutableList.Builder<TypeProvider>> tailLexedVal = (LexedValue<ImmutableList.Builder<TypeProvider>>)tail.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(tLexedVal.currentInputLine, t.right), new Line(c.currentInputLine, cright), new Line(tailLexedVal.currentInputLine, tail.right));
       int startCol = min(t.left, cleft, tail.left);
       int endCol = max(t.left + tLexedVal.len, cleft + c.len, tail.left + tailLexedVal.len);

       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          new LexedValue(
            tailLexedVal.val.add(tLexedVal.val),
            currentLinesSupplier,
            tailLexedVal.len)
       );
    :}
  | builtin_type:t
    {:
       RESULT = new Symbol(
          -1,
          t.left,
          t.right, // line number
          new LexedValue(
            ImmutableList.<TypeProvider>builder().add(((LexedValue<TypeProvider>) t.value).val),
            ((LexedValue)t.value).currentInputLine,
            ((LexedValue)t.value).len)
       );
    :}
  ;

identifier_assignment ::=
    IDENTIFIER:identifier ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new AssignmentStmt(identifier.val, e); :}
  ;

trashcan_assignment ::=
    UNDERSCORE ASSIGNMENT identifier:identifier SEMICOLON
    {: RESULT = new TrashcanAssignmentStmt(identifier); :}
  ;

identifier_increment_stmt ::=
    identifier_increment:i SEMICOLON
    {: RESULT = new IncrementStmt(i); :}
  ;

identifier_increment ::=
    INCREMENT:inc identifier:i
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(inc.currentInputLine, incright), new Line(i.currentLine, i.currentLineNumber));
       int startCol = min(incleft, i.startCol);
       int endCol = max(incleft + inc.len, i.endCol);

       RESULT = new IncrementExpr(i, /*preIncrement=*/true, currentLinesSupplier, i.currentLineNumber, startCol, endCol);
    :}
  | identifier:i INCREMENT:inc
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(i.currentLine, i.currentLineNumber), new Line(inc.currentInputLine, incright));
       int startCol = min(i.startCol, incleft);
       int endCol = max(i.endCol, incleft + inc.len);

       RESULT = new IncrementExpr(i, /*preIncrement=*/false, currentLinesSupplier, incright, startCol, endCol);
    :}
  ;

identifier_decrement_stmt ::=
    identifier_decrement:i SEMICOLON
    {: RESULT = new DecrementStmt(i); :}
  ;

identifier_decrement ::=
    DECREMENT:d identifier:i
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(d.currentInputLine, dright), new Line(i.currentLine, i.currentLineNumber));
       int startCol = min(dleft, i.startCol);
       int endCol = max(dleft + d.len, i.endCol);

       RESULT = new DecrementExpr(i, /*preDecrement=*/true, currentLinesSupplier, i.currentLineNumber, startCol, endCol);
    :}
  | identifier:i DECREMENT:d
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(i.currentLine, i.currentLineNumber), new Line(d.currentInputLine, dright));
       int startCol = min(i.startCol, dleft);
       int endCol = max(i.endCol, dleft + d.len);

       RESULT = new DecrementExpr(i, /*preDecrement=*/false, currentLinesSupplier, dright, startCol, endCol);
    :}
  ;

list_element_assignment ::=
    collection_subscript:l ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new ListElementAssignmentStmt(l, e); :}
  ;

// In reality, right now expr is taking on multiple types and this is unchecked. Runtime failures are allowed in this
// language at the moment. Fix this later, for now, explicit casting between bool and number have to be done carefully.
expr ::=
    MINUS:m expr:e
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(m.currentInputLine, mright), new Line(e.currentLine, e.currentLineNumber));
       int startCol = min(mleft, e.startCol);
       int endCol = max(mleft + m.len, e.endCol);

       RESULT = new NegateNumericExpr(e, currentLinesSupplier, e.currentLineNumber, startCol, endCol);
    :}
  | expr:a PLUS:p expr:b
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(p.currentInputLine, pright), new Line(b.currentLine, b.currentLineNumber));
       int startCol = min(a.startCol, pleft, b.startCol);
       int endCol = max(a.endCol, pleft + p.len, b.endCol);

       RESULT = new AddNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol);
    :}
  | identifier_increment:i
    {: RESULT = i; :}
  | identifier_decrement:i
    {: RESULT = i; :}
  | expr:a MINUS:m expr:b
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(m.currentInputLine, mright), new Line(b.currentLine, b.currentLineNumber));
       int startCol = min(a.startCol, mleft, b.startCol);
       int endCol = max(a.endCol, mleft + m.len, b.endCol);

       RESULT = new SubtractNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol);
    :}
  | expr:a MULTIPLY:m expr:b
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(m.currentInputLine, mright), new Line(b.currentLine, b.currentLineNumber));
       int startCol = min(a.startCol, mleft, b.startCol);
       int endCol = max(a.endCol, mleft + m.len, b.endCol);

       RESULT = new MultiplyNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol);
    :}
  | expr:a DIVIDE:d expr:b // Only support int-division right now...
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(d.currentInputLine, dright), new Line(b.currentLine, b.currentLineNumber));
       int startCol = min(a.startCol, dleft, b.startCol);
       int endCol = max(a.endCol, dleft + d.len, b.endCol);

       RESULT = new DivideNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol);
    :}
  | expr:a EXPONENTIATE:ex expr:b // Only support int-exponentiation right now...
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(ex.currentInputLine, exright), new Line(b.currentLine, b.currentLineNumber));
       int startCol = min(a.startCol, exleft, b.startCol);
       int endCol = max(a.endCol, exleft + ex.len, b.endCol);

       RESULT = new ExponentiateNumericExpr(a, b, currentLinesSupplier, bright, startCol, endCol);
    :}
  | parenthesized_expr:p
    {: RESULT = p; :}
  | LOG_PREFIX:log float:float_base LPAR:lp expr:arg RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(log.currentInputLine, logright), new Line(float_base.currentLine, float_base.currentLineNumber), new Line(lp.currentInputLine, lpright), new Line(arg.currentLine, arg.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(logleft, float_base.startCol, lpleft, arg.startCol, rpleft);
       int endCol = max(logleft + log.len, float_base.endCol, lpleft + lp.len, arg.endCol, rpleft + rp.len);

       RESULT = new LogNumericExpr(arg, float_base, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | LOG_PREFIX:log integer:int_base LPAR:lp expr:arg RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(log.currentInputLine, logright), new Line(int_base.currentLine, int_base.currentLineNumber), new Line(lp.currentInputLine, lpright), new Line(arg.currentLine, arg.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(logleft, int_base.startCol, lpleft, arg.startCol, rpleft);
       int endCol = max(logleft + log.len, int_base.endCol, lpleft + lp.len, arg.endCol, rpleft + rp.len);

       RESULT = new LogNumericExpr(arg, int_base, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | NUMERIC_BOOL:num LPAR:lp bool_expr:b RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(num.currentInputLine, numright), new Line(lp.currentInputLine, lpright), new Line(b.currentLine, b.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(numleft, lpleft, b.startCol, rpleft);
       int endCol = max(numleft + num.len, lpleft + lp.len, b.endCol, rpleft + rp.len);

       RESULT = new NumericBoolNumericExpr(b, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | input:i
    {: RESULT = i; :}
  | list:l
    {: RESULT = l; :}
  | collection_subscript:l
    {: RESULT = l; :}
  | LEN:len LPAR:lp expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(len.currentInputLine, lenright), new Line(lp.currentInputLine, lpright), new Line(e.currentLine, e.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(lenleft, lpleft, e.startCol, rpleft);
       int endCol = max(lenleft + len.len, lpleft + lp.len, e.endCol, rpleft + rp.len);

       RESULT = new LenExpr(e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  | bool_expr:b
    {: RESULT = b; :}
  | fmt_string:fs_symbol
    {:
       LexedValue<ImmutableList<ImmutableList.Builder>> fsLexedValue = (LexedValue<ImmutableList<ImmutableList.Builder>>) fs_symbol.value;
       ImmutableList<ImmutableList.Builder> fs = fsLexedValue.val;
       RESULT = new FormatStringExpr(fs.get(0).build().reverse(), fs.get(1).build().reverse(), fsLexedValue.currentInputLine, fs_symbol.right, fs_symbol.left, fs_symbol.left + fsLexedValue.len);
    :}
  | term:t
    {: RESULT = t; :}
  | function_call_expr:f
    {: RESULT = f; :}
  | lambda_function_expr:lf
    {: RESULT = lf; :}
  | provider_function_call_expr:pf
    {: RESULT = pf; :}
  | builder_method_call_expr:b
    {: RESULT = b; :}
  | builder_full_build:b
    {: RESULT = b; :}
  | tuple:t
    {: RESULT = t; :}
  | LPAR:lp builtin_type:asserted_type RPAR:rp expr:casted_expr
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(((LexedValue)asserted_type.value).currentInputLine, asserted_type.right), new Line(rp.currentInputLine, rpright), new Line(casted_expr.currentLine, casted_expr.currentLineNumber));
       int startCol = min(lpleft, asserted_type.left, rpleft, casted_expr.startCol);
       int endCol = max(lpleft + lp.len, asserted_type.left + ((LexedValue)asserted_type.value).len, rpleft + rp.len, casted_expr.endCol);

       RESULT = new CastExpr(((LexedValue<TypeProvider>)asserted_type.value).val, casted_expr, currentLinesSupplier, casted_expr.currentLineNumber, startCol, endCol);
    :}
  | error:e
    // TODO(steving) This is super helpful, do the same thing for stmts.
    // There's been some syntax error in an expression somewhere.. meaning that this expression is getting thrown away
    // in order to continue checking for other errors in the input program. So "repair" the program by giving it some
    // arbitrary Expr that won't complain a second time during AST type checking.
    {:
       RESULT = new Expr(ImmutableList.of(), () -> {throw new RuntimeException("Internal Compiler Error: Should be unreachable.");}, -1, -1, -1) {
          public Type getValidatedExprType(ScopedHeap unused) {
            return Types.UNDECIDED;
          }
          public StringBuilder generateJavaSourceBodyOutput(ScopedHeap unused) {
            return new StringBuilder();
          }
          public Object generateInterpretedOutput(ScopedHeap unused) {
            return null;
          }
          public void logTypeError(Exception unused) {
            // Intentionally do not re-log this error.
          }
       };
    :}
  ;

parenthesized_expr ::=
    LPAR:lp expr:e RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(e.currentLine, e.currentLineNumber), new Line(rp.currentInputLine, rpright));
       int startCol = min(lpleft, e.startCol, rpleft);
       int endCol = max(lpleft + lp.len, e.endCol, rpleft + rp.len);

       RESULT = new ParenthesizedExpr(e, currentLinesSupplier, rpright, startCol, endCol);
    :}
  ;

input ::=
    INPUT:i LPAR:lp STRING:prompt RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(i.currentInputLine, iright), new Line(lp.currentInputLine, lpright), new Line(prompt.currentInputLine, promptright), new Line(rp.currentInputLine, rpright));
       int startCol = min(ileft, lpleft, promptleft, rpleft);
       int endCol = max(ileft + i.len, lpleft + lp.len, promptleft + prompt.len, rpleft + rp.len);

       RESULT = new InputExpr(prompt.val, currentLinesSupplier, rpright, startCol, endCol);
    :}
  ;

list ::=
    LBRACKET:lb args_list:args RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lb.currentInputLine, lbright), new Line(((LexedValue) args.value).currentInputLine, args.right), new Line(rb.currentInputLine, rbright));
       int startCol = min(lbleft, args.left, rbleft);
       int endCol = max(lbleft + lb.len, args.left + ((LexedValue) args.value).len, rbleft + rb.len);

       // Notice that we reverse the list before handing it to the ListExpr node because it was collected backwards.
       RESULT = new ListExpr(((LexedValue<ImmutableList.Builder<Expr>>) args.value).val.build().reverse(), currentLinesSupplier, rbright, startCol, endCol);
    :}
  | LBRACKET:lb RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lb.currentInputLine, lbright), new Line(rb.currentInputLine, rbright));
       int startCol = min(lbleft, rbleft);
       int endCol = max(lbleft + lb.len, rbleft + rb.len);

       RESULT = new ListExpr(currentLinesSupplier, rbright, startCol, endCol);
    :}
  ;

tuple ::=
    // Tuples distinguish themselves from parenthesized expressions by having at least one comma.
    LPAR:lp expr:head COMMA:c args_list:tailValues RPAR:rp
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(head.currentLine, head.currentLineNumber), new Line(c.currentInputLine, cright), new Line(((LexedValue) tailValues.value).currentInputLine, tailValues.right), new Line(rp.currentInputLine, rpright));
       int startCol = min(lpleft, head.startCol, cleft, tailValues.left, rpleft);
       int endCol = max(lpleft + lp.len, head.endCol, cleft + c.len, tailValues.left + ((LexedValue) tailValues.value).len, rpleft + rp.len);

       ImmutableList.Builder<Expr> tupleValues = ImmutableList.builder();
       tupleValues.add(head);
       tupleValues.addAll(((LexedValue<ImmutableList.Builder<Expr>>) tailValues.value).val.build().reverse());
       RESULT = new TupleExpr(tupleValues.build(), currentLinesSupplier, rpright, startCol, endCol);
    :}
  ;

args_list ::=
    expr:head COMMA:c args_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(head.currentLine, head.currentLineNumber), new Line(c.currentInputLine, cright), new Line(((LexedValue)tail.value).currentInputLine, tail.right));
       int startCol = min(head.startCol, cleft, tail.left);
       int endCol = max(head.endCol, cleft + c.len, tail.left + ((LexedValue) tail.value).len);

       // Notice that we're building this list in reverse order, just by the order of the parser recursively identifying
       // each expr in the list.
       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableList.Builder<Expr>>) tail.value).val.add(head),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | expr:e
    {:
       RESULT = new Symbol(
          -1,
          e.startCol,
          e.currentLineNumber, // line number
          new LexedValue(
            ImmutableList.<Expr>builder().add(e),
            e.currentLine,
            e.endCol - e.startCol)
       );
    :}
  ;

collection_subscript ::=
    // Support arbitrarily repeated subscripting. CollectionSubscriptExpr node will check that there's the right levels of
    // nesting available for the given number of subscripts in this specific context.
    collection_subscript:l LBRACKET:lb expr:e RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(l.currentLine, l.currentLineNumber), new Line(lb.currentInputLine, lbright), new Line(e.currentLine, e.currentLineNumber), new Line(rb.currentInputLine, rbright));
       int startCol = min(l.startCol, lbleft, e.startCol, rbleft);
       int endCol = max(l.endCol, lbleft + lb.len, e.endCol, rbleft + rb.len);

       RESULT = new CollectionSubscriptExpr(l, e, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | list:l LBRACKET:lb expr:e RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(l.currentLine, l.currentLineNumber), new Line(lb.currentInputLine, lbright), new Line(e.currentLine, e.currentLineNumber), new Line(rb.currentInputLine, rbright));
       int startCol = min(l.startCol, lbleft, e.startCol, rbleft);
       int endCol = max(l.endCol, lbleft + lb.len, e.endCol, rbleft + rb.len);

       RESULT = new CollectionSubscriptExpr(l, e, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | identifier:i LBRACKET:lb expr:e RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(i.currentLine, i.currentLineNumber), new Line(lb.currentInputLine, lbright), new Line(e.currentLine, e.currentLineNumber), new Line(rb.currentInputLine, rbright));
       int startCol = min(i.startCol, lbleft, e.startCol, rbleft);
       int endCol = max(i.endCol, lbleft + lb.len, e.endCol, rbleft + rb.len);

       RESULT = new CollectionSubscriptExpr(i, e, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | function_call_expr:f LBRACKET:lb expr:e RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(f.currentLine, f.currentLineNumber), new Line(lb.currentInputLine, lbright), new Line(e.currentLine, e.currentLineNumber), new Line(rb.currentInputLine, rbright));
       int startCol = min(f.startCol, lbleft, e.startCol, rbleft);
       int endCol = max(f.endCol, lbleft + lb.len, e.endCol, rbleft + rb.len);

       RESULT = new CollectionSubscriptExpr(f, e, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | provider_function_call_expr:f LBRACKET:lb expr:e RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(f.currentLine, f.currentLineNumber), new Line(lb.currentInputLine, lbright), new Line(e.currentLine, e.currentLineNumber), new Line(rb.currentInputLine, rbright));
       int startCol = min(f.startCol, lbleft, e.startCol, rbleft);
       int endCol = max(f.endCol, lbleft + lb.len, e.endCol, rbleft + rb.len);

       RESULT = new CollectionSubscriptExpr(f, e, currentLinesSupplier, rbright, startCol, endCol);
    :}
  | parenthesized_expr:p LBRACKET:lb expr:e RBRACKET:rb
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(p.currentLine, p.currentLineNumber), new Line(lb.currentInputLine, lbright), new Line(e.currentLine, e.currentLineNumber), new Line(rb.currentInputLine, rbright));
       int startCol = min(p.startCol, lbleft, e.startCol, rbleft);
       int endCol = max(p.endCol, lbleft + lb.len, e.endCol, rbleft + rb.len);

       RESULT = new CollectionSubscriptExpr(p, e, currentLinesSupplier, rbright, startCol, endCol);
    :}
  ;

bool_expr ::=
    equality:b
    {: RESULT = b; :}
  | inequality:b
    {: RESULT = b; :}
  | bool_arithmetic:b
    {: RESULT = b; :}
  ;

// This calculator can evaluate an equality check of expressions.
equality ::=
    expr:a EQUALS:e expr:b
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(e.currentInputLine, eright), new Line(b.currentLine, b.currentLineNumber));
       int startCol = min(a.startCol, eleft, b.startCol);
       int endCol = max(a.endCol, eleft + e.len, b.endCol);

       RESULT = new EqualsBoolExpr(a, b, currentLinesSupplier, b.currentLineNumber, startCol, endCol);
    :}
  | expr:a NOT_EQUALS:ne expr:b
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(a.currentLine, a.currentLineNumber), new Line(ne.currentInputLine, neright), new Line(b.currentLine, b.currentLineNumber));
       int startCol = min(a.startCol, neleft, b.startCol);
       int endCol = max(a.endCol, neleft + ne.len, b.endCol);

       RESULT = new NotEqualsBoolExpr(a, b, currentLinesSupplier, b.currentLineNumber, startCol, endCol);
    :}
  ;

if_else_chain_stmt ::=
    if_stmt:leading_if_stmt else_if_stmt_chain:else_if_chain
    {:
       leading_if_stmt.setNextCondition(else_if_chain);
       RESULT = leading_if_stmt;
    :}
  | if_stmt:if_stmt else_stmt:trailing_else_stmt
    {:
       if_stmt.setTerminalElseClause(trailing_else_stmt);
       RESULT = if_stmt;
    :}
  | if_stmt:if_stmt
    {: RESULT = if_stmt; :}
  ;

if_stmt ::=
    IF LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new IfStmt(e, stmt_list); :}
  ;

else_if_stmt_chain ::=
    else_if_stmt:head else_if_stmt_chain:tail
    {:
       head.setNextCondition(tail);
       RESULT = head;
    :}
  | else_if_stmt:else_if_stmt else_stmt:trailing_else_stmt
    {:
       else_if_stmt.setTerminalElseClause(trailing_else_stmt);
       RESULT = else_if_stmt;
    :}
  | else_if_stmt:else_if_stmt
    {: RESULT = else_if_stmt; :}
  ;

else_if_stmt ::=
    ELSE if_stmt:else_if_stmt
    {: RESULT = else_if_stmt; :}
  ;

// We can simply return the StmtListNode itself because this is actually gonna be run by the IfStmt it's associated
// with.
else_stmt ::=
    ELSE LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = stmt_list; :}
  ;

while_stmt ::=
    WHILE LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new WhileStmt(e, stmt_list); :}
  ;

struct_definition_stmt ::=
    STRUCT_TYPE IDENTIFIER:name LCURLY function_args_types_list:backwards_field_types RCURLY
    {:
       // This is a named struct definition. You can construct multiple instances of this type.
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_field_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       RESULT = new StructDefinitionStmt(name.val, fieldTypesMap, /*immutable=*/ false);
    :}
  | LCURLY function_args_types_list:backwards_field_types RCURLY
    {:
       // This is an anonymous struct definition. Can construct once, but it'll be a unique type.
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_field_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       RESULT = new StructDefinitionStmt(fieldTypesMap, /*immutable=*/ false);
    :}
  | IMMUTABLE STRUCT_TYPE IDENTIFIER:name LCURLY function_args_types_list:backwards_field_types RCURLY
    {:
       // This is a named struct definition. You can construct multiple instances of this type.
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_field_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       RESULT = new StructDefinitionStmt(name.val, fieldTypesMap, /*immutable=*/ true);
    :}
  | IMMUTABLE LCURLY function_args_types_list:backwards_field_types RCURLY
    {:
       // This is an anonymous struct definition. Can construct once, but it'll be a unique type.
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_field_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       RESULT = new StructDefinitionStmt(fieldTypesMap, /*immutable=*/ true);
    :}
  ;

function_definition_stmt ::=
    FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new FunctionDefinitionStmt(name.val, argTypesMap, outputTypeProvider, stmt_list);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new FunctionDefinitionStmt(name.val, argTypesMap, Optional.of(injectedKeysList), outputTypeProvider, stmt_list);
    :}
  ;

lambda_function_expr ::=
    IDENTIFIER:arg_name ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(a.currentInputLine, aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(arg_nameleft, aleft, implicit_return_exprleft);
      int endCol = max(arg_nameleft + arg_name.len, aleft + a.len, implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(ImmutableList.of(arg_name.val), new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_expr.currentLineNumber, startCol, endCol);
    :}
  | IDENTIFIER:arg_name ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(a.currentInputLine, aright), new Line(lc.currentInputLine, lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.currentInputLine, rcright));
      int startCol = min(arg_nameleft, aleft, lcleft, rcleft);
      int endCol = max(arg_nameleft + arg_name.len, aleft + a.len, lcleft + lc.len, rcleft + rc.len);

      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      RESULT = new LambdaExpr(ImmutableList.of(arg_name.val), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  | LAMBDA:lam LPAR:lp IDENTIFIER:first_arg_name COMMA:c identifier_list:arg_names RPAR:rp ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lam.currentInputLine, lamright), new Line(lp.currentInputLine, lpright), new Line(first_arg_name.currentInputLine, first_arg_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue) arg_names.value).currentInputLine, arg_namesright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(lamleft, lpleft, first_arg_nameleft, cleft, arg_names.left, rpleft, aleft, implicit_return_exprleft);
      int endCol = max(lamleft + lam.len, lpleft + lp.len, first_arg_nameleft + first_arg_name.len, cleft + c.len, arg_names.left + ((LexedValue)arg_names.value).len, rpleft + rp.len, aleft + a.len, implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(((LexedValue<ImmutableList.Builder<String>>)arg_names.value).val.add(first_arg_name.val).build().reverse(), new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_exprright, startCol, endCol);
    :}
  | LAMBDA:lam LPAR:lp IDENTIFIER:first_arg_name COMMA:c identifier_list:arg_names RPAR:rp ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lam.currentInputLine, lamright), new Line(lp.currentInputLine, lpright), new Line(first_arg_name.currentInputLine, first_arg_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue)arg_names.value).currentInputLine, arg_namesright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(lc.currentInputLine, lcright), new Line(() -> "...", lcright + 2 > rcright ? lcright : lcright + 1), new Line(rc.currentInputLine, rcright));
      int startCol = min(lamleft, lpleft, first_arg_nameleft, cleft, arg_names.left, rpleft, aleft, lcleft, rcleft);
      int endCol = max(lamleft + lam.len, lpleft + lp.len, first_arg_nameleft + first_arg_name.len, cleft + c.len, arg_names.left + ((LexedValue)arg_names.value).len, rpleft + rp.len, aleft + a.len, lcleft + lc.len, rcleft + rc.len);

      // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
      RESULT = new LambdaExpr(((LexedValue<ImmutableList.Builder<String>>)arg_names.value).val.add(first_arg_name.val).build().reverse(), stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  | LPAR:lp RPAR:rp ARROW:a expr:implicit_return_expr
    {:
      Supplier<String> currentLinesSupplier =
         joinExprLines(new Line(lp.currentInputLine, lpright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(implicit_return_expr.currentLine, implicit_return_expr.currentLineNumber));
      int startCol = min(lpleft, rpleft, aleft, implicit_return_expr.startCol);
      int endCol = max(lpleft + lp.len, rpleft + rp.len, aleft + a.len, implicit_return_expr.endCol);

      // In this case, we can generate our own settable reference to a TypeProvider for the ReturnStmt.
      AtomicReference<TypeProvider> returnTypeReference = new AtomicReference<>(null);
      ReturnStmt implicitReturnStmt = new ReturnStmt(implicit_return_expr, returnTypeReference);
      RESULT = new LambdaExpr(new StmtListNode(implicitReturnStmt), returnTypeReference, currentLinesSupplier, implicit_return_expr.currentLineNumber, startCol, endCol);
    :}
  | LPAR:lp RPAR:rp ARROW:a LCURLY:lc stmt_list:stmt_list RCURLY:rc
    {:
       // We won't throw type errors at this level for the StmtListNode itself (that'll be handled on the Exprs contained w/in)
       // so intentionally ignore the StmtListNode here for error lines. Pointers may be slightly off if programmer has
       // terrible indentation but in that case, fuck em.
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(lp.currentInputLine, lpright), new Line(rp.currentInputLine, rpright), new Line(a.currentInputLine, aright), new Line(lc.currentInputLine, lcright), new Line(() -> "...", aright + 2 > rcright ? aright : aright + 1), new Line(rc.currentInputLine, rcright));
       int startCol = min(lpleft, rpleft, aleft, lcleft, rcleft);
       int endCol = max(lpleft + lp.len, rpleft + rp.len, aleft + a.len, lcleft + lc.len, rcleft + rc.len);

       // In this case we can pass on the TypeProvider reference that any ReturnStmts have been using.
       RESULT = new LambdaExpr(stmt_list, returnTypeHolder, currentLinesSupplier, rcright, startCol, endCol);
    :}
  ;

identifier_list ::=
    IDENTIFIER:arg_name COMMA:c identifier_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue)tail.value).currentInputLine, tail.right));
       int startCol = min(arg_nameleft, cleft);
       int endCol = max(arg_nameleft + arg_name.len, cleft + c.len);
       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableList.Builder<String>>)tail.value).val.add(arg_name.val),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name
    {:
       RESULT = new Symbol(
          -1,
          arg_nameleft,
          arg_nameright, // line number
          new LexedValue(
            ImmutableList.<String>builder().add(arg_name.val),
            arg_name.currentInputLine,
            arg_name.len)
       );
    :}
  ;

consumer_function_definition_stmt ::=
    CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      RESULT = new ConsumerFunctionDefinitionStmt(name.val, argTypesMap, stmt_list);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set a null return type for any invalid ReturnStmts that are waiting on it and reset the holder.
      if (returnTypeHolder != null) {
        returnTypeHolder.set(null);
        returnTypeHolder = null;
      }
      // This production matched a function defined by a list of statements followed by a return Expr to eval.
      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
        ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new ConsumerFunctionDefinitionStmt(name.val, argTypesMap, Optional.of(injectedKeysList), stmt_list);
    :}
  ;

provider_function_definition_stmt ::=
    PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      RESULT = new ProviderFunctionDefinitionStmt(name.val, outputTypeProvider, stmt_list);
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type LCURLY stmt_list:stmt_list RCURLY
    {:
      // Set the return type for all of the ReturnStmts that are waiting on it and reset the holder.
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;
      returnTypeHolder.set(outputTypeProvider);
      returnTypeHolder = null;
      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new ProviderFunctionDefinitionStmt(name.val, Optional.of(injectedKeysList), outputTypeProvider, stmt_list);
    :}
  ;

injected_keys_list ::=
    IDENTIFIER:key_name COLON:colon builtin_type:t COMMA:comma injected_keys_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentInputLine, key_nameright), new Line(colon.currentInputLine, colonright), new Line(((LexedValue) t.value).currentInputLine, t.right), new Line(comma.currentInputLine, commaright), new Line(((LexedValue) tail.value).currentInputLine, tail.right));
       int startCol = min(key_nameleft, colonleft, t.left, commaleft, tail.left);
       int endCol = max(key_nameleft + key_name.len, colonleft + colon.len, t.left + ((LexedValue) t.value).len, commaleft + comma.len, tail.left + ((LexedValue) tail.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableList.Builder<InjectedKey>>) tail.value).val
              .add(new InjectedKey(key_name.val, ((LexedValue<TypeProvider>) t.value).val, Optional.empty())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:key_name COLON:colon builtin_type:t AS IDENTIFIER:alias COMMA:comma injected_keys_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentInputLine, key_nameright), new Line(colon.currentInputLine, colonright), new Line(((LexedValue) t.value).currentInputLine, t.right), new Line(comma.currentInputLine, commaright), new Line(((LexedValue) tail.value).currentInputLine, tail.right));
       int startCol = min(key_nameleft, colonleft, t.left, commaleft, tail.left);
       int endCol = max(key_nameleft + key_name.len, colonleft + colon.len, t.left + ((LexedValue) t.value).len, commaleft + comma.len, tail.left + ((LexedValue) tail.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableList.Builder<InjectedKey>>) tail.value).val
              .add(new InjectedKey(key_name.val, ((LexedValue<TypeProvider>) t.value).val, Optional.of(alias.val))),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:key_name COLON:c builtin_type:t
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentInputLine, key_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue) t.value).currentInputLine, t.right));
       int startCol = min(key_nameleft, cleft, t.left);
       int endCol = max(key_nameleft + key_name.len, cleft + c.len, t.left + ((LexedValue) t.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ImmutableList.<InjectedKey>builder().add(new InjectedKey(key_name.val, ((LexedValue<TypeProvider>) t.value).val, Optional.empty())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:key_name COLON:c builtin_type:t AS IDENTIFIER:alias
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(key_name.currentInputLine, key_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue) t.value).currentInputLine, t.right));
       int startCol = min(key_nameleft, cleft, t.left);
       int endCol = max(key_nameleft + key_name.len, cleft + c.len, t.left + ((LexedValue) t.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ImmutableList.<InjectedKey>builder().add(new InjectedKey(key_name.val, ((LexedValue<TypeProvider>) t.value).val, Optional.of(alias.val))),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

// TODO(steving) Be less lazy and don't bother using a Map where we should just be using a List of pairs....but Java is so garbage it doesn't have tuples so.....
// Note that we're again building this up backwards for convenience (remember that all guava collections respect ordering).
function_args_types_list ::=
    IDENTIFIER:arg_name COLON:colon builtin_type:t COMMA:comma function_args_types_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(colon.currentInputLine, colonright), new Line(((LexedValue) t.value).currentInputLine, t.right), new Line(comma.currentInputLine, commaright), new Line(((LexedValue) tail.value).currentInputLine, tail.right));
       int startCol = min(arg_nameleft, colonleft, t.left, commaleft, tail.left);
       int endCol = max(arg_nameleft + arg_name.len, colonleft + colon.len, t.left + ((LexedValue) t.value).len, commaleft + comma.len, tail.left + ((LexedValue) tail.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) tail.value).val.put(arg_name.val, ((LexedValue<TypeProvider>) t.value).val),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name COLON:c builtin_type:t
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.currentInputLine, arg_nameright), new Line(c.currentInputLine, cright), new Line(((LexedValue) t.value).currentInputLine, t.right));
       int startCol = min(arg_nameleft, cleft, t.left);
       int endCol = max(arg_nameleft + arg_name.len, cleft + c.len, t.left + ((LexedValue) t.value).len);

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          new LexedValue(
            ImmutableMap.<String, TypeProvider>builder().put(arg_name.val, ((LexedValue<TypeProvider>) t.value).val),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

return_stmt ::=
    RETURN expr:e SEMICOLON
    {:
      // All ReturnStmts belonging to the same procedure expect the same return type. Use this container to
      // act as a placeholder for the procedure to inject that context once the parsing bubbles back up.
      if (returnTypeHolder == null) {
        returnTypeHolder = new AtomicReference<>(); // Start it off empty.
      }
      RESULT = new ReturnStmt(e, returnTypeHolder);
    :}
  ;

// Just to make sure that graphs are somewhat consistent, you must either choose between putting the root node as the
// first or last node definition in the graph body. Let's encourage ordering these sanely because it can be hard to
// trace declarative code without a pattern.
graph_function_definition_stmt ::=
    GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphFunctionDefinitionStmt(
          name.val,
          argTypesMap,
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

       RESULT = new GraphFunctionDefinitionStmt(
          name.val,
          argTypesMap,
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY root_node:root non_root_nodes_list:non_root_nodes RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
      RESULT = new GraphFunctionDefinitionStmt(
          name.val,
          argTypesMap,
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  | USING LPAR injected_keys_list:bw_injected_keys RPAR GRAPH FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type LCURLY non_root_nodes_list:non_root_nodes root_node:root RCURLY
    {:
      TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).val;

      ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).val.build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> argTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();

      // Unlike the various procedure definition stmt productions, there's no need to fiddle with the returnTypeHolder
      // because there's only going to be a single return from a graph function, and by definition every graph function
      // is syntactically guaranteed to have a root node, so there's no concern that we don't know the return type.

      ImmutableList<InjectedKey> injectedKeysList = ((LexedValue<ImmutableList.Builder<InjectedKey>>) bw_injected_keys.value).val.build().reverse();
       RESULT = new GraphFunctionDefinitionStmt(
          name.val,
          argTypesMap,
          Optional.of(injectedKeysList),
          outputTypeProvider,
          root,
          non_root_nodes.build().reverse());
    :}
  ;

root_node ::=
    ROOT IDENTIFIER:name LEFT_ARROW expr:expr SEMICOLON
    {: RESULT = new GraphNodeDefinitionStmt(name.val, expr); :}
  ;

non_root_node ::=
    NODE IDENTIFIER:name LEFT_ARROW expr:expr SEMICOLON
    {: RESULT = new GraphNodeDefinitionStmt(name.val, expr); :}
  ;

non_root_nodes_list ::=
    non_root_node:node non_root_nodes_list:tail
    {: RESULT = tail.add(node); :}
  | non_root_node:node
    {: RESULT = ImmutableList.<GraphNodeDefinitionStmt>builder().add(node); :}
  ;

node_reference ::=
    AT IDENTIFIER:identifier
    {: RESULT = new GraphNodeReferenceExpr(identifier.val, identifier.currentInputLine, identifierright, identifierleft, identifierleft + identifier.len); :}
  ;

function_call_expr ::=
    IDENTIFIER:function_name LPAR:l args_list:args RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(function_name.currentInputLine, function_nameright), new Line(l.currentInputLine, lright), new Line(args), new Line(r.currentInputLine, rright));
       int startCol = min(function_nameleft, lleft, args.left, rleft);
       int endCol = max(function_nameleft + function_name.len, lleft + l.len, args.left + ((LexedValue)args.value).len, rleft + r.len);
       RESULT = new FunctionCallExpr(function_name.val, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).val.build().reverse(), currentLinesSupplier, rright, startCol, endCol);
    :}
  ;

provider_function_call_expr ::=
    IDENTIFIER:provider_name LPAR:l RPAR:r
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(provider_name.currentInputLine, provider_nameright), new Line(l.currentInputLine, lright), new Line(r.currentInputLine, rright));
       int startCol = min(provider_nameleft, lleft, rleft);
       int endCol = max(provider_nameleft + provider_name.len, lleft + l.len, rleft + r.len);
       RESULT = new ProviderFunctionCallExpr(provider_name.val, currentLinesSupplier, rright, startCol, endCol);
    :}
  ;

consumer_function_call_stmt ::=
    IDENTIFIER:consumer_name LPAR args_list:args RPAR SEMICOLON
    {: RESULT = new ConsumerFunctionCallStmt(consumer_name.val, ((LexedValue<ImmutableList.Builder<Expr>>)args.value).val.build().reverse()); :}
  ;

// TODO(steving) Generalize this to use the same approach as method calls.
// TODO(steving) We have no classes yet - so do this once classes & methods exist.
builder_full_build ::=
    builder_method_call_expr:b DOTBUILD:d
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(b), new Line(d.currentInputLine, dright));
       int startCol = Math.min(b.startCol, dleft);
       int endCol = Math.max(b.endCol, dleft + d.len);
       RESULT = new BuilderFullBuildMethodCallExpr(b, currentLinesSupplier, dright, startCol, endCol);
    :}
  ;

builder_method_call_expr ::=
    IDENTIFIER:built_type_name DOT:d BUILDER:b LPAR:l RPAR:r
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(built_type_name.currentInputLine, built_type_nameright), new Line(d.currentInputLine, dright), new Line(b.currentInputLine, bright), new Line(l.currentInputLine, lright), new Line(r.currentInputLine, rright));
       int startCol = min(built_type_nameleft, dleft, bleft, lleft, rleft);
       int endCol = max(built_type_nameleft + built_type_name.len, dleft + d.len, bleft + b.len, lleft + l.len, rleft + r.len);
       RESULT = new BuilderMethodCallExpr(built_type_name.val, currentLinesSupplier, rright, startCol, endCol);
    :}
  | IDENTIFIER:built_type_name DOT:d BUILDER:b LPAR:l RPAR:r builder_setter_chain:set_field_values
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(built_type_name.currentInputLine, built_type_nameright), new Line(d.currentInputLine, dright), new Line(b.currentInputLine, bright), new Line(l.currentInputLine, lright), new Line(r.currentInputLine, rright), new Line(set_field_values));
       int startCol = min(built_type_nameleft, dleft, bleft, lleft, rleft, set_field_valuesleft);
       int endCol = max(built_type_nameleft + built_type_name.len, dleft + d.len, bleft + b.len, lleft + l.len, rleft + r.len, set_field_values.left + ((LexedValue)set_field_values.value).len);
       RESULT = new BuilderMethodCallExpr(built_type_name.val, ((LexedValue<ImmutableMap.Builder<String, Expr>>)set_field_values.value).val.build(), currentLinesSupplier, set_field_valuesright, startCol, endCol);
    :}
  ;

builder_setter_call ::=
    DOT:dot IDENTIFIER:set_field_name LPAR:lpar expr:e RPAR:rpar
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(dot.currentInputLine, dotright), new Line(set_field_name.currentInputLine, set_field_nameright), new Line(lpar.currentInputLine, lparright), new Line(e), new Line(lpar.currentInputLine, lparright));
       int startCol = min(dotleft, set_field_nameleft, lparleft, e.startCol, rparleft);
       int endCol = max(dotleft + dot.len, set_field_nameleft + set_field_name.len, lparleft + lpar.len, e.endCol, rparleft + rpar.len);
       RESULT = new Symbol(
          -1,
          startCol,
          rparright, // rpar's line number
          new LexedValue(
            ImmutableMap.<String, Expr>builder().put(set_field_name.val, e),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

builder_setter_chain ::=
    builder_setter_call:head builder_setter_chain:tail
    {:
       ImmutableMap.Builder<String, Expr> headMapBuilder = ((LexedValue<ImmutableMap.Builder<String, Expr>>)head.value).val;
       ImmutableMap<String, Expr> tailMap = ((LexedValue<ImmutableMap.Builder<String, Expr>>)tail.value).val.build();
       RESULT = chainSymbols(headMapBuilder.putAll(tailMap), head, tail);
    :}
  | builder_setter_call:setter_call
    {: RESULT = setter_call; :}
  ;

inequality ::=
    expr:a L_ANGLE_BRACKET:l expr:b
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(a), new Line(l.currentInputLine, lright), new Line(b));
       int startCol = min(a.startCol, lleft, b.startCol);
       int endCol = max(a.endCol, lleft + l.len, b.endCol);
       RESULT = new LessThanBoolExpr(a, b, currentLinesSupplier, b.currentLineNumber, startCol, endCol);
    :}
  | expr:a R_ANGLE_BRACKET:r expr:b
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(a), new Line(r.currentInputLine, rright), new Line(b));
       int startCol = min(a.startCol, rleft, b.startCol);
       int endCol = max(a.endCol, rleft + r.len, b.endCol);
       RESULT = new GreaterThanBoolExpr(a, b, currentLinesSupplier, b.currentLineNumber, startCol, endCol);
    :}
  | expr:a LTE:lte expr:b
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(a), new Line(lte.currentInputLine, lteright), new Line(b));
       int startCol = min(a.startCol, lteleft, b.startCol);
       int endCol = max(a.endCol, lteleft + lte.len, b.endCol);
       RESULT = new LessThanOrEqualToBoolExpr(a, b, currentLinesSupplier, b.currentLineNumber, startCol, endCol);
    :}
  | expr:a GTE:gte expr:b
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(a), new Line(gte.currentInputLine, gteright), new Line(b));
       int startCol = min(a.startCol, gteleft, b.startCol);
       int endCol = max(a.endCol, gteleft + gte.len, b.endCol);
       RESULT = new GreaterThanOrEqualToBoolExpr(a, b, currentLinesSupplier, b.currentLineNumber, startCol, endCol);
    :}
  ;

bool_arithmetic ::=
    expr:a AND:and expr:b
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(a), new Line(and.currentInputLine, andright), new Line(b));
       int startCol = min(a.startCol, andleft, b.startCol);
       int endCol = max(a.endCol, andleft + and.len, b.endCol);
       RESULT = new AndBoolExpr(a, b, currentLinesSupplier, b.currentLineNumber, startCol, endCol);
    :}
  | expr:a OR:o expr:b
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(a), new Line(o.currentInputLine, oright), new Line(b));
       int startCol = min(a.startCol, oleft, b.startCol);
       int endCol = max(a.endCol, oleft + o.len, b.endCol);
       RESULT = new OrBoolExpr(a, b, currentLinesSupplier, b.currentLineNumber, startCol, endCol);
    :}
  | NOT:n expr:a
    {:
       Supplier<String> currentLinesSupplier = joinExprLines(new Line(n.currentInputLine, nright), new Line(a));
       int startCol = Math.min(nleft, a.startCol);
       int endCol = Math.max(a.endCol, nleft + n.len);
       RESULT = new NotBoolExpr(a, currentLinesSupplier, a.currentLineNumber, startCol, endCol);
    :}
  ;

fmt_string ::=
    FMT_STRING_PART:fs expr:e fmt_string:fswt
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(fs.currentInputLine, fsright), new Line(e.currentLine, e.currentLineNumber), new Line(((LexedValue) fswt.value).currentInputLine, fswt.right));
       int startCol = min(fsleft, e.startCol, fswt.left);
       int endCol = max(fsleft + fs.len, e.endCol, fswt.left + ((LexedValue) fswt.value).len);

       ImmutableList<ImmutableList.Builder> fswtList = ((LexedValue<ImmutableList<ImmutableList.Builder>>)fswt.value).val;
       fswtList.get(0).add(fs.val);
       fswtList.get(1).add(e);

       RESULT = new Symbol(
          -1,
          startCol,
          fswt.right, // line number
          new LexedValue(
            fswtList,
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FMT_STRING_PART:fs expr:e STRING:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(fs.currentInputLine, fsright), new Line(e.currentLine, e.currentLineNumber), new Line(tail.currentInputLine, tailright));
       int startCol = min(fsleft, e.startCol, tailleft);
       int endCol = max(fsleft + fs.len, e.endCol, tailleft + tail.len);

       RESULT = new Symbol(
          -1,
          startCol,
          tailright, // line number
          new LexedValue(
            ImmutableList.of(ImmutableList.builder().add(tail.val).add(fs.val), ImmutableList.builder().add(e)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

// The last production 'term' closes the grammar. It's a primitive or identifier reference.
term ::=
    primitive:p
    {: RESULT = p; :}
  | identifier:i
    {: RESULT = i; :}
  | node_reference:nr
    {: RESULT = nr; :}
  ;

identifier ::=
    IDENTIFIER:identifier
    {: RESULT = new IdentifierReferenceTerm(identifier.val, identifier.currentInputLine, identifierright, identifierleft, identifierleft + identifier.len); :}
  ;

primitive ::=
    float:f
    {: RESULT = f; :}
  | integer:i
    {: RESULT = i; :}
  | STRING:s
    {: RESULT = new StringTerm(s.val, s.currentInputLine, sright, sleft, sleft + s.len); :}
  | TRUE:t
    {: RESULT = new TrueTerm(t.currentInputLine, tright, tleft, tleft + t.len); :}
  | FALSE:f
    {: RESULT = new FalseTerm(f.currentInputLine, fright, fleft, fleft + f.len); :}
  ;

float ::=
    FLOAT:f
    {: RESULT = new FloatTerm(f.val, f.currentInputLine, fright, fleft, fleft + f.len); :}
  ;

integer ::=
    INTEGER:i
    {: RESULT = new IntegerTerm(i.val, i.currentInputLine, iright, ileft, ileft + i.len); :}
  ;
