# Running Claro Programs
Follow these instructions to get running. Recommend getting started by just running some of the demo programs in `./claro_programs/` [here](https://github.com/JasonSteving99/claro-lang/tree/main/src/java/com/claro/claro_programs).

This directory originated as a complete test dir learning about the lexer/parser tools by implementing a calculator but...it's grown beyond that and it's possible that some naming still hasn't caught up lol. But this is straight up Claro.

# Bazel (Highly Recommended)

#### Compiler Backends
Claro's compiler is designed from the ground up to support multiple backends to allow for various modes of handling the parsed AST Intermediate Representation. For now Claro supports the following Targets:

### REPL
`$ bazel run claro_compiler_binary -- --repl --silent`

(Note that this works, but when using the `input()` stmt in the REPL, you won't be able to see what you're typing as input, but it will successfully parse it..)

### Interpreted
`$ bazel run claro_compiler_binary -- --interpreted --silent`

(Turns out that this actually broken until we can make a change to allow the interpreted mode to read from files instead of System.in...since it steals input from the program itself meaning that any program using the `input()` stmt doesn't work...For now it hardcodes using the file `second.claro`.)

### Java Source Target Output
`$ bazel run claro_compiler_binary -- --java_source --silent`


# Docker Hub (only if you can't run Bazel)

If at all possible you should definitely prefer running this project with Bazel from source directly, but if you can't get Bazel working you can find docker images for the binaries generated by this project at the [Docker Hub Repo "clarolang"](https://hub.docker.com/repository/docker/clarolang/claro).

#### REPL Broken in Docker Image
Note that I haven't yet figured out how to get the Lanterna library to work within the Docker Image, so the REPL won't work unless you build from source directly via Bazel rules.

### Pull the Claro Compiler Docker Image

`$ docker pull clarolang/claro:compiler`

### Run the Compiler Over a .claro File to Produce Compiled .java File

`$ docker run -i clarolang/claro:compiler --java_source --silent --classname=First --package="" < first.claro > First.java`

### Run the Compiler Over a .claro File and Run It

`$ docker run -i clarolang/claro:compiler --java_source --silent --classname=First --package="" < first.claro > First.java && javac First.java && java First`

### Cleanup After Yourself

The above commands will have produced some artifact files that you probably don't want lying around:
- `<classname>.java`
- `<classname>.class`
- Optionally, any class files for functions that you may have defined in your program. This is a JAVA_SOURCE CompilerBackend implementation detail... They'll look something like this: `<classname>$1$<functionName>.class`

`$ rm First.java First*.class`
