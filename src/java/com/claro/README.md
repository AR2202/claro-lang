# Learn the Syntax by Example
I recommend getting immersed in Claro syntax by just reading (and running) some of the demo programs in `./claro_programs/` [here](https://github.com/JasonSteving99/claro-lang/tree/main/src/java/com/claro/claro_programs).

# Running Claro Programs
You'll have a few options below for running Claro programs, either by building from the latest source directly, or by using the online REPL.

## Try it Out Online at [riju.codes/claro](https://riju.codes/claro)!
Please keep in mind that in the current state of the world, Riju is generally behind the latest state of Claro development since I don't control Riju and can't redeploy for each new commit to this repo. If you want the latest of the latest then read the below to build Claro locally. 

## Build from Source with Bazel (Highly Recommended)

#### Compiler Backends
Claro's compiler is designed from the ground up to support multiple backends to allow for various modes of handling the parsed AST Intermediate Representation. For now Claro supports the following Targets:

### REPL
`$ bazel run claro_compiler_binary -- --repl --silent`

(Note that this works, but when using the `input()` function in the REPL, you won't be able to see what you're typing as input, but it will successfully parse it..)

### Java Source Target Output
`$ bazel run claro_compiler_binary -- --java_source --silent`

### Interpreted
`$ bazel run claro_compiler_binary -- --interpreted --silent`

(Turns out that this actually broken until we can make a change to allow the interpreted mode to read from files instead of System.in...since it steals input from the program itself meaning that any program using the `input()` stmt doesn't work...For now it hardcodes using the file `second.claro`.)


## ~Docker Hub (only if you can't run Bazel)~ The Docker Image has been abandoned in favor of the [online REPL](https://www.riju.codes/claro)

If at all possible you should definitely prefer running this project with Bazel from source directly, but if you can't get Bazel working you can find docker images for the binaries generated by this project at the [Docker Hub Repo "clarolang"](https://hub.docker.com/repository/docker/clarolang/claro).

#### REPL Broken in Docker Image
Note that I haven't yet figured out how to get the Lanterna library to work within the Docker Image, so the REPL won't work unless you build from source directly via Bazel rules.

### Pull the Claro Compiler Docker Image

`$ docker pull clarolang/claro:compiler`

### Run the Compiler Over a .claro File to Produce Compiled .java File

`$ docker run -i clarolang/claro:compiler --java_source --silent --classname=First --package="" < first.claro > First.java`

### Run the Compiler Over a .claro File and Run It

`$ docker run -i clarolang/claro:compiler --java_source --silent --classname=First --package="" < first.claro > First.java && javac First.java && java First`

### Cleanup After Yourself

The above commands will have produced some artifact files that you probably don't want lying around:
- `<classname>.java`
- `<classname>.class`
- Optionally, any class files for functions that you may have defined in your program. This is a JAVA_SOURCE CompilerBackend implementation detail... They'll look something like this: `<classname>$1$<functionName>.class`

`$ rm First.java First*.class`
