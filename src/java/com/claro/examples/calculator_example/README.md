# Running Executable Calculator Example

#### Compiler Backends
Claro's compiler is designed from the ground up to support multiple backends to allow for various modes of handling the parsed AST Intermediate Representation. For now Claro supports the following Targets:

#### REPL
`$ bazel run compiled_calculator_binary -- --repl --silent`

#### Interpreted
`$ bazel run compiled_calculator_binary -- --interpreted --silent`

#### Java Source Target Output
`$ bazel run compiled_calculator_binary -- --silent`


# Docker Hub

If at all possible you should definitely prefer running this project with Bazel from source directly, but if you can't get Bazel working you can find docker images for the binaries generated by this project at the [Docker Hub Repo "clarolang"](https://hub.docker.com/repository/docker/clarolang/calculator).

#### REPL Broken in Docker Image
Note that I haven't yet figured out how to get the Lanterna library to work within the Docker Image, so the REPL won't work unless you build from source directly via Bazel rules.

### Pull the Calculator Compiler Docker Image

`$ docker pull clarolang/calculator:compiler`

### Run the Compiler Over a .calculator File to Produce Compiled .java File

`$ docker run -i clarolang/calculator:compiler --silent --classname=FirstCalculator --package="" < first.calculator > FirstCalculator.java`

### Run the Compiler Over a .calculator File and Run It

`$ docker run -i clarolang/calculator:compiler --silent --classname=FirstCalculator --package="" < first.calculator > FirstCalculator.java && javac FirstCalculator.java && java FirstCalculator`

### Cleanup After Yourself

The above commands will have produced some artifact files that you probably don't want lying around:
- FirstCalculator.java
- FirstCalculator.class

`$ rm FirstCalculator.java FirstCalculator.class`
