var x: int = 1;

consumer function callMeMaybe(userMessage: string) {
  print("This was the user message!:");
  print(userMessage);
}

function helloFunWorld(message: string, someInt: int) -> string {
  # For what it's worth, note that this function has access to the things declared above it.
  print(x + someInt);

  # Swap the commented res declaration and you'll see a return type error message.
  var res: string = message;
  # var res: int = 1;

  # Prompt the user for something and see if we should call the other function.
  var userResponse = input("Should we call the other function? (y/n): ");
  if (userResponse == "y") {
    callMeMaybe(input("What's your message?: "));
    print("Please ignore this next bit...Claro doesn't allow dead code so I'm using it....");
  } else {
    print("We're not gonna call the other function cuz your response was the following instead of 'y'");
    print(userResponse);
  }

  return res;
}

# The keyword `function` is actually optional here to allow you to be extremely explicit.
provider function gimmeInt() -> int {
   return 9;
}
# Example of defining a Provider w/o using the `function` keyword.
# provider gimmeAnothaInt() -> int {
#   return -9;
# }
var providedInt = gimmeInt();
print("Here's a provided result!");
print(providedInt);

# The keyword `function` is actually optional here to allow you to be extremely explicit.
consumer function takeThis(arg: string) {
  print(arg);
}
# Example of defining a Consumer w/o using the `function` keyword.
consumer takeAnothaOne(arg: int) {
  print(arg);
}
takeThis("we're calling takeThis!");
takeAnothaOne(99);


var helloFunWorldRes = helloFunWorld("Functions in compiled java source Claro code!", 10);
print(helloFunWorldRes);

var y: string = "not in function's scope";
print("Just gonna use y for the sake of satisfying the compiler on this one");
print(y);

print("This is what it looks like to print out the function reference itself");
print(gimmeInt);
var helloFunWorld2: function<|string, int| -> string> = helloFunWorld;
print(helloFunWorld2);

print("We can actually call functions via indirection!");
var gimmeInt2: provider<int> = gimmeInt;
print(gimmeInt2());
type(gimmeInt2);

print("Higher Order functions exist!");
consumer higher(consumerFn: consumer<int>, x: int) {
  consumerFn(x);
  print(consumerFn);
  type(consumerFn);
}
higher(takeAnothaOne, 999);
