package com.claro.examples.calculator_example;

import org.apache.commons.text.StringEscapeUtils;
import java_cup.runtime.Symbol;
import java.util.HashSet;
import java.util.Vector;
/*
 * Copyright (C) 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parser for a simple calculator.
 *
 * <p>The grammar defines a simple arihmetic expressions that supports the addition,
 * subtraction, multiplication, division, exponentiation, logarithms and parentheses.
 *
 * @author Jason Steving, derived from a simpler example by Régis Décamps
 */

action code {:
  int indentationLevel = 1;

  // We're gonna use a set for what would be the "symbol table" for now, since this simple grammar really only needs to
  // check whether a variable has been initialized yet or not.
  HashSet<String> symbolSet = new HashSet<>();
  // We're gonna collect another set for which initialized variables are actually *used* so that we can give a fancy
  // little warning indicating that a variable goes unused.
  HashSet<String> usedSymbolSet = new HashSet<>();

  private String getIndents(int level) {
    StringBuilder res = new StringBuilder();
    for(int i = 0; i < level; i++) {
      res.append("\t");
    }
    return res.toString();
  }

  private String genJavaMain(String expr) {
    return String.format(
      "package com.claro.examples.calculator_example;\n\n" +
      "import java.util.Scanner;\n\n\n" +
      "public class CompiledCalculator {\n" +
      // Programs can prompt users for input, they'll read that input using this Scanner over stdin.
      "  private static final Scanner INPUT_SCANNER = new Scanner(System.in);\n\n" +
      "  public static void main(String[] args) {\n" +
      "/*******AUTO-GENERATED DO NOT MODIFY*******/\n" +
      "%s" +
      "/*******END AUTO-GENERATED*******/\n" +
      "  }\n\n" +
      "  private static double promptUserInput(String prompt) {\n" +
      "    System.out.println(prompt);\n" +
      "    return INPUT_SCANNER.nextDouble();\n" +
      "  }\n" +
      "}",
      expr
    );
  }
:}

parser code {:
:}

// Terminals: () * + - == = ^ ;
terminal         LPAR, RPAR;
terminal         EXPONENTIATE;
terminal         MULTIPLY, DIVIDE;
terminal         PLUS, MINUS;
terminal         SEMICOLON;
terminal         EQUALS;
terminal         ASSIGNMENT;
// An integer is also a terminal, but it's of type Double.
terminal Double  INTEGER;
// A float is also a terminal, but it's of type Double.
terminal Double  FLOAT;
// A string is also a terminal, but it's of type String.
terminal String  STRING;
// A variable identifier is just a sequence of chars.
terminal String  IDENTIFIER;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal         LOG_PREFIX;
// This grammar also has a builtin print() function for printing expr values.
terminal         PRINT;
// This grammar also has a builtin numeric() function for casting booleans to doubles.
terminal         NUMERIC_BOOL;
// This grammar also has a builtin input() functino for reading a number from stdin.
terminal         INPUT;

// Just everything in the world will be real number doubles in this calculator, who cares.
nonterminal String calculated;
nonterminal String equality;
nonterminal String expr;
nonterminal String term;
nonterminal String stmt_list;
nonterminal String stmt;
nonterminal String print;
nonterminal String assignment;
nonterminal String input;
//nonterminal String  calculated;
//nonterminal Boolean equality;
//nonterminal Double  expr;
//nonterminal Double  multiply_expr;
//nonterminal Double  term;

// Lower precedence things at the top, higher precedence things at the bottom.
precedence left IDENTIFIER;
precedence left SEMICOLON;
precedence left ASSIGNMENT;
precedence left EQUALS;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX;

// This is where the grammar starts.
//program ::=
//    calculated SEMICOLON program

calculated ::=
    stmt_list:s
    {:
       symbolSet.removeAll(usedSymbolSet);
       if (symbolSet.size() > 0) {
         throw new CalculatorParserException(
           String.format("Warning! The following declared symbols are unused! %s", symbolSet)
         );
       }
       RESULT = genJavaMain(s);
    :}
// Need to put equality back in the grammar once something is implemented to allow it to act as a double.
//  | equality:e SEMICOLON
//    {: RESULT = genJavaMain(e); :}
  ;

stmt_list ::=
    stmt:head stmt_list:tail
    {: RESULT = String.format("%s%s", head, tail); :}
  | stmt:s
    {: RESULT = String.format("%s", s); :}
  ;

stmt ::=
    print:p SEMICOLON
    {: RESULT = String.format("%s;\n", p); :}
  | assignment:a SEMICOLON
    {: RESULT = String.format("%s;\n", a); :}
  ;

print ::=
    PRINT LPAR expr:e RPAR
    {:
       RESULT = String.format(
         "System.out.println(String.format(\"%s == %%s\", %s))",
         StringEscapeUtils.escapeJava(e),
         e);
    :}
  ;

assignment ::=
    IDENTIFIER:identifier ASSIGNMENT expr:e
    {:
       StringBuilder res = new StringBuilder();
       if (!symbolSet.contains(identifier)) {
          // First time we're seeing the variable, so declare it.
          res.append(String.format("double %s;\n", identifier));
          symbolSet.add(identifier);
       }
       res.append(String.format("%s = %s", identifier, e));
       RESULT = res.toString();
    :}
  ;

// In reality, right now expr is taking on multiple types and this is unchecked. Runtime failures are allowed in this
// language at the moment. Fix this later, for now, explicit casting between bool and number have to be done carefully.
expr ::=
    MINUS expr:e
    {: RESULT = String.format("(-%s)", e); :}
  | expr:a PLUS expr:b
    {: RESULT = String.format("(%s + %s)", a, b); :}
  | expr:a MINUS expr:b
    {: RESULT = String.format("(%s - %s)", a, b); :}
  | expr:a MULTIPLY expr:b
    {: RESULT = String.format("(%s * %s)", a, b); :}
  | expr:a DIVIDE expr:b // Only support int-division right now...
    {: RESULT = String.format("(%s / %s)", a, b); :}
  | expr:a EXPONENTIATE expr:b // Only support int-exponentiation right now...
    {: RESULT = String.format("Math.pow(%s, %s)", a,b); :}
  | LOG_PREFIX FLOAT:float_base LPAR expr:arg RPAR
    {: RESULT = String.format("(Math.log(%s) / Math.log(%s))", arg, float_base); :}
  | LOG_PREFIX INTEGER:int_base LPAR expr:arg RPAR
    {: RESULT = String.format("(Math.log(%s) / Math.log(%s))", arg, int_base); :}
  | NUMERIC_BOOL LPAR equality:b RPAR
    {: RESULT = String.format("(%s ? 1 : 0)", b); :}
  | equality:b
    {: RESULT = b; :}  // This is the action that causes the type-unsafety in this language...introduces booleans.
  | term:t
    {: RESULT = t; :}
  ;

// This calculator can evaluate an equality check of expressions, but then it must be the topmost grammar production.
equality ::=
    expr:a EQUALS expr:b
    {: RESULT = String.format("(%s == %s)", a, b); :}
    ;

// The last term closes the grammar. It's a number, or another expression in parentheses.
term ::=
    LPAR expr:e RPAR
    {: RESULT = String.format("(%s)", e); :}
  | FLOAT:f
    {: RESULT = f.toString(); :}
  | INTEGER:i
    {: RESULT = i.toString(); :}
  | IDENTIFIER:identifier
    {:
       // Make sure we check this will actually be a valid reference before we allow it.
       if (!symbolSet.contains(identifier)) {
         throw new CalculatorParserException(String.format("Referencing variable <%s> before assignment!", identifier));
       }

       // Mark that we're using this variable as a term, so that at the end of the program, we can warn about unused.
       usedSymbolSet.add(identifier);

       RESULT = identifier;
    :}
  | input:i
    {: RESULT = i; :}
  ;

input ::=
    INPUT LPAR STRING:prompt RPAR
    {: RESULT = String.format("promptUserInput(\"%s\")", prompt); :}
  ;

