package com.claro.examples.calculator_example;

import com.claro.examples.calculator_example.intermediate_representation.*;
import org.apache.commons.text.StringEscapeUtils;
import java_cup.runtime.Symbol;
import java.util.HashSet;
import java.util.Vector;
import java.util.Stack;
/*
 * Copyright (C) 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parser for a simple calculator.
 *
 * <p>The grammar defines a simple arihmetic expressions that supports the addition,
 * subtraction, multiplication, division, exponentiation, logarithms and parentheses.
 *
 * @author Jason Steving, derived from a simpler example by Régis Décamps
 */

action code {:
  int indentationLevel = 1;

  // We're gonna use a set for what would be the "symbol table" for now, since this simple grammar really only needs to
  // check whether a variable has been initialized yet or not.
  HashSet<String> symbolSet = new HashSet<>();
  // We're gonna collect another set for which initialized variables are actually *used* so that we can give a fancy
  // little warning indicating that a variable goes unused.
  HashSet<String> usedSymbolSet = new HashSet<>();

  private String getIndents(int level) {
    StringBuilder res = new StringBuilder();
    for(int i = 0; i < level; i++) {
      res.append("\t");
    }
    return res.toString();
  }

  /**
  * In some ways this hardcoded class is basically a standard library for this language.
  */
  private String genJavaMain(String expr) {
    return String.format(
      "%s" +
      "import java.util.Scanner;\n\n\n" +
      "public class %s {\n" +
      // Programs can prompt users for input, they'll read that input using this Scanner over stdin.
      "  private static final Scanner INPUT_SCANNER = new Scanner(System.in);\n\n" +
      "  public static void main(String[] args) {\n" +
      "/*******AUTO-GENERATED DO NOT MODIFY*******/\n" +
      "%s" +
      "/*******END AUTO-GENERATED*******/\n" +
      "  }\n\n" +
      "  private static double promptUserInput(String prompt) {\n" +
      "    System.out.println(prompt);\n" +
      "    return INPUT_SCANNER.nextDouble();\n" +
      "  }\n" +
      "}",
      parser.package_string,
      parser.generatedClassName,
      expr
    );
  }
:}

parser code {:
  public String generatedClassName = "CompiledCalculator";  // default to be overridden.
  public String package_string = "";  // default to be overridden.
:}

// Terminals: () * + - == < > <= >= or and = ^ ;
terminal         LPAR, RPAR;
terminal         LCURLY, RCURLY;
terminal         EXPONENTIATE;
terminal         MULTIPLY, DIVIDE;
terminal         PLUS, MINUS;
terminal         SEMICOLON;
terminal         EQUALS, NOT_EQUALS;
terminal         ASSIGNMENT;
terminal         LBRACKET, RBRACKET, LTE, GTE;
terminal         OR, AND, NOT;
terminal         TRUE, FALSE;
// An integer is also a terminal, but it's of type Integer.
terminal Integer INTEGER;
// A float is also a terminal, but it's of type Double.
terminal Double  FLOAT;
// A string is also a terminal, but it's of type String.
terminal String  STRING;
// A variable identifier is just a sequence of chars.
terminal String  IDENTIFIER;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal         LOG_PREFIX;
// This grammar also has a builtin print() function for printing expr values.
terminal         PRINT;
// This grammar also has a builtin numeric() function for casting booleans to doubles.
terminal         NUMERIC_BOOL;
// This grammar also has a builtin input() functino for reading a number from stdin.
terminal         INPUT;

// Just everything in the world will be real number doubles in this calculator, who cares.
nonterminal String      calculated;
nonterminal Expr        expr;
nonterminal Term        term;
nonterminal Term        primitive;
nonterminal FloatTerm   float;
nonterminal IntegerTerm integer;
nonterminal String      stmt;
nonterminal String      stmt_list;
nonterminal String      print;
nonterminal String      assignment;
nonterminal InputExpr   input;
nonterminal BoolExpr    bool_expr;
nonterminal BoolExpr    equality;
nonterminal BoolExpr    inequality;
nonterminal BoolExpr    bool_arithmetic;
//nonterminal String  calculated;
//nonterminal Boolean equality;
//nonterminal Double  expr;
//nonterminal Double  multiply_expr;
//nonterminal Double  term;

// Lower precedence things at the top, higher precedence things at the bottom.
precedence left IDENTIFIER;
precedence left SEMICOLON;
precedence left ASSIGNMENT;
precedence left EQUALS, NOT_EQUALS;
precedence left AND, OR, NOT;
precedence left LBRACKET, RBRACKET, LTE, GTE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX;

// This is where the grammar starts.
calculated ::=
    stmt_list:s
    {:
       symbolSet.removeAll(usedSymbolSet);
       if (symbolSet.size() > 0) {
         throw new CalculatorParserException(
           String.format("Warning! The following declared symbols are unused! %s", symbolSet)
         );
       }
       RESULT = genJavaMain(s);
    :}
  ;

stmt_list ::=
    stmt:head stmt_list:tail
    {: RESULT = String.format("%s%s", head, tail); :}
  | stmt:s
    {: RESULT = String.format("%s", s); :}
  ;

stmt ::=
    print:p SEMICOLON
    {: RESULT = String.format("%s;\n", p); :}
  | assignment:a SEMICOLON
    {: RESULT = String.format("%s;\n", a); :}
  ;

print ::=
    PRINT LPAR expr:e RPAR
    {:
       String expr_java_source = e.generateTargetOutput(Target.JAVA_SOURCE).toString();
       RESULT = String.format(
         "System.out.println(String.format(\"%s == %%s\", %s))",
         StringEscapeUtils.escapeJava(expr_java_source),
         expr_java_source);
    :}
  ;

assignment ::=
    IDENTIFIER:identifier ASSIGNMENT expr:e
    {:
       StringBuilder res = new StringBuilder();
       if (!symbolSet.contains(identifier)) {
          // First time we're seeing the variable, so declare it.
          res.append(String.format("double %s;\n", identifier));
          symbolSet.add(identifier);
       }
       res.append(String.format("%s = %s", identifier, e.generateTargetOutput(Target.JAVA_SOURCE).toString()));
       RESULT = res.toString();
    :}
  ;

// TODO(steving) Everything above this line still needs conversion to AST IR Nodes.

// In reality, right now expr is taking on multiple types and this is unchecked. Runtime failures are allowed in this
// language at the moment. Fix this later, for now, explicit casting between bool and number have to be done carefully.
expr ::=
    MINUS expr:e
    {: RESULT = new NegateNumericExpr(e); :}
  | expr:a PLUS expr:b
    {: RESULT = new AddNumericExpr(a, b); :}
  | expr:a MINUS expr:b
    {: RESULT = new SubtractNumericExpr(a, b); :}
  | expr:a MULTIPLY expr:b
    {: RESULT = new MultiplyNumericExpr(a, b); :}
  | expr:a DIVIDE expr:b // Only support int-division right now...
    {: RESULT = new DivideNumericExpr(a, b); :}
  | expr:a EXPONENTIATE expr:b // Only support int-exponentiation right now...
    {: RESULT = new ExponentiateNumericExpr(a, b); :}
  | LPAR expr:e RPAR
    {: RESULT = new ParenthesizedExpr(e); :}
  | LOG_PREFIX float:float_base LPAR expr:arg RPAR
    {: RESULT = new LogNumericExpr(arg, float_base); :}
  | LOG_PREFIX integer:int_base LPAR expr:arg RPAR
    {: RESULT = new LogNumericExpr(arg, int_base); :}
  | NUMERIC_BOOL LPAR bool_expr:b RPAR
    {: RESULT = new NumericBoolNumericExpr(b); :}
  | input:i
    {: RESULT = i; :}
  | bool_expr:b
    // TODO(steving) Address this. This action causes type-unsafety in this language...introduces booleans where really
    // there should only be doubles.
    {: RESULT = b; :}
  | term:t
    {: RESULT = t; :}
  ;

input ::=
    INPUT LPAR STRING:prompt RPAR
    {: RESULT = new InputExpr(prompt); :}
  ;

bool_expr ::=
    equality:b
    {: RESULT = b; :}
  | inequality:b
    {: RESULT = b; :}
  | bool_arithmetic:b
    {: RESULT = b; :}
  ;

// This calculator can evaluate an equality check of expressions.
equality ::=
    expr:a EQUALS expr:b
    {: RESULT = new EqualsBoolExpr(a, b); :}
  | expr:a NOT_EQUALS expr:b
    {: RESULT = new NotEqualsBoolExpr(a, b); :}
  ;

inequality ::=
    expr:a LBRACKET expr:b
    {: RESULT = new LessThanBoolExpr(a, b); :}
  | expr:a RBRACKET expr:b
    {: RESULT = new GreaterThanBoolExpr(a, b); :}
  | expr:a LTE expr:b
    {: RESULT = new LessThanOrEqualToBoolExpr(a, b); :}
  | expr:a GTE expr:b
    {: RESULT = new GreaterThanOrEqualToBoolExpr(a, b); :}
  ;

// TODO(steving) Address this. This action causes type-unsafety in this language...allows doubles where really
// there should only be booleans.
bool_arithmetic ::=
    expr:a AND expr:b
    {: RESULT = new AndBoolExpr(a, b); :}
  | expr:a OR expr:b
    {: RESULT = new OrBoolExpr(a, b); :}
  | NOT expr:a
    {: RESULT = new NotBoolExpr(a); :}
  ;

// The last production 'term' closes the grammar. It's a primitive or identifier.
term ::=
    primitive:p
    {: RESULT = p; :}
  | IDENTIFIER:identifier
    {: RESULT = new IdentifierReferenceTerm(identifier, symbolSet, usedSymbolSet); :}
  ;

primitive ::=
    float:f
    {: RESULT = f; :}
  | integer:i
    {: RESULT = i; :}
  | STRING:s
    {: RESULT = new StringTerm(s); :}
  | TRUE
    {: RESULT = new TrueTerm(); :}
  | FALSE
    {: RESULT = new FalseTerm(); :}
  ;

float ::=
    FLOAT:f
    {: RESULT = new FloatTerm(f); :}
  ;

integer ::=
    INTEGER:i
    {: RESULT = new IntegerTerm(i); :}
  ;
