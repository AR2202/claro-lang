package com.claro.examples.calculator_example;

import java_cup.runtime.Symbol;
import java.util.Vector;
/*
 * Copyright (C) 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parser for a simple calculator.
 *
 * <p>The grammar defines a simple arihmetic expressions that supports the addition,
 * subtraction, multiplication, division, exponentiation, logarithms and parentheses.
 *
 * @author Jason Steving, derived from a simpler example by Régis Décamps
 */

action code {:
  int indentationLevel = 1;

  private String getIndents(int level) {
    StringBuilder res = new StringBuilder();
    for(int i = 0; i < level; i++) {
      res.append("\t");
    }
    return res.toString();
  }

  private String genJavaMain(String expr) {
    return String.format(
      "package com.claro.examples.calculator_example;\n\n" +
      "public class CompiledCalculator {\n" +
      "  public static void main(String[] args) {\n" +
      "    System.out.printf(\"Computing the following:\\n%%s\\n= \", \"%s\");\n" +
      "    System.out.println(%s);\n" +
      "  }\n" +
      "}",
      expr,
      expr
    );
  }
:}

parser code {:
:}

// Terminals: () * + - =
terminal         LPAR, RPAR;
terminal         EXPONENTIATE;
terminal         MULTIPLY, DIVIDE;
terminal         PLUS, MINUS;
// An integer is also a terminal, bit it's of type Double.
terminal Double  INTEGER;
// A float is also a terminal, bit it's of type Double.
terminal Double  FLOAT;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal         LOG_PREFIX;
terminal         EQUALS;

// Just everything in the world will be real number doubles in this calculator, who cares.
nonterminal String calculated;
nonterminal String equality;
nonterminal String expr;
nonterminal String multiply_expr;
nonterminal String term;
//nonterminal String  calculated;
//nonterminal Boolean equality;
//nonterminal Double  expr;
//nonterminal Double  multiply_expr;
//nonterminal Double  term;

precedence left EQUALS;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX;

// This is where the grammar starts.
calculated ::=
    expr:e
    {: RESULT = genJavaMain(e); :}
  | equality:e
    {: RESULT = genJavaMain(e); :}
  ;

// An expression is a sum of priority_expr. Because the parser needs to produce priority_expr
// in order to assemble expr, this effectively makes priority_expr of higher priority than
// expr in the computation of the result.
// We also implement the actual computation done by the calculator. RESULT is the label that is
// assigned automatically to the rhs, in this case 'expr' because 'expr ::= ...'.
// Since the priority_expr is an object of type Double, we can call doubleValue() to retrieve its
// value.
expr ::=
    MINUS expr:e
    {: RESULT = String.format("(-%s)", e); :}
  | expr:a PLUS expr:b
    {: RESULT = String.format("(%s + %s)", a, b); :}
  | expr:a MINUS expr:b
    {: RESULT = String.format("(%s - %s)", a, b); :}
  | expr:a MULTIPLY expr:b
    {: RESULT = String.format("(%s * %s)", a, b); :}
  | expr:a DIVIDE expr:b // Only support int-division right now...
    {: RESULT = String.format("(%s / %s)", a, b); :}
  | expr:a EXPONENTIATE expr:b // Only support int-exponentiation right now...
    {: RESULT = String.format("Math.pow(%s, %s)", a,b); :}
  | LOG_PREFIX FLOAT:float_base LPAR expr:arg RPAR
    {: RESULT = String.format("(Math.log(%s) / Math.log(%s))", arg, float_base); :}
  | LOG_PREFIX INTEGER:int_base LPAR expr:arg RPAR
    {: RESULT = String.format("(Math.log(%s) / Math.log(%s))", arg, int_base); :}
  | term:t
    {: RESULT = t; :}
  ;

// This calculator can evaluate an equality check of expressions, but then it must be the topmost grammar production.
equality ::=
    expr:a EQUALS expr:b
    {: RESULT = String.format("(%s == %s)", a, b); :}
    ;

// The last term closes the grammar. It's a number, or another expression in parentheses.
term ::=
    LPAR expr:e RPAR
    {: RESULT = String.format("(%s)", e); :}
  | FLOAT:f
    {: RESULT = f.toString(); :}
  | INTEGER:i
    {: RESULT = i.toString(); :}
  ;
