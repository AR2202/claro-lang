package com.claro.examples.calculator_example;

import com.claro.examples.calculator_example.intermediate_representation.*;
import java_cup.runtime.Symbol;
import java.util.HashSet;
import java.util.Vector;
import java.util.Stack;
/*
 * Copyright (C) 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parser for a simple calculator.
 *
 * <p>The grammar defines a simple arihmetic expressions that supports the addition,
 * subtraction, multiplication, division, exponentiation, logarithms and parentheses.
 *
 * @author Jason Steving, derived from a simpler example by Régis Décamps
 */

action code {:
  int indentationLevel = 1;

  private String getIndents(int level) {
    StringBuilder res = new StringBuilder();
    for(int i = 0; i < level; i++) {
      res.append("\t");
    }
    return res.toString();
  }
:}

parser code {:
  public String generatedClassName = "CompiledCalculator";  // default to be overridden.
  public String package_string = "";  // default to be overridden.
  // We're gonna use a set for what would be the "symbol table" for now, since this simple grammar really only needs to
  // check whether a variable has been initialized yet or not.
  public HashSet<String> symbolSet = new HashSet<>();
  // We're gonna collect another set for which initialized variables are actually *used* so that we can give a fancy
  // little warning indicating that a variable goes unused.
  public HashSet<String> usedSymbolSet = new HashSet<>();
  // We need a knob for enabling/disabling unused checks in order to have REPL support.
  public boolean checkUnused = true;
:}

// Terminals: () * + - == < > <= >= or and = ^ ;
terminal         LPAR, RPAR;
terminal         LCURLY, RCURLY;
terminal         EXPONENTIATE;
terminal         MULTIPLY, DIVIDE;
terminal         PLUS, MINUS;
terminal         SEMICOLON;
terminal         EQUALS, NOT_EQUALS;
terminal         ASSIGNMENT;
terminal         LBRACKET, RBRACKET, LTE, GTE;
terminal         OR, AND, NOT;
terminal         TRUE, FALSE;
// An integer is also a terminal, but it's of type Integer.
terminal Integer INTEGER;
// A float is also a terminal, but it's of type Double.
terminal Double  FLOAT;
// A string is also a terminal, but it's of type String.
terminal String  STRING;
// A variable identifier is just a sequence of chars.
terminal String  IDENTIFIER;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal         LOG_PREFIX;
// This grammar also has a builtin print() function for printing expr values.
terminal         PRINT;
// This grammar also has a builtin numeric() function for casting booleans to doubles.
terminal         NUMERIC_BOOL;
// This grammar also has a builtin input() functino for reading a number from stdin.
terminal         INPUT;
terminal         IF;

// Just everything in the world will be real number doubles in this calculator, who cares.
nonterminal ProgramNode     program;
nonterminal Expr            expr;
nonterminal Term            term;
nonterminal Term            primitive;
nonterminal FloatTerm       float;
nonterminal IntegerTerm     integer;
nonterminal Stmt            stmt;
nonterminal StmtListNode    stmt_list;
nonterminal IfStmt          if_stmt;
nonterminal PrintStmt       print;
nonterminal AssignmentStmt  assignment;
nonterminal InputExpr       input;
nonterminal BoolExpr        bool_expr;
nonterminal BoolExpr        equality;
nonterminal BoolExpr        inequality;
nonterminal BoolExpr        bool_arithmetic;

// Lower precedence things at the top, higher precedence things at the bottom.
precedence left IDENTIFIER;
precedence left SEMICOLON;
precedence left ASSIGNMENT;
precedence left EQUALS, NOT_EQUALS;
precedence left AND, OR, NOT;
precedence left LBRACKET, RBRACKET, LTE, GTE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX, IF;

// This is where the grammar starts.
program ::=
    stmt_list:s
    {:
       RESULT = new ProgramNode(s, symbolSet, usedSymbolSet, checkUnused, package_string, generatedClassName);
    :}
  ;

stmt_list ::=
    stmt:head stmt_list:tail
    {: RESULT = new StmtListNode(head, tail); :}
  | stmt:s
    {: RESULT = new StmtListNode(s); :}
  ;

stmt ::=
    print:p
    {: RESULT = p; :}
  | assignment:a
    {: RESULT = a; :}
  | if_stmt:i
    {: RESULT = i; :}
  ;

print ::=
    PRINT LPAR expr:e RPAR SEMICOLON
    {: RESULT = new PrintStmt(e); :}
  ;

assignment ::=
    IDENTIFIER:identifier ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new AssignmentStmt(identifier, e, symbolSet, usedSymbolSet); :}
  ;

// In reality, right now expr is taking on multiple types and this is unchecked. Runtime failures are allowed in this
// language at the moment. Fix this later, for now, explicit casting between bool and number have to be done carefully.
expr ::=
    MINUS expr:e
    {: RESULT = new NegateNumericExpr(e); :}
  | expr:a PLUS expr:b
    {: RESULT = new AddNumericExpr(a, b); :}
  | expr:a MINUS expr:b
    {: RESULT = new SubtractNumericExpr(a, b); :}
  | expr:a MULTIPLY expr:b
    {: RESULT = new MultiplyNumericExpr(a, b); :}
  | expr:a DIVIDE expr:b // Only support int-division right now...
    {: RESULT = new DivideNumericExpr(a, b); :}
  | expr:a EXPONENTIATE expr:b // Only support int-exponentiation right now...
    {: RESULT = new ExponentiateNumericExpr(a, b); :}
  | LPAR expr:e RPAR
    {: RESULT = new ParenthesizedExpr(e); :}
  | LOG_PREFIX float:float_base LPAR expr:arg RPAR
    {: RESULT = new LogNumericExpr(arg, float_base); :}
  | LOG_PREFIX integer:int_base LPAR expr:arg RPAR
    {: RESULT = new LogNumericExpr(arg, int_base); :}
  | NUMERIC_BOOL LPAR bool_expr:b RPAR
    {: RESULT = new NumericBoolNumericExpr(b); :}
  | input:i
    {: RESULT = i; :}
  | bool_expr:b
    // TODO(steving) Address this. This action causes type-unsafety in this language...introduces booleans where really
    // there should only be doubles.
    {: RESULT = b; :}
  | term:t
    {: RESULT = t; :}
  ;

input ::=
    INPUT LPAR STRING:prompt RPAR
    {: RESULT = new InputExpr(prompt); :}
  ;

bool_expr ::=
    equality:b
    {: RESULT = b; :}
  | inequality:b
    {: RESULT = b; :}
  | bool_arithmetic:b
    {: RESULT = b; :}
  ;

// This calculator can evaluate an equality check of expressions.
equality ::=
    expr:a EQUALS expr:b
    {: RESULT = new EqualsBoolExpr(a, b); :}
  | expr:a NOT_EQUALS expr:b
    {: RESULT = new NotEqualsBoolExpr(a, b); :}
  ;

if_stmt ::=
    IF LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new IfStmt(e, stmt_list); :}
  ;

inequality ::=
    expr:a LBRACKET expr:b
    {: RESULT = new LessThanBoolExpr(a, b); :}
  | expr:a RBRACKET expr:b
    {: RESULT = new GreaterThanBoolExpr(a, b); :}
  | expr:a LTE expr:b
    {: RESULT = new LessThanOrEqualToBoolExpr(a, b); :}
  | expr:a GTE expr:b
    {: RESULT = new GreaterThanOrEqualToBoolExpr(a, b); :}
  ;

// TODO(steving) Address this. This action causes type-unsafety in this language...allows doubles where really
// there should only be booleans.
bool_arithmetic ::=
    expr:a AND expr:b
    {: RESULT = new AndBoolExpr(a, b); :}
  | expr:a OR expr:b
    {: RESULT = new OrBoolExpr(a, b); :}
  | NOT expr:a
    {: RESULT = new NotBoolExpr(a); :}
  ;

// The last production 'term' closes the grammar. It's a primitive or identifier.
term ::=
    primitive:p
    {: RESULT = p; :}
  | IDENTIFIER:identifier
    {: RESULT = new IdentifierReferenceTerm(identifier, symbolSet, usedSymbolSet); :}
  ;

primitive ::=
    float:f
    {: RESULT = f; :}
  | integer:i
    {: RESULT = i; :}
  | STRING:s
    {: RESULT = new StringTerm(s); :}
  | TRUE
    {: RESULT = new TrueTerm(); :}
  | FALSE
    {: RESULT = new FalseTerm(); :}
  ;

float ::=
    FLOAT:f
    {: RESULT = new FloatTerm(f); :}
  ;

integer ::=
    INTEGER:i
    {: RESULT = new IntegerTerm(i); :}
  ;
