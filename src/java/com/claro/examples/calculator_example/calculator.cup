package com.claro.examples.calculator_example;

import java_cup.runtime.Symbol;
import java.util.Vector;
/*
 * Copyright (C) 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parser for a simple calculator.
 *
 * <p>The grammar defines a simple arihmetic expressions that supports the addition,
 * subtraction, multiplication, division, exponentiation, logarithms and parentheses.
 *
 * @author Jason Steving, derived from a simpler example by Régis Décamps
 */

parser code {:
:}

// Terminals: () * + -
terminal         LPAR, RPAR;
terminal         EXPONENTIATE;
terminal         MULTIPLY, DIVIDE;
terminal         PLUS, MINUS;
// An integer is also a terminal, bit it's of type Double.
terminal Double INTEGER;
// A float is also a terminal, bit it's of type Double.
terminal Double  FLOAT;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal         LOG_PREFIX;

// Just everything in the world will be real number doubles in this calculator, who cares.
non terminal Double expr;
non terminal Double multiply_expr;
non terminal Double term;

precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX;

// This is where the grammar starts.

// An expression is a sum of priority_expr. Because the parser needs to produce priority_expr
// in order to assemble expr, this effectively makes priority_expr of higher priority than
// expr in the computation of the result.
// We also implement the actual computation done by the calculator. RESULT is the label that is
// assigned automatically to the rhs, in this case 'expr' because 'expr ::= ...'.
// Since the priority_expr is an object of type Double, we can call doubleValue() to retrieve its
// value.
expr ::=
    MINUS expr:a
    {: RESULT = -a; :}
  | expr:a PLUS expr:b
    {: RESULT = a.doubleValue() + b.doubleValue(); :}
  | expr:a MINUS expr:b
    {: RESULT = a.doubleValue() - b.doubleValue(); :}
  | expr:a MULTIPLY expr:b
    {: RESULT = a.doubleValue() * b.doubleValue(); :}
  | expr:a DIVIDE expr:b // Only support int-division right now...
    {: RESULT = a.doubleValue() / b.doubleValue(); :}
  | expr:a EXPONENTIATE expr:b // Only support int-exponentiation right now...
    {: RESULT = Math.pow(a, b); :}
  | LOG_PREFIX FLOAT:float_base LPAR expr:arg RPAR
    {: RESULT = Math.log(arg) / Math.log(float_base); :}
  | LOG_PREFIX INTEGER:int_base LPAR expr:arg RPAR
    {: RESULT = Math.log(arg) / Math.log(int_base); :}
  | term:t
    {: RESULT = t; :}
  ;
// The last term closes the grammar. It's a number, or another expression in parentheses.
// Note that local identifiers don't need to be a single letter. We use "nb" for the terminal
// number.
term ::=
    LPAR expr:e RPAR
    {: RESULT = e; :}
  | FLOAT:f
    {: RESULT = f; :}
  | INTEGER:i
    {: RESULT = i; :}
  ;
