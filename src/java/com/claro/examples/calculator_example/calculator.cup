package com.claro.examples.calculator_example;

import com.claro.examples.calculator_example.intermediate_representation.*;
import com.google.common.collect.ImmutableList;
import java_cup.runtime.Symbol;
import java.util.HashSet;
/*
 * Copyright (C) 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parser for a simple calculator.
 *
 * <p>The grammar defines a simple arihmetic expressions that supports the addition,
 * subtraction, multiplication, division, exponentiation, logarithms and parentheses.
 *
 * @author Jason Steving, derived from a simpler example by Régis Décamps
 */

action code {:
  int indentationLevel = 1;

  private String getIndents(int level) {
    StringBuilder res = new StringBuilder();
    for(int i = 0; i < level; i++) {
      res.append("\t");
    }
    return res.toString();
  }
:}

parser code {:
  public String generatedClassName = "CompiledCalculator";  // default to be overridden.
  public String package_string = "";  // default to be overridden.
:}

terminal         LPAR, RPAR;
terminal         LCURLY, RCURLY, LBRACKET, RBRACKET;
terminal         EXPONENTIATE;
terminal         MULTIPLY, DIVIDE;
terminal         PLUS, MINUS;
terminal         SEMICOLON;
terminal         COMMA;
terminal         EQUALS, NOT_EQUALS;
terminal         ASSIGNMENT;
terminal         L_ANGLE_BRACKET, R_ANGLE_BRACKET, LTE, GTE;
terminal         OR, AND, NOT;
terminal         TRUE, FALSE;
// An integer is also a terminal, but it's of type Integer.
terminal Integer INTEGER;
// A float is also a terminal, but it's of type Double.
terminal Double  FLOAT;
// A string is also a terminal, but it's of type String.
terminal String  STRING;
// A variable identifier is just a sequence of chars.
terminal String  IDENTIFIER;
// The prefix "log_", of the function log_x(y), is also a terminal.
// This is good practice for figuring out how to handle functions
// once I get to Claro, consider this a function hard-coded into the
// grammar.
terminal         LOG_PREFIX;
// This grammar also has a builtin print() function for printing expr values.
terminal         PRINT;
// This grammar also has a builtin numeric() function for casting booleans to doubles.
terminal         NUMERIC_BOOL;
// This grammar also has a builtin input() functino for reading a number from stdin.
terminal         INPUT;
terminal         IF, ELSE;
terminal         WHILE;

// Just everything in the world will be real number doubles in this calculator, who cares.
nonterminal ProgramNode                 program;
nonterminal Expr                        expr;
nonterminal Term                        term;
nonterminal Term                        primitive;
nonterminal IdentifierReferenceTerm     identifier;
nonterminal FloatTerm                   float;
nonterminal IntegerTerm                 integer;
nonterminal Stmt                        stmt;
nonterminal StmtListNode                stmt_list;
nonterminal ListExpr                    list;
nonterminal ListSubscriptExpr           list_subscript;
nonterminal ImmutableList.Builder<Node> list_initializer_args;
nonterminal IfStmt                      if_else_chain_stmt;
nonterminal IfStmt                      if_stmt;
nonterminal IfStmt                      else_if_stmt_chain;
nonterminal IfStmt                      else_if_stmt;
nonterminal StmtListNode                else_stmt;
nonterminal WhileStmt                   while_stmt;
nonterminal PrintStmt                   print;
nonterminal AssignmentStmt              identifier_assignment;
nonterminal ListElementAssignmentStmt   list_element_assignment;
nonterminal InputExpr                   input;
nonterminal BoolExpr                    bool_expr;
nonterminal BoolExpr                    equality;
nonterminal BoolExpr                    inequality;
nonterminal BoolExpr                    bool_arithmetic;

// Lower precedence things at the top, higher precedence things at the bottom.
// ...but also I've basically put no thought whatsoever into the order these ACTUALLY appear in.
precedence left COMMA;
precedence left IDENTIFIER;
precedence left SEMICOLON;
precedence left ASSIGNMENT;
precedence left EQUALS, NOT_EQUALS;
precedence left AND, OR, NOT;
precedence left L_ANGLE_BRACKET, R_ANGLE_BRACKET, LTE, GTE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence left EXPONENTIATE;
precedence left LOG_PREFIX, IF, ELSE;
precedence left WHILE;

// This is where the grammar starts.
program ::=
    stmt_list:s
    {:
       RESULT = new ProgramNode(s, package_string, generatedClassName);
    :}
  ;

stmt_list ::=
    stmt:head stmt_list:tail
    {: RESULT = new StmtListNode(head, tail); :}
  | stmt:s
    {: RESULT = new StmtListNode(s); :}
  ;

stmt ::=
    print:p
    {: RESULT = p; :}
  | identifier_assignment:a
    {: RESULT = a; :}
  | list_element_assignment:l
    {: RESULT = l; :}
  | if_else_chain_stmt:i
    {: RESULT = i; :}
  | while_stmt:w
    {: RESULT = w; :}
  ;

print ::=
    PRINT LPAR expr:e RPAR SEMICOLON
    {: RESULT = new PrintStmt(e); :}
  ;

identifier_assignment ::=
    IDENTIFIER:identifier ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new AssignmentStmt(identifier, e); :}
  ;

list_element_assignment ::=
    list_subscript:l ASSIGNMENT expr:e SEMICOLON
    {: RESULT = new ListElementAssignmentStmt(l, e); :}
  ;

// In reality, right now expr is taking on multiple types and this is unchecked. Runtime failures are allowed in this
// language at the moment. Fix this later, for now, explicit casting between bool and number have to be done carefully.
expr ::=
    MINUS expr:e
    {: RESULT = new NegateNumericExpr(e); :}
  | expr:a PLUS expr:b
    {: RESULT = new AddNumericExpr(a, b); :}
  | expr:a MINUS expr:b
    {: RESULT = new SubtractNumericExpr(a, b); :}
  | expr:a MULTIPLY expr:b
    {: RESULT = new MultiplyNumericExpr(a, b); :}
  | expr:a DIVIDE expr:b // Only support int-division right now...
    {: RESULT = new DivideNumericExpr(a, b); :}
  | expr:a EXPONENTIATE expr:b // Only support int-exponentiation right now...
    {: RESULT = new ExponentiateNumericExpr(a, b); :}
  | LPAR expr:e RPAR
    {: RESULT = new ParenthesizedExpr(e); :}
  | LOG_PREFIX float:float_base LPAR expr:arg RPAR
    {: RESULT = new LogNumericExpr(arg, float_base); :}
  | LOG_PREFIX integer:int_base LPAR expr:arg RPAR
    {: RESULT = new LogNumericExpr(arg, int_base); :}
  | NUMERIC_BOOL LPAR bool_expr:b RPAR
    {: RESULT = new NumericBoolNumericExpr(b); :}
  | input:i
    {: RESULT = i; :}
  | list:l
    {: RESULT = l; :}
  | list_subscript:l
    {: RESULT = l; :}
  | bool_expr:b
    // TODO(steving) Address this. This action causes type-unsafety in this language...introduces booleans where really
    // there should only be doubles.
    {: RESULT = b; :}
  | term:t
    {: RESULT = t; :}
  ;

input ::=
    INPUT LPAR STRING:prompt RPAR
    {: RESULT = new InputExpr(prompt); :}
  ;

list ::=
    LBRACKET list_initializer_args:args RBRACKET
    {:
       // Notice that we reverse the list before handing it to the ListExpr node because it was collected backwards.
       RESULT = new ListExpr(args.build().reverse());
    :}
  | LBRACKET RBRACKET
    {: RESULT = new ListExpr(); :}
  ;

list_initializer_args ::=
    expr:head COMMA list_initializer_args:tail
    {:
       // Notice that we're building this list in reverse order, just by the order of the parser recursively identifying
       // each expr in the list.
       RESULT = tail.add(head);
    :}
  | expr:e
    {: RESULT = ImmutableList.<Node>builder().add(e); :}
  ;

list_subscript ::=
    // Support arbitrarily repeated subscripting. ListSubscriptExpr node will check that there's the right levels of
    // nesting available for the given number of subscripts in this specific context.
    list_subscript:l LBRACKET expr:e RBRACKET
    {: RESULT = new ListSubscriptExpr(l, e); :}
  | list:l LBRACKET expr:e RBRACKET
    {: RESULT = new ListSubscriptExpr(l, e); :}
  | identifier:i LBRACKET expr:e RBRACKET
    {: RESULT = new ListSubscriptExpr(i, e); :}
  ;

bool_expr ::=
    equality:b
    {: RESULT = b; :}
  | inequality:b
    {: RESULT = b; :}
  | bool_arithmetic:b
    {: RESULT = b; :}
  ;

// This calculator can evaluate an equality check of expressions.
equality ::=
    expr:a EQUALS expr:b
    {: RESULT = new EqualsBoolExpr(a, b); :}
  | expr:a NOT_EQUALS expr:b
    {: RESULT = new NotEqualsBoolExpr(a, b); :}
  ;

if_else_chain_stmt ::=
    if_stmt:leading_if_stmt else_if_stmt_chain:else_if_chain
    {:
       leading_if_stmt.setNextCondition(else_if_chain);
       RESULT = leading_if_stmt;
    :}
  | if_stmt:if_stmt else_stmt:trailing_else_stmt
    {:
       if_stmt.setTerminalElseClause(trailing_else_stmt);
       RESULT = if_stmt;
    :}
  | if_stmt:if_stmt
    {: RESULT = if_stmt; :}
  ;

if_stmt ::=
    IF LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new IfStmt(e, stmt_list); :}
  ;

else_if_stmt_chain ::=
    else_if_stmt:head else_if_stmt_chain:tail
    {:
       head.setNextCondition(tail);
       RESULT = head;
    :}
  | else_if_stmt:else_if_stmt else_stmt:trailing_else_stmt
    {:
       else_if_stmt.setTerminalElseClause(trailing_else_stmt);
       RESULT = else_if_stmt;
    :}
  | else_if_stmt:else_if_stmt
    {: RESULT = else_if_stmt; :}
  ;

else_if_stmt ::=
    ELSE if_stmt:else_if_stmt
    {: RESULT = else_if_stmt; :}
  ;

// We can simply return the StmtListNode itself because this is actually gonna be run by the IfStmt it's associated
// with.
else_stmt ::=
    ELSE LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = stmt_list; :}
  ;

while_stmt ::=
    WHILE LPAR expr:e RPAR LCURLY stmt_list:stmt_list RCURLY
    {: RESULT = new WhileStmt(e, stmt_list); :}
  ;

inequality ::=
    expr:a L_ANGLE_BRACKET expr:b
    {: RESULT = new LessThanBoolExpr(a, b); :}
  | expr:a R_ANGLE_BRACKET expr:b
    {: RESULT = new GreaterThanBoolExpr(a, b); :}
  | expr:a LTE expr:b
    {: RESULT = new LessThanOrEqualToBoolExpr(a, b); :}
  | expr:a GTE expr:b
    {: RESULT = new GreaterThanOrEqualToBoolExpr(a, b); :}
  ;

// TODO(steving) Address this. This action causes type-unsafety in this language...allows doubles where really
// there should only be booleans.
bool_arithmetic ::=
    expr:a AND expr:b
    {: RESULT = new AndBoolExpr(a, b); :}
  | expr:a OR expr:b
    {: RESULT = new OrBoolExpr(a, b); :}
  | NOT expr:a
    {: RESULT = new NotBoolExpr(a); :}
  ;

// The last production 'term' closes the grammar. It's a primitive or identifier.
term ::=
    primitive:p
    {: RESULT = p; :}
  | identifier:i
    {: RESULT = i; :}
  ;

identifier ::=
    IDENTIFIER:identifier
    {: RESULT = new IdentifierReferenceTerm(identifier); :}
  ;

primitive ::=
    float:f
    {: RESULT = f; :}
  | integer:i
    {: RESULT = i; :}
  | STRING:s
    {: RESULT = new StringTerm(s); :}
  | TRUE
    {: RESULT = new TrueTerm(); :}
  | FALSE
    {: RESULT = new FalseTerm(); :}
  ;

float ::=
    FLOAT:f
    {: RESULT = new FloatTerm(f); :}
  ;

integer ::=
    INTEGER:i
    {: RESULT = new IntegerTerm(i); :}
  ;
