syntax = "proto3";

package claro.compiler_backends.java_source.monomorphization.ipc_protos;

import "src/java/com/claro/module_system/module_serialization/proto/claro_types/ClaroTypes.proto";

option java_multiple_files = false;
option java_outer_classname = "IPCMessages";
option java_package = "com.claro.compiler_backends.java_source.monomorphization.proto.ipc_protos";

message MonomorphizationRequest {
  message UserDefinedTypeMetadata {
    claro.module_system.module_serialization.claro_types.UserDefinedType type = 1;
    claro.module_system.module_serialization.claro_types.TypeProto wrapped_type = 2;
    repeated string type_param_names = 3;
  }

  // The name of the generic procedure for which monomorphization is being requested.
  string procedure_name = 1;

  // The ordered list of concrete types the procedure's generic type params are being bound to.
  repeated claro.module_system.module_serialization.claro_types.TypeProto concrete_type_params = 2;

  // In the case that the requested concrete_type_params are user-defined types (in particular if they were defined
  // outside of the dep module's own dep subgraph) then the dep module will not have configuration for the type's
  // wrapped type, or type param names. So, when sending a MonomorphizationRequest, this metadata will be passed along
  // to enable the dep module subprocess to make note before it attempts monomorphization. If the concrete_type_params
  // doesn't contain any user-defined types, then this list will be empty.
  repeated UserDefinedTypeMetadata user_defined_type_concrete_type_params_metadata = 3;
}

message MonomorphizationResponse {
  message Monomorphization {
    MonomorphizationRequest monomorphization_request = 1;
    string monomorphization_codegen = 2;
  }
  message TransitiveDepModuleMonomorphizationRequest {
    string unique_module_name = 1;
    MonomorphizationRequest monomorphization_request = 2;
  }
  // The actual codegen'd Java-source strings for the requested monomorphization as well as any other local, generic
  // procedure monomorphizations that were triggered by monomorphization of the requested procedure (this can happen
  // when a generic procedure calls another generic procedure ad infinitum).
  repeated Monomorphization local_module_monomorphizations = 1;

  // A list of requested monomorphizations from transitive dep modules that the coordinator will need to trigger codegen
  // for. The assumption here is that the codegen in the local_module_monomorphizations field implicitly depends on the
  // monomorphizations represented in this field, so the coordinator must trigger that transitive dep module
  // monomorphization or else the local_module_monomorphization codegen would be invalid.
  // TODO(steving) In order to workaround the versioning issues between the latest and bootstrapping compilers, temporarily
  // TODO(steving)     dropping this field so that I can come back and reuse it with a different signature later.
  //  repeated TransitiveDepModuleMonomorphizationRequest transitive_dep_module_monomorphization_requests = 2;

  // If there's any sort of exception during the actual compilation logic itself, I really need some way to diagnose
  // that in the main coordinator process as debugging the dep module processes is a painful process. So, instead,
  // I'll format an error message here and convey the problem to the coordinator via a proper error field in the
  // MonomorphizationResponse, leaving everything else unset. The coordinator should then check for errors before
  // proceeding.
  string optional_error_message = 3;
}