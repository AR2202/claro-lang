

consumer add<T>(l: mut [T], toAdd: T) {
  $$BEGIN_JAVA
  l.add(toAdd);
  $$END_JAVA
}


function addAll<T>(l: mut [T], toAdd: [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.addAll(toAdd);
  $$END_JAVA
  return res;
}
function addAllFromMut<T>(l: mut [T], toAdd: mut [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.addAll(toAdd);
  $$END_JAVA
  return res;
}


consumer clear<T>(l: mut [T]) {
  $$BEGIN_JAVA
  l.clear();
  $$END_JAVA
}


function contains<T>(l: [T], elem: T) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.contains(elem);
  $$END_JAVA
  return res;
}
function containsInMut<T>(l: mut [T], elem: T) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.contains(elem);
  $$END_JAVA
  return res;
}


function containsAll<T>(l: [T], elems: [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.containsAll(elems);
  $$END_JAVA
  return res;
}
function containsAllFromMut<T>(l: [T], elems: mut [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.containsAll(elems);
  $$END_JAVA
  return res;
}
function containsAllInMut<T>(l: mut [T], elems: [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.containsAll(elems);
  $$END_JAVA
  return res;
}
function containsAllInMutFromMut<T>(l: mut [T], elems: mut [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.containsAll(elems);
  $$END_JAVA
  return res;
}


consumer ensureCapacity<T>(l: mut [T], minCapacity: int) {
  $$BEGIN_JAVA
  l.ensureCapacity(minCapacity);
  $$END_JAVA
}


consumer forEach<T>(l: [T], action: consumer<T>) {
  $$BEGIN_JAVA
  l.forEach(action::apply);
  $$END_JAVA
}
consumer forEachInMut<T>(l: mut [T], action: consumer<T>) {
  $$BEGIN_JAVA
  l.forEach(action::apply);
  $$END_JAVA
}


function indexOf<T>(l: [T], t: T) -> int {
  var res: int;
  $$BEGIN_JAVA
  res = l.indexOf(t);
  $$END_JAVA
  return res;
}
function indexOfInMut<T>(l: mut [T], t: T) -> int {
  var res: int;
  $$BEGIN_JAVA
  res = l.indexOf(t);
  $$END_JAVA
  return res;
}


function insertAllAt<T>(l: mut [T], index: int, elems: [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.addAll(index, elems);
  $$END_JAVA
  return res;
}
function insertAllAtFromMut<T>(l: mut [T], index: int, elems: mut [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.addAll(index, elems);
  $$END_JAVA
  return res;
}


consumer insertAt<T>(l: mut [T], index: int, t: T) {
  $$BEGIN_JAVA
  l.add(index, t);
  $$END_JAVA
}


function isEmpty<T>(l: [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.isEmpty();
  $$END_JAVA
  return res;
}
function isEmptyInMut<T>(l: mut [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.isEmpty();
  $$END_JAVA
  return res;
}


function lastIndexOf<T>(l: [T], t: T) -> int {
  var res: int;
  $$BEGIN_JAVA
  res = l.lastIndexOf(t);
  $$END_JAVA
  return res;
}
function lastIndexOfInMut<T>(l: mut [T], t: T) -> int {
  var res: int;
  $$BEGIN_JAVA
  res = l.lastIndexOf(t);
  $$END_JAVA
  return res;
}


function removeFirst<T>(l: mut [T], t: T) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.remove(t);
  $$END_JAVA
  return res;
}


function removeAt<T>(l: mut [T], index: int) -> T {
  var res: T;
  $$BEGIN_JAVA
  res = l.remove((int) index);
  $$END_JAVA
  return res;
}


function removeAll<T>(l: mut [T], toRemove: [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.removeAll(toRemove);
  $$END_JAVA
  return res;
}
function removeAllFromMut<T>(l: mut [T], toRemove: mut [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.removeAll(toRemove);
  $$END_JAVA
  return res;
}


function removeIf<T>(l: mut [T], pred: function<T -> boolean>) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.removeIf(pred::apply);
  $$END_JAVA
  return res;
}


consumer replaceAll<T>(l: mut [T], operator: function<T -> T>) {
  $$BEGIN_JAVA
  l.replaceAll(operator::apply);
  $$END_JAVA
}


function retainAll<T>(l: mut [T], toRetain: [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.retainAll(toRetain);
  $$END_JAVA
  return res;
}
function retainAllFromMut<T>(l: mut [T], toRetain: mut [T]) -> boolean {
  var res: boolean;
  $$BEGIN_JAVA
  res = l.retainAll(toRetain);
  $$END_JAVA
  return res;
}


consumer sort<T>(l: mut [T], comparator: function<|T, T| -> int>) {
  $$BEGIN_JAVA
  l.sort(comparator::apply);
  $$END_JAVA
}


function subList<T>(l: [T], fromInclusive: int, toExclusive: int) -> [T] {
  var res: [T];
  $$BEGIN_JAVA
  res = new ClaroList((Types.ListType) l.getClaroType(), l.subList(fromInclusive, toExclusive));
  $$END_JAVA
  return res;
}
function subListOfMut<T>(l: mut [T], fromInclusive: int, toExclusive: int) -> mut [T] {
  var res: mut [T];
  $$BEGIN_JAVA
  res = new ClaroList((Types.ListType) l.getClaroType(), l.subList(fromInclusive, toExclusive));
  $$END_JAVA
  return res;
}


consumer trimToSize<T>(l: mut [T]) {
  $$BEGIN_JAVA
  l.trimToSize();
  $$END_JAVA
}


function withInitialCapacity<T>(capacity: int) -> mut [T] {
  var res: mut [T] = mut [];
  # TODO(steving) This implementation is unnecessarily inefficient. I need the ability to use inline-Java but still have
  # TODO(steving)     access to the compile-time type codegen. I want to use the below initialization instead:
  # TODO(steving)       res = new ClaroList(<Java source Claro type of T>, capacity);
  ensureCapacity(res, capacity);
  return res;
}
