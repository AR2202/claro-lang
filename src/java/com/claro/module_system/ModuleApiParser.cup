package com.claro;

import com.claro.intermediate_representation.*;
import com.claro.intermediate_representation.statements.contracts.ContractProcedureSignatureDefinitionStmt;
import com.claro.intermediate_representation.types.BaseType;
import com.claro.intermediate_representation.types.ClaroTypeException;
import com.claro.intermediate_representation.types.SupportsMutableVariant;
import com.claro.intermediate_representation.types.TypeProvider;
import com.claro.intermediate_representation.types.TypeProvider.ImmediateTypeProvider;
import com.claro.intermediate_representation.types.Type;
import com.claro.intermediate_representation.types.Types;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.base.Strings;
import java_cup.runtime.Symbol;
import java.util.Map;
import java.util.Optional;
import java.util.Stack;
import java.util.function.Function;
import java.util.function.Supplier;
import lombok.Data;

action code {:
  private Symbol constructBuiltinType(LexedValue<String> lb, int lbleft, int lbright, Symbol t, LexedValue<String> rb, int rbleft, int rbright, Function<LexedValue<TypeProvider>, TypeProvider> typeProviderConstructor) {
    LexedValue<TypeProvider> tLexedVal = (LexedValue<TypeProvider>) t.value;
    Supplier<String> currentLinesSupplier =
      joinExprLines(new Line(lb.getCurrentInputLine(), lbright), new Line(tLexedVal.getCurrentInputLine(), t.right), new Line(rb.getCurrentInputLine(), rbright));
    int startCol = min(lbleft, t.left, rbleft);
    int endCol = max(lbleft + lb.getLen(), t.left + tLexedVal.getLen(), rbleft + rb.getLen());

    return new Symbol(
      -1,
      startCol,
      endCol, // line number
      LexedValue.create(
        typeProviderConstructor.apply(tLexedVal),
        currentLinesSupplier,
        endCol - startCol)
      );
  }
:}

parser code {:
  public String generatedClassName = "module";  // default to be overridden.
  public String package_string = "";  // default to be overridden.

  public int errorsFound = 0;
  public static Stack<Runnable> errorMessages = new Stack<>();

  @Override
  public void report_error(String message, Object info) {
    errorsFound++;
    Symbol currSymbol = (Symbol) info;
    LexedValue<?> lexedValue = (LexedValue) currSymbol.value;

    errorMessages.push(
      () -> {
        // It's possible that this is just a terminal report from JCUP.
        if (lexedValue == null) {
          return;
        }
        System.err.print(String.format("%s.claro_module_api:%s: ", generatedClassName, currSymbol.right + 1));
        System.err.println("Unexpected token <" + lexedValue.getVal() + ">");
        String currentInputLineString = lexedValue.getCurrentInputLine().get();
        if (Character.isWhitespace(currentInputLineString.charAt(currentInputLineString.length() - 1))) {
          int trailingWhitespaceStart = currentInputLineString.length();
          while (Character.isWhitespace(currentInputLineString.charAt(--trailingWhitespaceStart))); // This is just cute for the sake of it....barf...but I'm keeping it lol.
          System.err.println(currentInputLineString.substring(0, trailingWhitespaceStart + 1));
        } else {
          System.err.println(lexedValue.getCurrentInputLine().get());
        }
        System.err.println(Strings.repeat(" ", currSymbol.left) + '^');
      });
  }

  @Override
  public void syntax_error(Symbol cur_token) {
    this.report_error("Syntax error", cur_token);
  }

  @Data
  static class Line {
    Supplier<String> inputLineSupplier;
    int inputLineNumber;

    Line(StringBuilder inputLine, int inputLineNumber) {
      this(() -> inputLine.toString(), inputLineNumber);
    }

    Line(Symbol s) {
      this(((LexedValue<?>)s.value).getCurrentInputLine(), s.right);
    }

    Line(Supplier<String> inputLineSupplier, int inputLineNumber) {
      this.inputLineSupplier = inputLineSupplier;
      this.inputLineNumber = inputLineNumber;
    }
  }

  private Supplier<String> joinExprLines(Line ... linesToJoin) {
    return () -> {
        StringBuilder res = new StringBuilder(linesToJoin[0].inputLineSupplier.get());
        int prevLineNum = linesToJoin[0].inputLineNumber;
        for (int i = 1; i < linesToJoin.length; i++) {
          Line curr = linesToJoin[i];
          if (curr.inputLineNumber != prevLineNum) {
            prevLineNum = curr.inputLineNumber;
            res.append(curr.inputLineSupplier.get());
          }
        }
        return res.toString();
    };
  }

  private static int min(int ... nums) {
    int currMin = Integer.MAX_VALUE;
    for (int x : nums) {
      currMin = Math.min(x, currMin);
    }
    return currMin;
  }

  private static int max(int ... nums) {
    int currMax = Integer.MIN_VALUE;
    for (int x : nums) {
      currMax = Math.max(x, currMax);
    }
    return currMax;
  }
:}

terminal LexedValue<String>  LPAR, RPAR;
terminal LexedValue<String>  LCURLY, RCURLY, LBRACKET, RBRACKET;
terminal LexedValue<String>  SEMICOLON;
terminal LexedValue<String>  COLON;
terminal LexedValue<String>  COMMA;
terminal LexedValue<String>  BAR;
terminal LexedValue<String>  L_ANGLE_BRACKET, R_ANGLE_BRACKET;
terminal LexedValue<String>  ARROW;
// A variable identifier is just a sequence of chars.
terminal LexedValue<String>  IDENTIFIER;
// Builtin Types
terminal LexedValue<String>  INT_TYPE, FLOAT_TYPE, BOOLEAN_TYPE, STRING_TYPE, TUPLE_TYPE, STRUCT_TYPE,
                 ONEOF, FUNCTION_TYPE, CONSUMER_FUNCTION_TYPE, PROVIDER_FUNCTION_TYPE;
terminal LexedValue<String>  MUT;
terminal LexedValue<String>  FUTURE, BLOCKING, MAYBE_BLOCKING;
terminal LexedValue<String>  HTTP_CLIENT, HTTP_SERVER;

// Declare which type will be returned by each nonterminal grammar production.
nonterminal ModuleNode                         module;
nonterminal Symbol/*ImmutableMap.Builder<String, TypeProvider>*/ function_args_types_list;
nonterminal Symbol/*ImmutableList.Builder<String>*/  identifier_list;
nonterminal ImmutableList<String>              generic_blocking_on;
nonterminal ImmutableList.Builder<String>      identifier_bar_sep_list;
nonterminal TypeProvider                       maybe_blocking_procedure_types;
nonterminal ImmutableMap.Builder<String, TypeProvider> procedure_args_w_generic_blocking;
nonterminal ImmutableList.Builder<ContractProcedureSignatureDefinitionStmt> contract_signature_defs_list;
nonterminal ContractProcedureSignatureDefinitionStmt contract_procedure_signature_definition_stmt;
// Unfortunately IntelliJ is starting to take a dump on this file since it's gotten massive, so it will no longer
// correctly parse this type even though JCup and Java are handling the file like a champ.
nonterminal Symbol/*TypeProvider*/             builtin_type;
nonterminal Symbol/*TypeProvider*/             base_builtin_type_without_mutability_modifier;
nonterminal Symbol/*ImmutableList<TypeProvider>*/  builtin_types_list;
nonterminal Symbol/*ImmutableList.Builder<TypeProvider>*/ backwards_builtin_types_list;

// Lower precedence things at the top, higher precedence things at the bottom.
// ...but also I've basically put no thought whatsoever into the order these ACTUALLY appear in.
precedence right ARROW;
precedence left COMMA;
precedence left IDENTIFIER;
precedence left SEMICOLON;
precedence left COLON;
precedence left L_ANGLE_BRACKET, R_ANGLE_BRACKET;
precedence left LPAR, RPAR, LBRACKET, RBRACKET;

// This is where the grammar starts.
module ::=
    contract_signature_defs_list:exported_procedures
    {:
       RESULT = new ModuleNode(exported_procedures.build().reverse(), generatedClassName, package_string);
    :}
  ;

builtin_type ::=
    base_builtin_type_without_mutability_modifier:base_type
    {: RESULT = base_type; :}
  | MUT:m base_builtin_type_without_mutability_modifier:base_type
    {:
       RESULT = constructBuiltinType(
           m, mleft, mright, base_type, LexedValue.create("", () -> "", 0), base_type.left + ((LexedValue) base_type.value).getLen(), base_type.right,
           tLexedVal -> (TypeProvider) (scopedHeap) -> {
                Type resolvedType = tLexedVal.getVal().resolveType(scopedHeap);
                // Literally all I need to do is manually mark the thing mutable if mutability is supported for this type.
                if (resolvedType instanceof SupportsMutableVariant) {
                  return ((SupportsMutableVariant) resolvedType).toShallowlyMutableVariant();
                } else {
                  // Java is stupid, I hate the concept of checked exceptions. If you're going to give me exceptions,
                  // please make them "just work".
                  throw new RuntimeException(
                    ClaroTypeException.forIllegalMutableTypeAnnotationOnInherentlyImmutableType(resolvedType));
                }
           });
    :}
  ;

base_builtin_type_without_mutability_modifier ::=
    INT_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.INTEGER),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | FLOAT_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.FLOAT),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | BOOLEAN_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.BOOLEAN),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | STRING_TYPE:t
    {:
       RESULT = new Symbol(
          -1,
          tleft,
          tright, // line number
          LexedValue.create(
            (TypeProvider) ImmediateTypeProvider.of(Types.STRING),
            t.getCurrentInputLine(),
            t.getLen())
       );
    :}
  | LBRACKET:lb builtin_type:t RBRACKET:rb
    {:
       RESULT = constructBuiltinType(
           lb, lbleft, lbright, t, rb, rbleft, rbright,
           tLexedVal -> (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.ListType.forValueType(tLexedVal.getVal().resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
           });
    :}
  | LCURLY:lb builtin_type:t RCURLY:rb
    {:
       RESULT = constructBuiltinType(
           lb, lbleft, lbright, t, rb, rbleft, rbright,
           tLexedVal -> (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.SetType.forValueType(tLexedVal.getVal().resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
           });
    :}
  | LCURLY:la builtin_type:key COLON:c builtin_type:value RCURLY:ra
    // Maps are defined like {string:int} to avoid a new keyword `map` since I'd like to not impair functional style,
    // where map is a well known function.
    {:
       LexedValue<TypeProvider> keyLexedVal = (LexedValue<TypeProvider>) key.value;
       LexedValue<TypeProvider> valueLexedVal = (LexedValue<TypeProvider>) value.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(la.getCurrentInputLine(), laright), new Line(keyLexedVal.getCurrentInputLine(), key.right), new Line(c.getCurrentInputLine(), cright), new Line(valueLexedVal.getCurrentInputLine(), value.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(laleft, key.left, cleft, value.left, raleft);
       int endCol = max(laleft + la.getLen(), key.left + keyLexedVal.getLen(), cleft + c.getLen(), value.left + valueLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> {
                boolean impossibleRecursionAlreadyFoundOnLevel =
                    scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                Type resolvedType = Types.MapType.forKeyValueTypes(keyLexedVal.getVal().resolveType(scopedHeap), valueLexedVal.getVal().resolveType(scopedHeap));
                // Recursive aliases are allowed to be defined within this type since it has an implicit "bottom". But
                // it doesn't matter if we've already found impossible, unresolved recursion on this level.
                if (!impossibleRecursionAlreadyFoundOnLevel && scopedHeap.isIdentifierDeclared("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND")) {
                  scopedHeap.deleteIdentifierValue("$POTENTIAL_IMPOSSIBLE_SELF_REFERENCING_TYPE_FOUND");
                }
                return resolvedType;
              },
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | ONEOF:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg_types.left + argTypesLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.OneofType.forVariantTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argLexedVal.getCurrentInputLine(), arg.right), new Line(a.getCurrentInputLine(), aright), new Line(outputTypeLexedVal.getCurrentInputLine(), output_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg.left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg.left + argLexedVal.getLen(), aleft + a.getLen(), output_type.left + outputTypeLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.getVal().resolveType(scopedHeap)), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(b1.getCurrentInputLine(), b1right), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(b2.getCurrentInputLine(), b2right), new Line(a.getCurrentInputLine(), aright), new Line(outputTypeLexedVal.getCurrentInputLine(), output_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, b1left, arg_types.left, b2left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), b1left + b1.getLen(), arg_types.left + argTypesLexedVal.getLen(), b2left + b2.getLen(), aleft + a.getLen(), output_type.left + outputTypeLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argLexedVal.getCurrentInputLine(), arg.right), new Line(a.getCurrentInputLine(), aright), new Line(outputTypeLexedVal.getCurrentInputLine(), output_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg.left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg.left + argLexedVal.getLen(), aleft + a.getLen(), output_type.left + outputTypeLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.getVal().resolveType(scopedHeap)), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(b1.getCurrentInputLine(), b1right), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(b2.getCurrentInputLine(), b2right), new Line(a.getCurrentInputLine(), aright), new Line(outputTypeLexedVal.getCurrentInputLine(), output_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, b1left, arg_types.left, b2left, aleft, output_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), b1left + b1.getLen(), arg_types.left + argTypesLexedVal.getLen(), b2left + b2.getLen(), aleft + a.getLen(), output_type.left + outputTypeLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg_types.left + argTypesLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg_types.left + argTypesLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | PROVIDER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:return_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> returnTypeProvider = (LexedValue<TypeProvider>) return_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(returnTypeProvider.getCurrentInputLine(), return_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, return_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), return_type.left + returnTypeProvider.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(returnTypeProvider.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/false),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | BLOCKING PROVIDER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:return_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> returnTypeProvider = (LexedValue<TypeProvider>) return_type.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(returnTypeProvider.getCurrentInputLine(), return_type.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, return_type.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), return_type.left + returnTypeProvider.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(returnTypeProvider.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/true),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | TUPLE_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(t.getCurrentInputLine(), tright), new Line(la.getCurrentInputLine(), laright), new Line(argTypesLexedVal.getCurrentInputLine(), arg_types.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(tleft, laleft, arg_types.left, raleft);
       int endCol = max(tleft + t.getLen(), laleft + la.getLen(), arg_types.left + argTypesLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.TupleType.forValueTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | FUTURE:f L_ANGLE_BRACKET:la builtin_type:wrapped R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> wrappedTypeProvider = (LexedValue<TypeProvider>) wrapped.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(f.getCurrentInputLine(), fright), new Line(la.getCurrentInputLine(), laright), new Line(wrappedTypeProvider.getCurrentInputLine(), wrapped.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(fleft, laleft, wrapped.left, raleft);
       int endCol = max(fleft + f.getLen(), laleft + la.getLen(), wrapped.left + wrappedTypeProvider.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.FutureType.wrapping(wrappedTypeProvider.getVal().resolveType(scopedHeap)),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:type_name
    {:
       RESULT = new Symbol(
          -1,
          type_nameleft,
          type_nameright, // line number
          LexedValue.create(
            TypeProvider.Util.getTypeByName(type_name.getVal(), /*isTypeDefinition=*/true),
            type_name.getCurrentInputLine(),
            type_name.getLen())
       );
    :}
  | IDENTIFIER:type_name L_ANGLE_BRACKET:la builtin_types_list:concrete_type_params R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> concreteTypeParamsLexedVal = (LexedValue<ImmutableList<TypeProvider>>) concrete_type_params.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(type_name.getCurrentInputLine(), type_nameright), new Line(la.getCurrentInputLine(), laright), new Line(concreteTypeParamsLexedVal.getCurrentInputLine(), concrete_type_params.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(type_nameleft, laleft, concrete_type_params.left, raleft);
       int endCol = max(type_nameleft + type_name.getLen(), laleft + la.getLen(), concrete_type_params.left + concreteTypeParamsLexedVal.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> Types.UserDefinedType.forTypeNameAndParameterizedTypes(
              type_name.getVal(),
              concreteTypeParamsLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList())
            ),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | STRUCT_TYPE:s LCURLY:la function_args_types_list:fields RCURLY:ra
    // Structs are defined like `struct{field1: int, ..., fieldN: string}`. This is intended to resemble a sequence of
    // variable declarations, which will align with the initialization syntax `{field1 = 1, ..., fieldN = "foo"}` which
    // in turn is intended to resemble a sequence of variable initializations. I appreciate the metaphore of a struct as
    // a bundle of variables.
    {:
      ImmutableList<Map.Entry<String, TypeProvider>> fieldTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) fields.value).getVal().build().entrySet().asList().reverse();
      ImmutableMap<String, TypeProvider> fieldTypesMap =
          ImmutableMap.<String, TypeProvider>builderWithExpectedSize(fieldTypesList.size()).putAll(fieldTypesList).build();
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(s.getCurrentInputLine(), sright), new Line(la.getCurrentInputLine(), laright), new Line(((LexedValue) fields.value).getCurrentInputLine(), fields.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(sleft, laleft, fields.left, raleft);
       int endCol = max(sleft + s.getLen(), laleft + la.getLen(), fields.left + ((LexedValue) fields.value).getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) ->
              Types.StructType.forFieldTypes(
                fieldTypesMap.keySet().asList(),
                fieldTypesMap.values().stream()
                  .map(tp -> tp.resolveType(scopedHeap))
                  .collect(ImmutableList.toImmutableList()),
                /*isMutable=*/false
              ),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | HTTP_CLIENT:h L_ANGLE_BRACKET:la builtin_type:http_service R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> httpServiceLex = (LexedValue<TypeProvider>)http_service.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(h.getCurrentInputLine(), hright), new Line(la.getCurrentInputLine(), laright), new Line(httpServiceLex.getCurrentInputLine(), http_serviceright), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(hleft, laleft, http_serviceleft, raleft);
       int endCol = max(hleft + h.getLen(), laleft + la.getLen(), http_serviceleft + httpServiceLex.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> {
              // First things first, I need to actually do some type validation that this type has been correctly
              // parameterized with an HttpService and not some arbitrary type.
              Type resolvedHttpServiceType = httpServiceLex.getVal().resolveType(scopedHeap);
              if (!resolvedHttpServiceType.baseType().equals(BaseType.HTTP_SERVICE)) {
                throw new RuntimeException(
                  ClaroTypeException.forIllegalHttpClientTypeWithNonHttpServiceParameterizedType(resolvedHttpServiceType)
                );
              }
              return Types.HttpClientType.forServiceName(((Types.HttpServiceType) resolvedHttpServiceType).getServiceName());
            },
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | HTTP_SERVER:f L_ANGLE_BRACKET:la builtin_type:wrapped R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> wrappedTypeProvider = (LexedValue<TypeProvider>) wrapped.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(f.getCurrentInputLine(), fright), new Line(la.getCurrentInputLine(), laright), new Line(wrappedTypeProvider.getCurrentInputLine(), wrapped.right), new Line(ra.getCurrentInputLine(), raright));
       int startCol = min(fleft, laleft, wrapped.left, raleft);
       int endCol = max(fleft + f.getLen(), laleft + la.getLen(), wrapped.left + wrappedTypeProvider.getLen(), raleft + ra.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          endCol, // line number
          LexedValue.create(
            (TypeProvider) (scopedHeap) -> {
              Type resolvedHttpServiceType = wrappedTypeProvider.getVal().resolveType(scopedHeap);
              if (!resolvedHttpServiceType.baseType().equals(BaseType.HTTP_SERVICE)) {
                throw new RuntimeException(
                  ClaroTypeException.forIllegalHttpServerTypeWithNonHttpServiceParameterizedType(resolvedHttpServiceType)
                );
              }
              return Types.HttpServerType.forHttpService(resolvedHttpServiceType);
            },
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

builtin_types_list ::=
    backwards_builtin_types_list:b
    {:
       LexedValue<ImmutableList.Builder<TypeProvider>> bLexedValue = (LexedValue<ImmutableList.Builder<TypeProvider>>) b.value;
       RESULT = new Symbol(
          -1,
          b.left,
          b.right, // line number
          LexedValue.create(
            bLexedValue.getVal().build().reverse(),
            bLexedValue.getCurrentInputLine(),
            bLexedValue.getLen())
       );
    :}
  ;

backwards_builtin_types_list ::=
    builtin_type:t COMMA:c backwards_builtin_types_list:tail
    {:
       LexedValue<TypeProvider> tLexedVal = (LexedValue<TypeProvider>)t.value;
       LexedValue<ImmutableList.Builder<TypeProvider>> tailLexedVal = (LexedValue<ImmutableList.Builder<TypeProvider>>)tail.value;
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(tLexedVal.getCurrentInputLine(), t.right), new Line(c.getCurrentInputLine(), cright), new Line(tailLexedVal.getCurrentInputLine(), tail.right));
       int startCol = min(t.left, cleft, tail.left);
       int endCol = max(t.left + tLexedVal.getLen(), cleft + c.getLen(), tail.left + tailLexedVal.getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          LexedValue.create(
            tailLexedVal.getVal().add(tLexedVal.getVal()),
            currentLinesSupplier,
            tailLexedVal.getLen())
       );
    :}
  | builtin_type:t
    {:
       RESULT = new Symbol(
          -1,
          t.left,
          t.right, // line number
          LexedValue.create(
            ImmutableList.<TypeProvider>builder().add(((LexedValue<TypeProvider>) t.value).getVal()),
            ((LexedValue)t.value).getCurrentInputLine(),
            ((LexedValue)t.value).getLen())
       );
    :}
  ;

generic_blocking_on ::=
    BLOCKING COLON identifier_bar_sep_list:i
    {:
      RESULT = i.build().reverse();
    :}
  ;

identifier_bar_sep_list ::=
    IDENTIFIER:i BAR identifier_bar_sep_list:b
    {:
      RESULT = b.add(i.getVal());
    :}
  | IDENTIFIER:i
    {:
      RESULT = ImmutableList.<String>builder().add(i.getVal());
    :}
  ;

maybe_blocking_procedure_types ::=
    MAYBE_BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_type:arg ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> argLexedVal = (LexedValue<TypeProvider>) arg.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(ImmutableList.of(argLexedVal.getVal().resolveType(scopedHeap)), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING FUNCTION_TYPE:t L_ANGLE_BRACKET:la BAR:b1 builtin_types_list:arg_types BAR:b2 ARROW:a builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.FunctionType.typeLiteralForArgsAndReturnTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING CONSUMER_FUNCTION_TYPE:t L_ANGLE_BRACKET:la builtin_types_list:arg_types R_ANGLE_BRACKET:ra
    {:
       LexedValue<ImmutableList<TypeProvider>> argTypesLexedVal = (LexedValue<ImmutableList<TypeProvider>>) arg_types.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.ConsumerType.typeLiteralForConsumerArgTypes(argTypesLexedVal.getVal().stream().map(tp -> tp.resolveType(scopedHeap)).collect(ImmutableList.toImmutableList()), /*explicitlyAnnotatedBlocking=*/null);
    :}
  | MAYBE_BLOCKING PROVIDER_FUNCTION_TYPE:p L_ANGLE_BRACKET:la builtin_type:output_type R_ANGLE_BRACKET:ra
    {:
       LexedValue<TypeProvider> outputTypeLexedVal = (LexedValue<TypeProvider>) output_type.value;

       RESULT = (TypeProvider) (scopedHeap) -> Types.ProcedureType.ProviderType.typeLiteralForReturnType(outputTypeLexedVal.getVal().resolveType(scopedHeap), /*explicitlyAnnotatedBlocking=*/null);
    :}
  ;

identifier_list ::=
    IDENTIFIER:arg_name COMMA:c identifier_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue)tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(arg_nameleft, cleft);
       int endCol = max(arg_nameleft + arg_name.getLen(), cleft + c.getLen());
       RESULT = new Symbol(
          -1,
          startCol,
          tail.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableList.Builder<String>>)tail.value).getVal().add(arg_name.getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name
    {:
       RESULT = new Symbol(
          -1,
          arg_nameleft,
          arg_nameright, // line number
          LexedValue.create(
            ImmutableList.<String>builder().add(arg_name.getVal()),
            arg_name.getCurrentInputLine(),
            arg_name.getLen())
       );
    :}
  ;

// TODO(steving) Be less lazy and don't bother using a Map where we should just be using a List of pairs....but Java is so garbage it doesn't have tuples so.....
// Note that we're again building this up backwards for convenience (remember that all guava collections respect ordering).
function_args_types_list ::=
    IDENTIFIER:arg_name COLON:colon builtin_type:t COMMA:comma function_args_types_list:tail
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(colon.getCurrentInputLine(), colonright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right), new Line(comma.getCurrentInputLine(), commaright), new Line(((LexedValue) tail.value).getCurrentInputLine(), tail.right));
       int startCol = min(arg_nameleft, colonleft, t.left, commaleft, tail.left);
       int endCol = max(arg_nameleft + arg_name.getLen(), colonleft + colon.getLen(), t.left + ((LexedValue) t.value).getLen(), commaleft + comma.getLen(), tail.left + ((LexedValue) tail.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) tail.value).getVal().put(arg_name.getVal(), ((LexedValue<TypeProvider>) t.value).getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  | IDENTIFIER:arg_name COLON:c builtin_type:t
    {:
       Supplier<String> currentLinesSupplier =
          joinExprLines(new Line(arg_name.getCurrentInputLine(), arg_nameright), new Line(c.getCurrentInputLine(), cright), new Line(((LexedValue) t.value).getCurrentInputLine(), t.right));
       int startCol = min(arg_nameleft, cleft, t.left);
       int endCol = max(arg_nameleft + arg_name.getLen(), cleft + c.getLen(), t.left + ((LexedValue) t.value).getLen());

       RESULT = new Symbol(
          -1,
          startCol,
          t.right, // line number
          LexedValue.create(
            ImmutableMap.<String, TypeProvider>builder().put(arg_name.getVal(), ((LexedValue<TypeProvider>) t.value).getVal()),
            currentLinesSupplier,
            endCol - startCol)
       );
    :}
  ;

procedure_args_w_generic_blocking ::=
    IDENTIFIER:arg_name COLON maybe_blocking_procedure_types:maybe_blocking_proc COMMA procedure_args_w_generic_blocking:args_w_generic_blocking
    {:
      RESULT = args_w_generic_blocking.put(arg_name.getVal(), maybe_blocking_proc);
    :}
  | IDENTIFIER:arg_name COLON builtin_type:t COMMA procedure_args_w_generic_blocking:args_w_generic_blocking
    {:
      RESULT = args_w_generic_blocking.put(arg_name.getVal(), ((LexedValue<TypeProvider>) t.value).getVal());
    :}
  | IDENTIFIER:arg_name COLON maybe_blocking_procedure_types:maybe_blocking_proc
    {:
      RESULT = ImmutableMap.<String, TypeProvider>builder().put(arg_name.getVal(), maybe_blocking_proc);
    :}
  | IDENTIFIER:arg_name COLON builtin_type:t
    {:
      RESULT = ImmutableMap.<String, TypeProvider>builder().put(arg_name.getVal(), ((LexedValue<TypeProvider>) t.value).getVal());
    :}
  ;

contract_signature_defs_list ::=
    contract_procedure_signature_definition_stmt:signature contract_signature_defs_list:tail
    {:
      RESULT = tail.add(signature);
    :}
  | contract_procedure_signature_definition_stmt:signature
    {:
      RESULT = ImmutableList.<ContractProcedureSignatureDefinitionStmt>builder().add(signature);
    :}
  ;

contract_procedure_signature_definition_stmt ::=
   // FUNCTIONS
   FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), Optional.of(genericTypesList));
   :}
 | BLOCKING FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.of(genericTypesList));
   :}
 | generic_blocking_on:generic_blocking_on FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), Optional.of(genericTypesList));
   :}

   // CONSUMERS
 | CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR function_args_types_list:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = ((LexedValue<ImmutableMap.Builder<String, TypeProvider>>) backwards_arg_types.value).getVal().build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), Optional.of(genericTypesList));
   :}
 | BLOCKING CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.of(genericTypesList));
   :}
 | generic_blocking_on:generic_blocking_on CONSUMER_FUNCTION_TYPE IDENTIFIER:name L_ANGLE_BRACKET identifier_list:generic_types R_ANGLE_BRACKET LPAR procedure_args_w_generic_blocking:backwards_arg_types RPAR SEMICOLON
   {:
     ImmutableList<Map.Entry<String, TypeProvider>> argTypesList = backwards_arg_types.build().entrySet().asList().reverse();
     ImmutableMap<String, TypeProvider> argTypesMap =
         ImmutableMap.<String, TypeProvider>builderWithExpectedSize(argTypesList.size()).putAll(argTypesList).build();
      ImmutableList<String> genericTypesList =
        ((LexedValue<ImmutableList.Builder<String>>)generic_types.value).getVal().build().reverse();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.of(argTypesMap), Optional.empty(), /*explicitlyAnnotatedBlocking=*/null, /*genericBlockingOn=*/ Optional.of(generic_blocking_on), Optional.of(genericTypesList));
   :}

   // PROVIDERS
 | PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.empty(), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/false, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
 | BLOCKING PROVIDER_FUNCTION_TYPE IDENTIFIER:name LPAR RPAR ARROW builtin_type:output_type SEMICOLON
   {:
     TypeProvider outputTypeProvider = ((LexedValue<TypeProvider>) output_type.value).getVal();
     RESULT = new ContractProcedureSignatureDefinitionStmt(name.getVal(), Optional.empty(), Optional.of(outputTypeProvider), /*explicitlyAnnotatedBlocking=*/true, /*genericBlockingOn=*/ Optional.empty(), /*optionalGenericTypesList=*/ Optional.empty());
   :}
  ;
