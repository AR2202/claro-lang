# TODO(steving) Notice to anyone reading this file before Claro's First-Class Module System is fully functional:
# TODO(steving)   It's a known problem that currently the lack of namespacing with so many source files scattered around
# TODO(steving)   has resulted in it being hard to trace the implementation of procedures coming from other .claro files.
# TODO(steving)   For now this state of things is somewhat intentional as this is being used as a motivating example
# TODO(steving)   for fleshing out the module system to fully compose this service out of Modules.

HttpService MyDemoService {
  gamePage: "/",
  startNewGame: "/startNewGame",
  joinGame: "/game/{gameId}/join/{handle}",
  gameMove: "/game/{gameId}/player/{secret}/{dir}",
  getBestMoves: "/game/{gameId}/player/{secret}/getBestMoves",
  resetGame: "/game/{gameId}/player/{secret}/reset"
}

########################################################################################################################
# For each HttpService definition, Claro you may either generate a client to communicate with a remote server, OR
# declare an `endpoint_handlers` block for the service in order to be able to generate a server that implements the
# service. This is the key power of the language's server definitions as each endpoint handler is statically *REQUIRED*
# to be implemented in a non-blocking manner to fully leverage 100% of Claro's extremely efficient multithreaded
# concurrency model.
########################################################################################################################

endpoint_handlers MyDemoService {
  graph provider gamePage() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- gamePageHandler();
  }

  graph provider startNewGame() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForJson(@formattedJson);
    node formattedJson <- startNewGameHandler("Jason");
  }

  graph function joinGame(gameId: string, handle: string) -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- handleBuggyResponseAsHtmlStrParts(@joinResponse)[0];
    node joinResponse <- friendsJoin(
      cast(HttpClient<BuggyBuggies>, getHttpClient("https://buggy-buggies.gigalixirapp.com")),
      gameId,
      handle
    );
  }

  graph function gameMove(gameId: string, playerSecret: string, dir: string) -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- gameMoveHandler(gameId, playerSecret, @dirsMap[dir]);
    node dirsMap <- {"up": "N", "down": "S", "right": "E", "left": "W"};
  }

  graph function getBestMoves(gameId: string, playerSecret: string) -> future<HttpResponse> {
    root res <- getOk200HttpResponseForJson(@formattedJson);
    node formattedJson <- getBestMovesHandler(@parsedWorld);
    # TODO(steving) Figure out how to use just a singleton client.
    node parsedWorld <- worldInfo(
      cast(HttpClient<BuggyBuggies>, getHttpClient("https://buggy-buggies.gigalixirapp.com")),
      gameId,
      playerSecret
    );
  }

  graph function resetGame(gameId: string, playerSecret: string) -> future<HttpResponse> {
    root res <- getOk200HttpResponseForJson(@formattedJson);
    node formattedJson <- handleBuggyResponseAsHtmlStrParts(@resetResponse)[0];
    node resetResponse <- reset(
      cast(HttpClient<BuggyBuggies>, getHttpClient("https://buggy-buggies.gigalixirapp.com")),
      gameId,
      playerSecret
    );
  }
}

########################################################################################################################
# The builtin function `getBasicHttpServerForPort()` has the following signature:
#     function getBasicHttpServerForPort<T>(port: int) -> HttpServer<T>;
#
# As you can tell by the lack of a requires clause, this particular contract definition does rely on compiler magic that
# you couldn't directly implement in user-space in Claro in order to enforce the requirement that each concrete `T` is
# actually an HttpService. To achieve exactly this outside of the compiler, you'd need to actually do some codegen
# yourself to dynamically generate a contract definition. Claro won't support macros so this would be done at the Bazel
# genrule level. Instead, Claro provides this powerful building block out of the box!
#
# TODO(steving) This obviously needs to be presented as part of the stdlib in a module such as `HttpServers` so that the
# TODO(steving)   function must be called as `HttpServers::getBasicHttpServerForPort()` instead of as a top-level function.
########################################################################################################################

var myDemoServer: HttpServer<MyDemoService> = getBasicHttpServerForPort(8080);
startServerAndAwaitShutdown(myDemoServer);


