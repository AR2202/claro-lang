# Lambda Expr syntax does not carry type annotations, so their type signature must either be constrained by
# its surrounding context, OR explicitly annotated.
var firstLambda: function<string -> string> = x -> x;
print(firstLambda("Claro supports lambdas!"));

# You may alternatively cast the type of the lambda expression (which is used as a static type hint and does
# not result in a runtime type cast).
var secondLambda = (function<string -> string>) x -> x;
print(secondLambda("And they're really easy to work with!"));


consumer testPassingLambdasAsArgs(x: int, f: function<int -> int>) {
  print(f(x));
}

testPassingLambdasAsArgs(
  900,
  x -> 2 * x);


function foo(x: int, f: function<int -> int>) -> int {
  return f(x);
}

print(foo(2, y -> -5 * y) + foo(10, x -> 10 * x));
print(foo(2, y -> -5 * y));
print(foo(10, x -> 10 * x));


# Lambdas can capture state defined before them.
var i = "hello";
print(
  foo(
    111,
    z -> {
      print(i);
      # And you can even recursively use lambdas w/in lambdas.
      testPassingLambdasAsArgs(100000, x -> x);
      return z;
    }
  )
);

provider testProcedureCanReturnLambda() -> function<int -> int> {
#  var f: function<int -> int> = x -> x;
#  return f;
  return x -> x;
}

var returnedLambda = testProcedureCanReturnLambda();
print(returnedLambda(8));

# Lambdas can be defined within procedure bodies as well.
function testLambdasWithinProcedureBodies(x: int) -> string {
  testPassingLambdasAsArgs(x, arg1 -> 100 * arg1);
  return "returns work even after lambda return";
}
print(testLambdasWithinProcedureBodies(23));


# This shows the power of lambdas in Claro. You can even now define your own partial application function.
function partial(first: int, f: function<|int, int| -> int>) -> function<int -> int> {
  return second -> {
    # This variable is here just to show off that Claro supports multi-line lambdas too!
    var res = f(first, second);
    return res;
  };
}

var add10 = partial(10, lambda (first, second) -> {return first + second;});
print(add10(20));  # 30
print(add10(30));  # 40

# Type Aliases make type declarations like this one easier to read.
alias IntFunction : function<int -> int>
alias IntBiFunction : function<|int, int| -> int>
var partialLambda: function<|int, IntBiFunction| -> IntFunction> =
  lambda (first, l) -> second -> l(first, second);
type(partialLambda);  # function<|int, function<|int, int| -> int>| -> function<int -> int>>

var add10Partial = partialLambda(10, lambda (first, second) -> first + second);
print(add10Partial(100));  # 110

# Lambda Provider Functions are supported.
var testP: provider<string> = () -> "yay!"; # This would be much more useful if it was taking user input...
# Lambda Consumer Functions are supported as well.
var testC: consumer<string> = s -> { print(testP); print(s); };
testC(testP());

# Probably the most important characteristic of Lambdas is their scope "Capturing" semantics.
# The below example shows that lambdas are able to reference variables that are initialized in outer
# scopes, but they "Capture" the current value of that variable, rather than a true "Closure" over
# that variable. I'd argue that a true "Closure" where the variable itself travels with the lambda
# would do nothing but lead to ErrorProne code. Instead, "Captured Variables" are better thought of
# as variables implicitly passed as constructor arguments to the underlying Lambda object (take this
# as your reminder that Lambdas are objects if you've forgotten that).

var testOuterScopeVar = -1;
var p: provider<int> = () -> {return testOuterScopeVar;};
testOuterScopeVar = 99;
print(p());
provider testOuterScopeInFunction() -> provider<int> {
  var testFunctionOuterScopeVar = 1;
  # Lambdas are able to capture values defined in outer function scopes as well.
  var p: provider<int> = () -> 99 + testFunctionOuterScopeVar;
  # Unlike java, you can keep using variables as usual even after their values were captured in a lambda.
  # This has no effect on the value that was captured in the lambda body.
  testFunctionOuterScopeVar++;
  print(testFunctionOuterScopeVar);
  return p;
}
p = testOuterScopeInFunction();
print(p());
print(testOuterScopeVar);

# Captured variables are mutable state across calls to the lambda, so this allows the creation of your
# own "Generators" (ala Python) without needing to add yet more syntax to the language.
var xxx = 10;
var lll: provider<int> = () -> {
  if (xxx > 0) {
    --xxx;
  }
  return xxx;
};
var lllcurr = lll();
while (lllcurr > 0) {
  print(lllcurr);
  lllcurr = lll();
}
print("done");
print(xxx);