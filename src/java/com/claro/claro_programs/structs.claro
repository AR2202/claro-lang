print("We're gonna build a struct!");

struct FirstStruct {
  field1: int,
  field2: string
}

#var firstStructBuilder = FirstStruct.builder().field1(99).field2("ninety-nine");
# For some reason the above line works but this explicit type def line still doesn't.
var firstStructBuilder: builder<FirstStruct> = FirstStruct.builder().field1(99).field2("ninety-nine");
type(firstStructBuilder);
print(firstStructBuilder);

immutable struct FirstImmutableStruct {
  i: int,
  s: string
}

var firstImmutableStructBuilder = FirstImmutableStruct.builder().i(-999).s("negative nine-hundred-ninety-nine");
type(firstImmutableStructBuilder);
print(firstImmutableStructBuilder);

var firstBuiltImmutableStruct = FirstImmutableStruct.builder().i(27).s("age").build();
type(firstBuiltImmutableStruct);
print(firstBuiltImmutableStruct);

# Anonymous struct definition. This will actually only be accepted in places where type declarations are found.
# E.g. function Foo(i: int) -> {output_i: int, output_s: string} { ... }
{field1: int, field2: string}


# Structs can reference each other.
# And the definitions can come in ANY ORDER IN THE FILE thanks to multi-phase parsing!!!
struct Bar{
  foo: Foo
}
struct Foo{
  i: int,
  s: string
}
var b: Bar = Bar.builder().foo(Foo.builder().i(9).s("nine").build()).build();
print(b);


# Functions can be parameterized by, and return StructTypes.
function getBar(f: Foo) -> builder<Bar> {
  return Bar.builder().foo(f);
}
print(getBar(Foo.builder().i(-9).s("negative-nine").build()));
