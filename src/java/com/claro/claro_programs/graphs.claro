# Compute ((3x+1)(x^2 - y))/(x^2) concurrently....which is super ridiculous but demonstrates a point:
#
#
#   times3:(3 * x)                        squared:(x ^ 2)
#       \                                      /      \
#        v                                    v       |
#     plus1:(1 + @times3)    minusY:(@squared - y)    /
#           \                         /              /
#            v                       v              /
#           multiply:(@plus1 * @minusY)            /
#                            \                    /
#                             v                  v
#                         divide:(@multiply / @squared)
#                                     |
#                                     v
#                                   result
# TODO(steving) 1. Validate that the blocking unwrap operator is never used within the call stack of a graph function.
# TODO(steving)    I can use the same approach as I used for accumulating transitive keys across function calls.
# TODO(steving) 2. Support Graph Functions in the Interpreted backend.
# TODO(steving) 3. Support Consumer/Provider Graph Functions.
# TODO(steving) 4. Try modelling the builtin `input()` function as an async function to queue up interactions with the
# TODO(steving)    console so that graph functions can naturally make use of user input without different threads
# TODO(steving)    stepping all over each other. It also seems more naturally correct for input() to be explicitly
# TODO(steving)    modelled this way anyways since you are consciously waiting on the user for something.
# TODO(steving) 5. If you're able to model builtin `input()` as an async function, then consider extending this logic
# TODO(steving)    a generalized notion of a "SynchronizingResource" so that writes to a shared resource e.g. stdout via
# TODO(steving)    the builtin `print()` and any other following operations are guaranteed to happen as a logical
# TODO(steving)    synchronized unit. This would basically involve keeping a queue of futures to chain off of one
# TODO(steving)    another, where each new call into the SynchronizingResource is applied as a new future chained onto
# TODO(steving)    the last future. Then subsequent calls into the SynchronizingResource would be chained onto the new
# TODO(steving)    last future. All operations must either be a synchronized read, or a synchronized read and write, so
# TODO(steving)    operations passed to mutate should be a lambda of type function<UnwrappedType, UnwrappedType>. Going
# TODO(steving)    based on Java names for this thing, SynchronizedResource == Atomic* except in Claro this is non-blocking.
graph function firstGraph(x: float, y: float) -> future<float> {

  root result <- @multiply / @squared;

  node multiply <- @plus1 * @minusY;

  node plus1 <- 1 + @times3;

  node minusY <- @squared - y;

  node times3 <- 3 * x;

  node squared <- x * x;
}

# The token <-| is referred to as the "(blocking) unwrap operator". I'm very intentionally not allowing more concise
# ways to unwrap a future (for example w/o a declaration to a variable) because I want blocking to be extremely
# apparent and I don't ever want it to be overlooked as blocking threads can frequently be a bad idea.
var firstConcurrentClaroResult <-| firstGraph(10.0, 2.0);
print(firstConcurrentClaroResult);



graph function nTimesRecursively(n: int, x: int, y: int) -> future<int> {
  root result <- 1 + @next1;

  node next1 <- maybeRecurse(n - 1 > 0, n, x, y);
}

using(immediateFuture: function<int -> future<int>>)
function maybeRecurse(b: boolean, n: int, x: int, y: int) -> future<int> {
  if (b) {
    return nTimesRecursively(n - 1, x, y);
  }
  return immediateFuture(0);
}

# TODO(steving) There's got to be an easier way to simply construct an immediate future. Try handling this the way we're
# TODO(steving) already planning to handle implicit auto-wrapping to optional<...> in function returns.
graph function getIntFuture(x: int) -> future<int> {
  root res <- @identity;
  node identity <- x;
}

module ImmediateFutureModule {
  bind immediateFuture:function<int -> future<int>> to getIntFuture;
}

using(ImmediateFutureModule) {
  var n = 200;
  var recursiveRes <-| nTimesRecursively(n, 10, 2);
  print(recursiveRes);
  print(recursiveRes == n);
}

