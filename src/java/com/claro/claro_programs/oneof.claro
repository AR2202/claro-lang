###############################################################################################
# DEMONSTRATE BASIC ONEOF USE
#
# Claro's `oneof` is more of a "meta"-type than a proper type. The below variable is defined
# as a `oneof<string, int>` which means that, at any given point in the program, it may be
# referencing a value of one of the listed types. In this case, it may be referencing either
# a string or an int.
###############################################################################################
var firstOneof: oneof<string, int>;

firstOneof = 1;
print(firstOneof);
firstOneof = "one";
print(firstOneof);
type(firstOneof);

var secondOneof: oneof<int, string>;
secondOneof = 2;
print(secondOneof);
secondOneof = "two";
print(secondOneof);
type(secondOneof);

print("Oneof's are mutually assignable even if their variant types are listed in different orders:");
print("oneof<string, int> == oneof<int, string>");
firstOneof = secondOneof;
print(firstOneof);

print("Oneof's over different variant types are not mutually assignable:");
print("oneof<string, int> != oneof<int, string, float>");
var thirdOneof: oneof<int, string, float> = 1.2;
print(thirdOneof);
type(thirdOneof);

# Uncomment below line for compile error that `oneof<int, string, float>` isn't compatible with `oneof<string, int>`.
#firstOneof = thirdOneof;
#thirdOneof = firstOneof;

###############################################################################################
# DEMONSTRATE USING ONEOF'S IN COLLECTIONS
###############################################################################################

var l: [oneof<string, int>] = [firstOneof];
print(l);
l[0] = 1;
print(l);

append(l, 3);
append(l, "five");
append(l, 7);
append(l, "nine");
print(l); # [1, 3, five, 7, nine]

var lv = l[0];
print(lv);
type(lv);
lv = l[2];
print(lv);
type(lv);

append(l, lv);
print(l);

var l2: [oneof<[int], [string]>] = [];
print(l2);
append(l2, [1,2]);
append(l2, ["three", "four"]);
print(l2);


###############################################################################################
# DEMONSTRATE TYPE "NARROWING" BY EQUALITY CHECKING A ONEOF'S VALUE.
###############################################################################################

var intOrString: oneof<int, string> = 1;

if (intOrString == "one") {
  print("NOPE!");
  var e = intOrString[2];
  print("But we have successfully narrowed the typ{e} and can treat as a string!");
} else if (intOrString == 100) {
  print("NAHHH");
} else if ((intOrString == 1) or (intOrString == 2)) {
  print("----------------------------------------------------------------------------------------------------");
  print("GOOD!");
  print("Here, these nested conditions guarantee that the type can be narrowed!");
  print("The narrowed type is no longer a oneof:");
  type(intOrString);
  print("Watch me do math with intOrString (which is set to `{intOrString}`): `intOrString + 99 = {intOrString + 99}`");
  print("----------------------------------------------------------------------------------------------------");
}

print(intOrString);

if (((intOrString == 1) or (intOrString == "one")) and (9 > 0)) {
  print("----------------------------------------------------------------------------------------------------");
  print("These particular nested conditions provide no guarantee that the type can be narrowed");
  print("So the type is still a oneof:");
  type(intOrString);
  print("----------------------------------------------------------------------------------------------------");
}

intOrString = "one";
print(intOrString == "one");
print(intOrString == 1);


###############################################################################################
# DEMONSTRATE TYPE "WIDENING" BY ASSIGNING A TYPE OTHER THAN THE NARROWED TYPE AFTER NARROWING.
###############################################################################################

print("----------------------------------------------------------------------------------------------------");
if (input("Do you want an int? Y/N (if no we'll use string):") == "Y") {
  intOrString = 10;
} else {
  intOrString = "ten";
}

if (intOrString == 10) {
  print("You chose to use int!");
  print("Here's some math over intOrString={intOrString}: `intOrString / 2 = {intOrString / 2}`");
  print("That all worked because the type has been narrowed to:");
  type(intOrString);
  print("But now, I'll update the value to one of the other variant types.");
  print("intOrString = \"ten\";\nNow type(intOrString) results in:");
  intOrString = "ten";
  type(intOrString);
  print("The type has been \"widened\"!");
} else if (intOrString == "ten") {
  print("You chose to use string!");
  print("Here's the string you chose: {intOrString}");
  print("And here's each char on a seperate line to prove the string ops work:");
  var i = 0;
  while (i < len(intOrString)) {
    print("Char {i + 1}: {intOrString[i]}");
    i++;
  }
  print("That all worked because the type has been narrowed to:");
  type(intOrString);
  print("But now, I'll update the value to one of the other variant types.");
  print("intOrString = 10;\nNow type(intOrString) results in:");
  intOrString = 10;
  type(intOrString);
  print("The type has been \"widened\"!");
}
print(intOrString);
