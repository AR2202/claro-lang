module MyFirstModule {

  bind firstBinding:int to 99;
  bind firstBinding:string to "first!";

  bind getInput:provider<string> to getUserInput;

}

module MySecondModule {
  bind newInt:int to 100;

  # It's illegal to have duplicate bindings even across different modules, IFF you use the modules at the
  # same time. You can see Claro will throw a compile-time error for that if you uncomment the following.
#  bind firstBinding:string to "duplicate";

  # Module definitions are forbidden everywhere except for the top level. Uncomment this for a compile error.
#  module NestedModule {
#    bind majorKey:string to "nested";
#  }
}


using(firstBinding:string)
consumer printFirstIntBinding(prefix: string) {
  print("{prefix}: {firstBinding}");
}

using(
  firstBinding:int,
  firstBinding:string as firstString, # You're able to use deps that have the same name by aliasing.
  getInput:provider<string>)
consumer foo(x: int) {
  print(firstBinding);
  print(firstString);
  print(getInput());
  print(x);
}

provider getUserInput() -> string {
  return input("gimme a string fam: ");
}

using(MyFirstModule, MySecondModule) {
  printFirstIntBinding("firstBinding");
  foo(10);

  # It's intentionally illegal to define procedures within a using-block. Uncomment this to see Claro
  # give a compile-time error for this.
#  function bar(prompt: string) -> string {
    #    return getInput(prompt);
    #  }
}

# Modules can also be arbitrarily nested!
module WeTheBestModule using(MyFirstDepModule) {
  bind majorKey:string to "anotha one";
}

module MyFirstDepModule using(TransitiveDepsModule) {
  bind something:int to 1000;
}

module TransitiveDepsModule {
  bind boundDep:string to "Transitive Dependencies are Working!!";
}

# You're allowed to successively use modules and they'll operate completely independently.
using(MySecondModule, MyFirstModule) {
  print(getNewInt());

  # You're even allowed to nest using blocks. Modules will compose cleanly as long as none of the nested modules
  # attempt to rebind a key already bound by a module used in the outer block. Note that modules may be reused,
  # either directly as in this example (which is bad style) or as a result of shared transitive module dependencies.
  # Reused modules are actually treated as a no-op since they can be short-circuited at compile-time rather than
  # allowing rebinding, or simply failing.
  using(WeTheBestModule, MyFirstModule) {
    print(getMajorKey("majorKey is bound to"));
  }
}

using(newInt:int)
provider getNewInt() -> int {
  return newInt;
}

using(majorKey:string, firstBinding:string, boundDep:string)
function getMajorKey(s:string) -> string {
  print("This is the firstBinding: {firstBinding}");
  print(boundDep);
  return "{s}: {majorKey}";
}



# If you've made it this far, here's an illustration to help you imagine what's
# basically the main cool part about Claro's module system. I can create mock bindings for tests.
module ProdModule {
  bind getDataFromUser:provider<string> to getUserInput;
  bind askUserQuestion:consumer<string> to s -> { print(s); };
}
module TestModule {
  bind getDataFromUser:provider<string> to () -> "TEST";
  bind askUserQuestion:consumer<string> to s -> { print("TODO(steving) implement no-op instruction in Claro. {s}"); };
}

using(askUserQuestion:consumer<string>, getDataFromUser:provider<string>)
function askUserAQuestionAndGetAnswer(q: string) -> string {
  askUserQuestion(q);
  return getDataFromUser();
}

if (input("Should we test instead of run prod? (Y/N): ") == "Y") {
  using(TestModule) {
    print("Testing!");
    if (askUserAQuestionAndGetAnswer("testing") == "TEST") {
      print("PASSED!");
    } else {
      print("FAILED!");
    }
  }
} else {
  using(ProdModule) {
    print(askUserAQuestionAndGetAnswer("Aren't Claro Modules awesome??"));
  }
}
