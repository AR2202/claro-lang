
var i = 3;

match (i) {
  case 2  -> print("Found i = 2");
  case 1 | 3 | 5  -> print("Found small odd number: {i}");
  case 10 -> print("Found i = 10");
  case _  -> print("Found unknown value: {i}");
}

print("----------------------------------------");
var s = "foo";

match (s) {
  case "bar"  -> print("Found bar");
  case "fizz" | "buzz" ->
    print("Found one of the fizzbuzz strings");
    print("\tIt's actual value is: {s}");
  case _      -> print("Found unknown value: {s}");
}

print("----------------------------------------");
var b = true;

match (b) {
  case true  -> print("True!");
  case false -> print("False!");
  # No default needed because above arms exhaustively cover all cases.
}

########################################################################################################################
# DEMONSTRATE MATCHING OVER A ONEOF
#
# This is already a surprisingly powerful feature as this will be incredibly useful for doing error-handling as Claro
# is built around Error<T> values rather than exceptions. So, for operations that may fail, it'll be a common pattern to
# return a oneof<SuccessRes, Error<FailedRes>> and already, this match will enable very convenient exhaustive handling
# of all errors.
########################################################################################################################

print("----------------------------------------");
var intOrStr: oneof<int, string, boolean> = 10;

match (intOrStr) {
# TODO(steving) TESTING! For some reason this int literal isn't rejected, but is also not handled properly.
#  case 10 ->
  case int ->
    print("Found an int!");
    var proveTypeIsNarrowed = intOrStr + 10;
    print("I can even do math with it: intOrStr + 10 = {proveTypeIsNarrowed}");
  case string -> print("Found a string!");
  case boolean -> print("Found a boolean!");
}

########################################################################################################################
# DEMONSTRATE MATCHING A USER-DEFINED TYPE (limited to wrapping a primitive value)
#
# Note that there are certain restrictions imposed on matching against user-defined types whose unwrapper has been
# restricted as shown below:
#
#   newtype Foo : ...;
#   unwrappers Foo { ... }
#
# First, you are no allowed to match against such a type directly as in:
#
#    match (Foo(...)) { ... }
#
# This restriction exists in order to maintain the semantic "opaqueness" of such types as is explicitly requested by
# defining an unwrappers-block.
#
# TODO(steving) You are still able to match against such a type using a wildcard pattern for the wrapped value when
# TODO(steving) the type is nested within nested within some other structured type. E.g.:
#
#    match([Foo(...)]) {
#      case [Foo(_), _, ...] -> ...; # Matched a Foo at the front of a list of length >= 2.
#      case [..., Foo(_)]    -> ...; # Matched a Foo at the end of a list of length >= 1.
#      case _                -> ...;
#    }
########################################################################################################################

print("----------------------------------------");
newtype Foo<T> : T

var foo = Foo(10);

match (foo) {
  case Foo(1) | Foo(3) | Foo(5) ->
    print("Found small odd Foo");
    print(wrappingMessage(unwrap(foo)));
  case Foo(2) -> print(wrappingMessage(2));
  case Foo(X) -> print("Fell through to default case: {wrappingMessage(X)}");
}

function wrappingMessage(x: int) -> string {
  return "Found Foo wrapping {x}";
}

########################################################################################################################
# DEMONSTRATE MATCHING AGAINST A TUPLE (limited to wrapping primitive elements)
########################################################################################################################

print("----------------------------------------");
var t = (1, 2);

match (t) {
  case (1, 2) -> print("Found a 1 and 2");
  case (3, 0) -> print("Found a 3 and 0");
  case (1, _) -> print("Found a 1 and something else ({t[1]})");
  case (_, 2) -> print("Found something ({t[0]}) and a 2");
  case (3, 6) -> print("Found a 3 and 6");
  case _      -> print("Fell through to default case: {t}");
}

print("----------------------------------------");

for (t2 in [(1, 2, 3), (999, 999, 6), (2, 4, 999), (2, 999, 9), (999, 4, 999), (999, 2, 3), (999, 999, 999)]) {
  print("Matching: {t2}");
  match (t2) {
    case (1, 2, 3) -> print("(1, 2, 3)");
    case (_, _, 6) -> print("(_, _, 6)");
    case (2, 4, _) -> print("(2, 4, _)");
    case (2, _, 9) -> print("(2, _, 9)");
    case (_, 4, _) -> print("(_, 4, _)");
    case (_, 2, 3) -> print("(_, 2, 3)");
    case _         -> print("...Fallthrough...");
  }
}

print("----------------------------------------");
match ((1, "one")) {
  case (_, "two")   -> print("two");
  case (1, "three") -> print("1 two");
  case (1, "one")   -> print("ONES");
  case _            -> print("...Fallthrough...");
}
