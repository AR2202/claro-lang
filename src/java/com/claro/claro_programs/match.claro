
var i = 3;

match (i) {
  case 2  -> print("Found i = 2");
  case 1 | 3 | 5  -> print("Found small odd number: {i}");
  case 10 -> print("Found i = 10");
  case _  -> print("Found unknown value: {i}");
}

print("----------------------------------------");
var s = "foo";

match (s) {
  case "bar"  -> print("Found bar");
  case "fizz" | "buzz" ->
    print("Found one of the fizzbuzz strings");
    print("\tIt's actual value is: {s}");
  case _      -> print("Found unknown value: {s}");
}

print("----------------------------------------");
var b = true;

match (b) {
  case true  -> print("True!");
  case false -> print("False!");
  # No default needed because above arms exhaustively cover all cases.
}

########################################################################################################################
# DEMONSTRATE MATCHING OVER A ONEOF
#
# This is already a surprisingly powerful feature as this will be incredibly useful for doing error-handling as Claro
# is built around Error<T> values rather than exceptions. So, for operations that may fail, it'll be a common pattern to
# return a oneof<SuccessRes, Error<FailedRes>> and already, this match will enable very convenient exhaustive handling
# of all errors.
########################################################################################################################

print("----------------------------------------");
var intOrStr: oneof<int, string, boolean> = 10;

match (intOrStr) {
  case int ->
    print("Found an int!");
    var proveTypeIsNarrowed = intOrStr + 10;
    print("I can even do math with it: intOrStr + 10 = {proveTypeIsNarrowed}");
  case string -> print("Found a string!");
  case boolean -> print("Found a boolean!");
}

########################################################################################################################
# DEMONSTRATE MATCHING A USER-DEFINED TYPE
#
# Note that there are certain restrictions imposed on matching against user-defined types whose unwrapper has been
# restricted as shown below:
#
#   newtype Foo : ...;
#   unwrappers Foo { ... }
#
# First, you are no allowed to match against such a type directly as in:
#
#    match (Foo(...)) { ... }
#
# This restriction exists in order to maintain the semantic "opaqueness" of such types as is explicitly requested by
# defining an unwrappers-block.
#
# TODO(steving) You are still able to match against such a type using a wildcard pattern for the wrapped value when
# TODO(steving) the type is nested within nested within some other structured type. E.g.:
#
#    match([Foo(...)]) {
#      case [Foo(_), _, ...] -> ...; # Matched a Foo at the front of a list of length >= 2.
#      case [..., Foo(_)]    -> ...; # Matched a Foo at the end of a list of length >= 1.
#      case _                -> ...;
#    }
########################################################################################################################

print("----------------------------------------");
newtype Foo<T> : T

var foo = Foo(10);

match (foo) {
  case Foo(1) | Foo(3) | Foo(5) ->
    print("Found small odd Foo");
    print(wrappingMessage(unwrap(foo)));
  case Foo(2) -> print(wrappingMessage(2));
  case Foo(X) -> print("Fell through to default case: {wrappingMessage(X)}");
}

function wrappingMessage(x: int) -> string {
  return "Found Foo wrapping {x}";
}
