# https://adventofcode.com/2022/day/9#part1

alias Dir : tuple<int, int>
alias Cmd : tuple<Dir, int>

provider getCmd() -> Cmd {
  var charToIntMap = {"0":0, "1":1, "2":2, "3":3, "4":4, "5":5, "6":6, "7":7, "8":8, "9":9};
  var charToDirMap = {"U": (-1, 0), "D": (1, 0), "L": (0, -1), "R": (0, 1)};
  var s = input();
  var res: Cmd = (charToDirMap[s[0]], 0);
  var i = 2;
  while (i < len(s)) {
    res[1] = res[1] * 10 + charToIntMap[s[i++]];
  }
  return res;
}

alias Point : tuple<int, int>
function areTouching(p1: Point, p2: Point) -> boolean {
  var abs: function<int -> int> = i -> i * (1 - numeric_bool(i < 0) * 2);
  return (abs(p1[0] - p2[0]) <= 1) and (abs(p1[1] - p2[1]) <= 1);
}

consumer move(rope: [Point], cmd: Cmd, tailVisitedPositions: {Point: int}) {
  # Technically probably shouldn't need to iterate on this first one, but I'll need that if I'm asked to generalize on
  # part 2, so I'll do that now.
  while (cmd[1] > 0) {
    var oldHeadPos = rope[0];
    rope[0] = (oldHeadPos[0] + cmd[0][0], oldHeadPos[1] + cmd[0][1]);
    if (not areTouching(rope[0], rope[1])) {
      rope[1] = oldHeadPos;
      tailVisitedPositions[rope[1]] = 1; # Wishlist: Again, wish Claro had mutable sets.
    }
    cmd[1] = cmd[1] - 1;
  }
}

var rope = [(0,0), (0,0)]; # The rope starts entirely on top of itself.
var tailVisitedPositions = {rope[1]: 1}; # Wishlist: Again, wish Claro had mutable sets.
while (isInputReady()) {
  move(rope, getCmd(), tailVisitedPositions);
}
print("The tail took {len(tailVisitedPositions)} unique positions!");