
# Claro allows the definition of user defined types using the `newtype` keyword! This has *no affect on the generated
# code* it simply allows programmers to indicate that while some types may be *represented* the same at a storage level,
# at a higher conceptual level, they have *semantically distinct interpretations*. So, Claro will enforce this
# distinction in order to allow you to ensure that data of distinct types is always handled in a way that is cognizant
# of the semantics of the custom type.

newtype MyInt : int

var myInt : MyInt = MyInt(1);
print(myInt);
type(myInt);

# By design, there is *NO INHERITANCE* of implementation from the wrapped type. To demonstrate, in the below example,
# even though the type wraps `int`, you cannot do addition with `MyInt` instances (by default, w/o explicitly
# defining how addition works for your custom type).
# Uncomment any of the below lines to see compile-time errors complaining about type mismatches.
#print(myInt + myInt);

# In order to actually get at the wrapped type, Claro provides a builtin `unwrap()` function. Conceptually, think of
# this function as "decoding" or "reinterpreting" the outer type into the wrapped type.
var unwrappedInt : int = unwrap(myInt);
print(unwrappedInt);
type(unwrappedInt);
# Now that you've reinterpreted the MyInt as an int, you can use the `+` operator again since it's impl'd for ints.
print(unwrappedInt + unwrappedInt);


# It's a design decision up to the programmer to decide whether this is valuable, but you may also define newtype's
# based off of another newtype. Again, this establishes an indication that they will share the same underlying concrete
# representation in memory, and MORE IMPORTANTLY that they share the same foundational semantic constraints imposed by
# the wrapped type with ADDITIONAL constraints on top. So here, MyOtherInt is also represented as `int` because
# `MyInt` is represented as an `int`. In some way this could be useful even just in helping you to make sure that two
# types remain structurally equivalent if that's important to you for some reason. But more importantly you can use this
# to layer semantic constraints or reinterpretations.
newtype MyOtherInt : MyInt
var myOtherInt: MyOtherInt = MyOtherInt(myInt);
print(myOtherInt);
type(myOtherInt);

unwrappedInt = unwrap(unwrap(myOtherInt));
print(unwrappedInt + unwrappedInt);

# New Types are, by design, *NOT* mutually compatible with any (transitive) base types they are defined on. Claro very
# intentionally *will never* support traditional subtyping relationships as found in other languages. Remember that the
# *entire point of defining a newtype* is that you claim these things are semantically distinct from one another.

# Uncomment any of the below lines to see compile-time errors complaining about type mismatches.
#myInt = myOtherInt;
#myOtherInt = myInt;
#myInt = 1;
#myOtherInt = 1;


########################################################################################################################
# As you should expect, you can now do anything with your custom types that you could do with builtin types. Here's a
# non-trivial example of doing runtime dynamic dispatch over values of your custom types.
########################################################################################################################

contract Foo<T> {
  consumer bar(t: T);
}
implement Foo<MyInt> as MyIntFoo {
  consumer bar(t: MyInt) {
    print("My Int is: {t}");
  }
}
implement Foo<MyOtherInt> as MyOtherIntFoo {
  consumer bar(t: MyOtherInt) {
    print("My Other Int is: {t}");
  }
}

# Runtime dynamic dispatch here will correctly dispatch to the impl based on which type you choose for `someCustomInt`.
var someCustomInt: oneof<MyInt, MyOtherInt> = myInt;
Foo::bar(someCustomInt);
someCustomInt = myOtherInt;
Foo::bar(someCustomInt);

########################################################################################################################
# DEMONSTRATE A CUSTOM TYPE THAT DEFINES A SINGLE "INITIALIZER" FUNCTION
#
# By defining an "initializers block" for the type `EvenInt` below, this program is now unable to construct an instance
# of `EvenInt` w/o going through the initializer function `GetValidatedEvenInt`. This has the powerful implication that
# no matter what, if you have an instance of `EvenInt`, you know for a fact that the wrapped `int` is even.
########################################################################################################################

newtype NothingType : boolean
initializers NothingType {
  provider Nothing() -> NothingType {
    return NothingType(false);
  }
}

newtype EvenInt : int

initializers EvenInt {
  function GetValidatedEvenInt(x: int) -> oneof<EvenInt, NothingType> {
    if (x % 2 == 1) {
      return Nothing();
    }
    return EvenInt(x);
  }
}


var firstEvenInt : oneof<EvenInt, NothingType> = GetValidatedEvenInt(2);
if (firstEvenInt instanceof EvenInt) {
  print("I successfully initialized an EvenInt! {firstEvenInt}");
  type(firstEvenInt); # Via type-narrowing, Claro is aware that this is an EventInt.
}
firstEvenInt = GetValidatedEvenInt(3);
if (firstEvenInt instanceof NothingType) {
  print("The odd int 3 was correctly rejected!: {firstEvenInt}");
  type(firstEvenInt); # Via type-narrowing, Claro is aware that this is a NothingType.
}


# It is impossible to call `EvenInt`'s constructor directly since the initializers block is defined for that type. Try
# Uncommenting the lines below w/ the call to `EvenInt(3)` and you'll see this error message:
#  "user_defined_types.claro:xxx: Illegal Use of User-Defined Type Constructor Outside of Initializers Block: An initializers
#    block has been defined for the custom type `EvenInt`, so, in order to maintain any semantic constraints that the
#    initializers are intended to impose on the type, you aren't allowed to use the type's default constructor directly.
#   		Instead, to get an instance of this type, consider calling one of the defined initializers:
#   			- GetValidatedEvenInt
#   var shouldMakeThisInvalid : EvenInt = EvenInt(3);
#                                         ^^^^^^^^^^
#   1 Error"

#var thisWillNotCompile: EvenInt = EvenInt(3);
#print(thisWillNotCompile);