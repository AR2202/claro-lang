contract BinaryMathOps<T, V, R> {
  function add(lhs: T, rhs: V) -> R;
  function multiply(lhs: T, rhs: V) -> R;
}

implement BinaryMathOps<int, int, int> as IntegerAddition {
  function add(lhs: int, rhs: int) -> int {
    return lhs + rhs;
  }

  function multiply(lhs: int, rhs: int) -> int {
    return lhs * rhs;
  }
}

implement BinaryMathOps<string, string, string> as ConcatStrings {
  function add(lhs: string, rhs: string) -> string {
    return "{lhs}{rhs}";
  }

  function multiply(lhs: string, rhs: string) -> string {
    # I'm not really sure what multiply means between two strings so....
    return "\"{lhs}\" * \"{rhs}\"";
  }
}

alias IntFn : function<int -> int>

implement BinaryMathOps<IntFn, int, IntFn> as ModifyIntFuncOutput {
  function add(lhs: function<int -> int>, rhs: int) -> function<int -> int> {
    return x -> lhs(x) + rhs;
  }

  function multiply(lhs: function<int -> int>, rhs: int) -> function<int -> int> {
    return x -> lhs(x) * rhs;
  }
}

####################################################################################################
# DEMONSTRATE CALLING CONTRACT PROCEDURES
#
# All expr types are always able to be statically inferred (since Claro will *never* support
# nominal subtyping and does not yet support the planned oneof<Foo, Bar, ...> type). So, Claro
# takes advantage of this to statically infer which contract implementation to dispatch to at
# compile-time.
####################################################################################################

print("--------------------------------------------------------------------------------");
print("Testing BinaryMathOps<int, int, int>::add");
var intRes: int = BinaryMathOps::add(2, 98);
print(intRes);
print("Testing BinaryMathOps<int, int, int>::multiply");
intRes = BinaryMathOps::multiply(2, 98);
print(intRes);

print("--------------------------------------------------------------------------------");
print("Testing BinaryMathOps<string, string, string>::add");
var stringRes: string = BinaryMathOps::add("Age: ", "twenty-eight");
print(stringRes);
print("Testing BinaryMathOps<string, string, string>::multiply");
stringRes = BinaryMathOps::multiply("Age: ", "twenty-eight");
print(stringRes);

print("--------------------------------------------------------------------------------");
print("Testing BinaryMathOps<function<int -> int>, int, function<int -> int>>::add");
var modifiedFuncRes: IntFn = BinaryMathOps::add((IntFn) x -> x, 10);
print(modifiedFuncRes(90));
print("Testing BinaryMathOps<function<int -> int>, int, function<int -> int>>::multiply");
modifiedFuncRes = BinaryMathOps::multiply((IntFn) x -> x, 10);
print(modifiedFuncRes(90));

# This should give you a hint as to how Claro will utilize Contracts as the basis for Generics via
# a clever but simple technique known as "monomorphization".
function foo(i: int) -> int {
  return BinaryMathOps::add(i, i);
}
function bar(s: string) -> string {
  return BinaryMathOps::add(s, s);
}
print("--------------------------------------------------------------------------------");
print(foo(900000));
print(bar("sup "));

implement BinaryMathOps<int, int, string> as IntegerAdditionFormattedAsString {
  function add(lhs: int, rhs: int) -> string {
    var intAdditionRes: int = BinaryMathOps::add(lhs, rhs);
    return "Integer Addition Res String: {intAdditionRes}";
  }
  function multiply(lhs: int, rhs: int) -> string {
    var intMultRes: int = BinaryMathOps::multiply(lhs, rhs);
    return "Integer Multiplication Res String: {intMultRes}";
  }
}
print("--------------------------------------------------------------------------------");
print("Testing BinaryMathOps<int, int, string>::add");
print((string) BinaryMathOps::add(1, 99));
print("...again using inference.");
var intintstringres: string = BinaryMathOps::add(100, 28);
print(intintstringres);

#########################################################################
## A FEW GENERICS EXAMPLES!!
#########################################################################

requires(BinaryMathOps<T,V,R>)
function pairwiseSum<T, V, R>(ttuple: tuple<T, T>, vtuple: tuple<V, V>) -> tuple<R, R> {
  var res1: R = BinaryMathOps::add(ttuple[0], vtuple[0]);
  var res2: R = BinaryMathOps::add(ttuple[1], vtuple[1]);
  return (res1, res2);
}

print("----------------------------------------------------------");
print("Testing Generic function pairwiseSum<string, string, string>:");
var ttuple: tuple<string, string> = ("Hello, generic ", "This is ");
var vtuple: tuple<string, string> = ("Claro world!", "effing sweet.");
var firstGenericResult: tuple<string, string> = pairwiseSum(ttuple, vtuple);
print(firstGenericResult[0]);
print(firstGenericResult[1]);

print("----------------------------------------------------------");
print("Testing Generic function pairwiseSum<int, int, int>:");
var ttuple3: tuple<int, int> = (1, 99);
var vtuple3: tuple<int, int> = (99, 1);
var thirdGenericResult: tuple<int, int> = pairwiseSum(ttuple3, vtuple3);
print(thirdGenericResult[0]);
print(thirdGenericResult[1]);

# TODO(steving) Implement support for Providers used as contract procedures.
####################################################################################################
# DEMONSTRATE CONTRACTS THAT INCLUDE PROVIDER SIGNATURES
####################################################################################################
#
#contract Default<T> {
#  provider get() -> T;
#}
#
#implement Default<int> as DefaultInt {
#  provider get() -> int {
#    return 0;
#  }
#}
#
#var defaultInt: int = Default::get();
#print(defaultInt);
#
#requires(Default<T>)
#provider getDefault<T>() -> T {
#  return Default::get();
#}
#
#defaultInt = getDefault();
#print(defaultInt);


####################################################################################################
# DEMONSTRATE CONTRACTS THAT INCLUDE GENERIC SIGNATURES
####################################################################################################

contract Foo<T> {
  function doIt<V>(t: T, v: V) -> tuple<T, V>;
}

implement Foo<int> as IntFoo {
  function doIt<V>(t: int, v: V) -> tuple<int, V> {
    return (2 * t, v);
  }
}
implement Foo<string> as StringFoo {
  function doIt<V>(t: string, v: V) -> tuple<string, V> {
    return ("formatted: {t}", identity(v));
  }
}

# Just ensuring that we're still able to call other generic procedures from within generic contract procedures.
function identity<A>(a: A) -> A { return a; }

print("----------------------------------------------------------");
print("Testing Foo::doIt<T>:");
var t = Foo::doIt(10, "ten");
type(t);
print(t);
var t2 = Foo::doIt(10, ["ten"]);
type(t2);
print(t2);
var t3 = Foo::doIt("10", ["ten"]);
type(t3);
print(t3);


####################################################################################################
# DEMONSTRATE CONTRACTS THAT INCLUDE BOTH BLOCKING-GENERICS AND GENERIC TYPE PARAMS
####################################################################################################

contract Bar<O> {
  blocking:mapFn function doIt<I>(i: I, mapFn: blocking? function<I -> O>) -> O;
  blocking function doItBlocking<I>(i: I, mapFn: blocking function<I -> O>) -> O;
}
implement Bar<int> as IntBar {
  blocking:mapFn function doIt<I>(i: I, mapFn: blocking? function<I -> int>) -> int {
    return mapFn(i);
  }
  blocking function doItBlocking<I>(i: I, mapFn: blocking function<I -> int>) -> int {
    return mapFn(i);
  }
}

graph function testGraph(i: int) -> future<int> {
  root res <- (int) Bar::doIt(@imm, (x: int) -> int { return 2 * x; });
# Uncomment this line to get an error message indicating that you're not allowed to call blocking procedures from here.
#  root res <- (int) Bar::doIt(@imm, blocker);
  node imm <- i;
}
blocking function blocker(i: int) -> int {
  var res <-| testGraph(i);
  return res;
}

print("----------------------------------------------------------");
print("Testing Blocking Generics with Bar<T>::doIt");
print(Bar::doIt(2, (x: int) -> int { return 2 * x; }));
print(Bar::doIt(2, blocker));

print("----------------------------------------------------------");
print("Testing Blocking Function Bar<T>::doItBlocking");
print(Bar::doItBlocking(2, blocker));
# Uncomment this line to get a type mismatch error indicating that a blocking function is expected.
#print(Bar::doItBlocking(2, (x: int) -> int { return 2 * x; }));



####################################################################################################
# DEMONSTRATE CONTRACTS THAT INCLUDE CONSUMER SIGNATURES
####################################################################################################

contract Consumes<T> {
  consumer prefixPrint(prefix: string, t: T);
}
implement Consumes<int> as IntConsumes {
  consumer prefixPrint(prefix: string, t: int) {
    print("{prefix}: {t}");
  }
}
implement Consumes<string> as StrConsumes {
  consumer prefixPrint(prefix: string, t: string) {
    print("{prefix}: {t}");
  }
}

print("----------------------------------------------------------");
print("Testing Consumer Consumes<T>::prefixPrint");
Consumes::prefixPrint("Contract Consumer Call", 1);
Consumes::prefixPrint("Contract Consumer Call", "two");

# Of course, generic procedures may defer to contract consumers.
requires(Consumes<T>, BinaryMathOps<T, T, T>)
consumer genericConsumer<T>(t: T) {
  Consumes::prefixPrint("DEFERRED", t);
  _ = (T) BinaryMathOps::add(t, t);
}
genericConsumer(3);
genericConsumer("three");

