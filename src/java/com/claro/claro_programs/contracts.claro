contract BinaryMathOps<T, V, R> {
  function add(lhs: T, rhs: V) -> R;
  function multiply(lhs: T, rhs: V) -> R;
}

implement BinaryMathOps<int, int, int> as IntegerAddition {
  function add(lhs: int, rhs: int) -> int {
    return lhs + rhs;
  }

  function multiply(lhs: int, rhs: int) -> int {
    return lhs * rhs;
  }
}

implement BinaryMathOps<string, string, string> as ConcatStrings {
  function add(lhs: string, rhs: string) -> string {
    return "{lhs}{rhs}";
  }

  function multiply(lhs: string, rhs: string) -> string {
    # I'm not really sure what multiply means between two strings so....
    return "\"{lhs}\" * \"{rhs}\"";
  }
}

alias IntFn : function<int -> int>

implement BinaryMathOps<IntFn, int, IntFn> as ModifyIntFuncOutput {
  function add(lhs: function<int -> int>, rhs: int) -> function<int -> int> {
    return x -> lhs(x) + rhs;
  }

  function multiply(lhs: function<int -> int>, rhs: int) -> function<int -> int> {
    return x -> lhs(x) * rhs;
  }
}

####################################################################################################
# DEMONSTRATE CALLING CONTRACT PROCEDURES
#
# All expr types are always able to be statically inferred (since Claro will *never* support
# nominal subtyping and does not yet support the planned oneof<Foo, Bar, ...> type). So, Claro
# takes advantage of this to statically infer which contract implementation to dispatch to at
# compile-time.
####################################################################################################

print("--------------------------------------------------------------------------------");
print("Testing BinaryMathOps<int, int, int>::add");
var intRes: int = BinaryMathOps::add(2, 98);
print(intRes);
print("Testing BinaryMathOps<int, int, int>::multiply");
intRes = BinaryMathOps::multiply(2, 98);
print(intRes);

print("--------------------------------------------------------------------------------");
print("Testing BinaryMathOps<string, string, string>::add");
var stringRes: string = BinaryMathOps::add("Age: ", "twenty-eight");
print(stringRes);
print("Testing BinaryMathOps<string, string, string>::multiply");
stringRes = BinaryMathOps::multiply("Age: ", "twenty-eight");
print(stringRes);

print("--------------------------------------------------------------------------------");
print("Testing BinaryMathOps<function<int -> int>, int, function<int -> int>>::add");
var modifiedFuncRes: IntFn = BinaryMathOps::add((IntFn) x -> x, 10);
print(modifiedFuncRes(90));
print("Testing BinaryMathOps<function<int -> int>, int, function<int -> int>>::multiply");
modifiedFuncRes = BinaryMathOps::multiply((IntFn) x -> x, 10);
print(modifiedFuncRes(90));

# This should give you a hint as to how Claro will utilize Contracts as the basis for Generics via
# a clever but simple technique known as "monomorphization".
function foo(i: int) -> int {
  return BinaryMathOps::add(i, i);
}
function bar(s: string) -> string {
  return BinaryMathOps::add(s, s);
}
print("--------------------------------------------------------------------------------");
print(foo(900000));
print(bar("sup "));

# TODO(steving) Somehow, Claro still has no way to convert btwn string <-> int...crazy, huh. Fix this.
#implement BinaryMathOps<int, int, string> as IntegerAdditionFormattedAsString {
#  function add(lhs: int, rhs: int) -> string {
#    var intAdditionRes: int = BinaryMathOps<int, int, int>::add(lhs, rhs);
#    return "Integer Addition Res String: {intAdditionRes}";
#  }
#}
#print("Testing BinaryMathOps<int, int, string>::add");
#print(BinaryMathOps<int, int, string>::add(1, 99));
#print("...again using inference.");
#var intintstringres: string = BinaryMathOps::add(100, 28);
#print(intintstringres);

#########################################################################
## A FEW GENERICS EXAMPLES!!
#########################################################################

requires(BinaryMathOps<T,V,R>)
function pairwiseSum<T, V, R>(ttuple: tuple<T, T>, vtuple: tuple<V, V>) -> tuple<R, R> {
  var res1: R = BinaryMathOps::add(ttuple[0], vtuple[0]);
  var res2: R = BinaryMathOps::add(ttuple[1], vtuple[1]);
  return (res1, res2);
}

print("----------------------------------------------------------");
print("Testing Generic function pairwiseSum<string, string, string>:");
var ttuple: tuple<string, string> = ("Hello, generic ", "This is ");
var vtuple: tuple<string, string> = ("Claro world!", "effing sweet.");
var firstGenericResult: tuple<string, string> = pairwiseSum(ttuple, vtuple);
print(firstGenericResult[0]);
print(firstGenericResult[1]);


# TODO(steving) Somehow, Claro still has no way to convert btwn string <-> int...crazy, huh. Fix this.
#print("----------------------------------------------------------");
#print("Testing Generic function pairwiseSum<string, int, string>:");
#var ttuple2: tuple<string, string> = ("Number of problems I got: ", "Generics ain't ");
#var vtuple2: tuple<int, int> = (99, 1);
#var secondGenericResult: tuple<string, string> = pairwiseSum(ttuple2, vtuple2);
#print(secondGenericResult[0]);
#print(secondGenericResult[1]);

print("----------------------------------------------------------");
print("Testing Generic function pairwiseSum<int, int, int>:");
var ttuple3: tuple<int, int> = (1, 99);
var vtuple3: tuple<int, int> = (99, 1);
var thirdGenericResult: tuple<int, int> = pairwiseSum(ttuple3, vtuple3);
print(thirdGenericResult[0]);
print(thirdGenericResult[1]);

