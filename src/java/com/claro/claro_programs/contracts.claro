contract Add<T, V, R> {
  function add(lhs: T, rhs: V) -> R;
}

implement Add<string, string, string> as ConcatStrings {
  function add(lhs: string, rhs: string) -> string {
    return "{lhs}{rhs}";
  }
}

implement Add<int, int, int> as IntegerAddition {
  function add(lhs: int, rhs: int) -> int {
    return lhs + rhs;
  }
}

alias IntFn : function<int -> int>

implement Add<IntFn, int, IntFn> as ModifyIntFuncOutput {
  function add(lhs: function<int -> int>, rhs: int) -> function<int -> int> {
    return x -> lhs(x) + rhs;
  }
}

print("--------------------------------------------------------------------------------");
print("Testing contract implementation Add<string, string, string>::add");
var stringResAgain: string = Add::add("Age: ", "twenty-eight");
print(stringResAgain);

print("--------------------------------------------------------------------------------");
print("Testing contract implementation Add<string, string, string>::add");
var intResAgain: int = Add::add(1, 99);
print(intResAgain);

print("--------------------------------------------------------------------------------");
print("Testing contract implementation Add<function<int -> int>, int, function<int -> int>>::add");
var modifiedFuncResAgain: IntFn = Add::add((IntFn) x -> x, 10);
print(modifiedFuncResAgain(90));

# This should give you a hint as to how Claro will utilize Contracts as the basis for Generics via
# a clever but simple technique known as "monomorphization".
function foo(i: int) -> int {
  return Add::add(i, i);
}
function bar(s: string) -> string {
  return Add::add(s, s);
}
print(foo(900000));
print(bar("sup "));

#implement Add<int, int, string> as IntegerAdditionFormattedAsString {
#  function add(lhs: int, rhs: int) -> string {
#    var intAdditionRes: int = Add<int, int, int>::add(lhs, rhs);
#    return "Integer Addition Res String: {intAdditionRes}";
#  }
#}
#print("Testing contract implementation Add<int, int, string>::add");
#print(Add<int, int, string>::add(1, 99));
#print("...again using inference.");
#var intintstringres: string = Add::add(100, 28);
#print(intintstringres);

#########################################################################
## DEMONSTRATE A GENERIC FUNCTION OVER REQUIRED CONTRACT IMPLEMENTATION.
#########################################################################
#
#requires(Add<T,V,R>)
#function pairwiseSum<T, V, static R>(ttuple: tuple<T, T>, vtuple: tuple<V, V>) -> tuple<R, R> {
#  var res1: R = Add<T,V,R>::add(((T) ttuple[0]), ((V) vtuple[0]));
#  var res2: R = Add<T,V,R>::add(((T) ttuple[1]), ((V) vtuple[1]));
#  return (res1, res2);
#}
#
#print("Testing Generic function pairwiseSum<string, string, string>:");
#var ttuple: tuple<string, string> = ("Hello, generic ", "This is ");
#var vtuple: tuple<string, string> = ("Claro world!", "effing sweet.");
#var firstGenericResult: tuple<string, string> = pairwiseSum(ttuple, vtuple);
#print((string) firstGenericResult[0]);
#print((string) firstGenericResult[1]);
#
#print("Testing Generic function pairwiseSum<string, int, string>:");
#var ttuple2: tuple<string, string> = ("Number of problems I got: ", "Generics ain't ");
#var vtuple2: tuple<int, int> = (99, 1);
#var secondGenericResult: tuple<string, string> = pairwiseSum(ttuple2, vtuple2);
#print((string) secondGenericResult[0]);
#print((string) secondGenericResult[1]);
#
#print("Testing Generic function pairwiseSum<int, int, int>:");
#var ttuple3: tuple<int, int> = (1, 99);
#var vtuple3: tuple<int, int> = (99, 1);
#var thirdGenericResult: tuple<int, int> = pairwiseSum(ttuple3, vtuple3);
#print((string) thirdGenericResult[0]);
#print((string) thirdGenericResult[1]);
#
#print("Testing Generic function pairwiseSum<int, int, string>:");
#var ttuple4: tuple<int, int> = (90, 909);
#var vtuple4: tuple<int, int> = (-999, 0);
#var fourthGenericResult: tuple<string, string> = pairwiseSum(ttuple4, vtuple4);
#print((string) fourthGenericResult[0]);
#print((string) fourthGenericResult[1]);
#var fourthGenericResultWithoutInference = pairwiseSum<int, int, string>(ttuple4, vtuple4);
#print(fourthGenericResultWithoutInference[0]);
#print(fourthGenericResultWithoutInference[1]);

