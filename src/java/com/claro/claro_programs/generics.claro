#########################################################################
## DEMONSTRATE A GENERIC FUNCTION OVER REQUIRED CONTRACT IMPLEMENTATION!
#########################################################################

contract Conversion<I, O> {
  function applyConversion(from: I) -> O;
}

implement Conversion<int, string> as IntToStrConversion {
  function applyConversion(from: int) -> string {
    var res: string;
    if (from < 0) {
      res = "Negative";
    } else if (from == 0) {
      res = "Zero";
    } else {
      res = "Positive";
    }
    return res;
  }
}

implement Conversion<tuple<int, int>, [int]> as TupleIntIntToListInt {
  function applyConversion(from: tuple<int, int>) -> [int] {
    return [(int) from[0], (int) from[1]];
  }
}

# THIS IS MY FIRST GENERIC FUNCTION IN CLARO! DOESN'T SEEM LIKE MUCH, BUT IT TOOK A LOT TO LEAD UP TO THIS!
# YAY CODE REUSE!

requires(Conversion<From, To>)
function convert<From, To>(toConvert: From) -> To {
  print("Converting from input type: ");
  type(toConvert);
  var converted: To = Conversion::applyConversion(toConvert);
  print("To output type: ");
  type(converted);
  return converted;
}

print("----------------------------------------------------------");
print("Testing generic function convert<int, string>");
var intToStringConvertedRes: string = convert(10);
print(intToStringConvertedRes);

var tupleIntIntToListIntConvertedRes: [int] = convert((9, 10));
print(tupleIntIntToListIntConvertedRes);


####################################################################
## DEMONSTRATE A GENERIC FUNCTION THAT JUST TAKES A FIRST CLASS ARG
####################################################################

function map<I, O>(inputList: [I], mapFn: function<I -> O>) -> [O] {
  var outputList: [O] = [];
  var i = 0;
  while (i < len(inputList)) {
    append(outputList, mapFn(inputList[i++]));
  }
  return outputList;
}

print("----------------------------------------------------------");
print("Testing generic function map<|[int], function<int, boolean>| -> [boolean]>");
var mapResult = map([1, 90, -13, 0], (function<int -> boolean>) x -> x >= 0);
print(mapResult);

# TODO(steving) I'd like the following type inference to be supported. All of the information is there
# TODO(steving) so Claro should be able to figure this out, but I'm leaving it as a TODO for now since it's really hard
# TODO(steving) to imagine a way to get the lambda to have its type asserted onto it, when the typical generic func call
# TODO(steving) flow is to infer each arg's type (which lambda does not support as its syntax is ambiguous).
#var mapResult: [boolean] = map([1, 90, -13, 0], x -> x >= 0);

##########################################################################
## DEMONSTRATE A GENERIC FUNCTION THAT DEFERS TO ANOTHER GENERIC FUNCTION
##########################################################################

requires(Conversion<In, Out>)
function defer<In, Out>(in: In) -> Out {
  return Conversion::applyConversion(in);
}

function mapDeferringToContractImpl<I, O>(inputList: [I]) -> [O] {
  var outputList: [O] = [];
  var i = 0;
  while (i != len(inputList)) {
    append(outputList, defer(inputList[i++]));
  }
  return outputList;
}

print("----------------------------------------------------------");
print("Testing generic function map<int, string>");
var mappedStringsRes: [string] = mapDeferringToContractImpl([1,-1,0,10,-99]);
print(mappedStringsRes);

##################################################################################
## DEMONSTRATE A GENERIC FUNCTION THAT USES BOTH A CONTRACT AND A FIRST CLASS ARG
##################################################################################

implement Conversion<int, float> as IntToFloat {
  function applyConversion(from: int) -> float {
    return from * 1.0;
  }
}

requires(Conversion<From, Intermediate>)
function mapThroughIntermediate<From, Intermediate, To>(
    inputList: [From], mapFn: function<Intermediate -> To>) -> [To] {
  var outputList: [To] = [];
  var i = 0;
  while (i < len(inputList)) {
    append(outputList, mapFn(Conversion::applyConversion(inputList[i++])));
  }
  return outputList;
}

print("----------------------------------------------------------");
print("Testing generic function mapThroughIntermediate<int, float, boolean>");
var intsAsBools =
  mapThroughIntermediate(
    [-1, 2, 3, -4],
    (function<float -> boolean>) x -> {
      if (x >= 0) {
        return true;
      }
      return false;
    });
print(intsAsBools);
