#########################################################################
## DEMONSTRATE A GENERIC FUNCTION OVER REQUIRED CONTRACT IMPLEMENTATION!
#########################################################################

contract Conversion<I, O> {
  function applyConversion(from: I) -> O;
}

implement Conversion<int, string> as IntToStrConversion {
  function applyConversion(from: int) -> string {
    var res: string;
    if (from < 0) {
      res = "Negative";
    } else if (from == 0) {
      res = "Zero";
    } else {
      res = "Positive";
    }
    return res;
  }
}

implement Conversion<tuple<int, int>, [int]> as TupleIntIntToListInt {
  function applyConversion(from: tuple<int, int>) -> [int] {
    return [(int) from[0], (int) from[1]];
  }
}

# THIS IS MY FIRST GENERIC FUNCTION IN CLARO! DOESN'T SEEM LIKE MUCH, BUT IT TOOK A LOT TO LEAD UP TO THIS!
# YAY CODE REUSE!

requires(Conversion<From, To>)
function convert<From, To>(toConvert: From) -> To {
  print("Converting from input type: ");
  type(toConvert);
  var converted: To = Conversion::applyConversion(toConvert);
  print("To output type: ");
  type(converted);
  return converted;
}

print("----------------------------------------------------------");
print("Testing generic function convert<int, string>");
var intToStringConvertedRes: string = convert(10);
print(intToStringConvertedRes);

print("----------------------------------------------------------");
print("Testing generic function convert<(int, int), [int]>");
var tupleIntIntToListIntConvertedRes: [int] = convert((9, 10));
print(tupleIntIntToListIntConvertedRes);


####################################################################
## DEMONSTRATE A GENERIC FUNCTION THAT JUST TAKES A FIRST CLASS ARG
####################################################################

function map<I, O>(inputList: [I], mapFn: function<I -> O>) -> [O] {
  var outputList: [O] = [];
  var i = 0;
  while (i < len(inputList)) {
    append(outputList, mapFn(inputList[i++]));
  }
  return outputList;
}

print("----------------------------------------------------------");
print("Testing generic function map<|[int], function<int, boolean>| -> [boolean]>");
var mapResult = map([1, 90, -13, 0], (function<int -> boolean>) x -> x >= 0);
print(mapResult);

# TODO(steving) I'd like the following type inference to be supported. All of the information is there
# TODO(steving) so Claro should be able to figure this out, but I'm leaving it as a TODO for now since it's really hard
# TODO(steving) to imagine a way to get the lambda to have its type asserted onto it, when the typical generic func call
# TODO(steving) flow is to infer each arg's type (which lambda does not support as its syntax is ambiguous).
#var mapResult: [boolean] = map([1, 90, -13, 0], x -> x >= 0);
#var mapResult: [boolean] = map([1, 90, -13, 0], (x: int) -> boolean { return x >= 0; });


function filter<T>(inputList: [T], predFn: function<T -> boolean>) -> [T] {
  var outputList: [T] = [];
  var i = 0;
  while (i < len(inputList)) {
    var curr = inputList[i++];
    if (predFn(curr)) {
      append(outputList, curr);
    }
  }
  return outputList;
}

print("----------------------------------------------------------");
print("Testing generic function filter<|[int], function<int, boolean>| -> [int]>");
var filterResult = filter([1, 90, -13, 0], (function<int -> boolean>) x -> x > 0);
print(filterResult);

##########################################################################
## DEMONSTRATE A GENERIC FUNCTION THAT DEFERS TO ANOTHER GENERIC FUNCTION
##########################################################################

requires(Conversion<In, Out>)
function defer<In, Out>(in: In) -> Out {
  return Conversion::applyConversion(in);
}

function mapDeferringToContractImpl<I, O>(inputList: [I]) -> [O] {
  var outputList: [O] = [];
  var i = 0;
  while (i != len(inputList)) {
    append(outputList, defer(inputList[i++]));
  }
  return outputList;
}

print("----------------------------------------------------------");
print("Testing generic function mapDeferringToContractImpl<int, string>");
var mappedStringsRes: [string] = mapDeferringToContractImpl([1,-1,0,10,-99]);
print(mappedStringsRes);
print("----------------------------------------------------------");
print("Testing generic function mapDeferringToContractImpl<int, float>");
var mappedFloatsRes: [float] = mapDeferringToContractImpl([1,-1,0,10,-99]);
print(mappedFloatsRes);

##################################################################################
## DEMONSTRATE A GENERIC FUNCTION THAT USES BOTH A CONTRACT AND A FIRST CLASS ARG
##################################################################################

implement Conversion<int, float> as IntToFloat {
  function applyConversion(from: int) -> float {
    return from * 1.0;
  }
}

requires(Conversion<From, Intermediate>)
function mapThroughIntermediate<From, Intermediate, To>(
    inputList: [From], mapFn: function<Intermediate -> To>) -> [To] {
  var outputList: [To] = [];
  var i = 0;
  while (i < len(inputList)) {
    append(outputList, mapFn(Conversion::applyConversion(inputList[i++])));
  }
  return outputList;
}

print("----------------------------------------------------------");
print("Testing generic function mapThroughIntermediate<int, float, boolean>");
var intsAsBools =
  mapThroughIntermediate(
    [-1, 2, 3, -4],
    (function<float -> boolean>) x -> {
      if (x >= 0) {
        return true;
      }
      return false;
    });
print(intsAsBools);

############################################################################################################
## TOY EXAMPLE SHOWING HOW A FRAMEWORK MIGHT USE THIS TO PROVIDE FUNCTIONALITY W/O KNOWING ABOUT YOUR TYPES
############################################################################################################

# Bear with me on these aliases, Claro doesn't have structs yet.
alias ID : string
alias Person : tuple<string, ID>
alias Dog : tuple<string, string, ID>

contract HasId<T> {
  function getId(t: T) -> ID;
}
implement HasId<Person> as PersonId {
  function getId(p: Person) -> ID {
    return (ID) p[1];
  }
}
implement HasId<Dog> as DogId {
  function getId(d: Dog) -> ID {
    return (ID) d[2];
  }
}

function dbSave<S>(objectToSave: S, id: ID) -> boolean {
  print("Persisting - \n\tID: ");
  print(id);
  print("\tObject: ");
  print(objectToSave);
  return true;
}

requires(HasId<T>)
function persist<T>(t: T) -> boolean {
  var idToPersist: ID = HasId::getId(t);
  return dbSave(t, idToPersist);
}

var p1: Person = ("CÃ©dric", "1");
var p2: Person = ("Jason", "2");
var dog1: Dog = ("Max", "Golden Retriever", "3");

# Nobody should need to pass the lambda arg, even though we're not
# using inheritance.
print("----------------------------------------------------------");
var persistResult = persist(p1);
print(persistResult);
print("----------------------------------------------------------");
persistResult = persist(p2);
print(persistResult);
print("----------------------------------------------------------");
persistResult = persist(dog1);
print(persistResult);


# Fun fact: Generics based around monomorphization cannot handle compiling this function which otherwise should be a
# valid program. Uncomment to see the compiler hang forever. The issue is that the compiler continues finding new
# monomorphizations that it needs to create indefinitely.
#
# Fun Fact #2: Rust has the same issue e.g. https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2b83fcf6dcb45900c83586e6d9070709
#
#function testRec<T>(t: T, i: int) -> int {
#  if (i >= 10) {
#    return i;
#  }
#  return testRec((t, t), i+1);
#}
#
#print(testRec("this will break", 0));


############################################################################################################
## EXAMPLE OF DEFINING A GENERIC FUNCTION TO BE BLOCKING (NOT TO BE CONFUSED W/ BLOCKING-GENERIC)
############################################################################################################

blocking function genericBlockingFunc<T>(futureArg: future<T>) -> T {
  var res <-| futureArg;
  return res;
}

###########################################################################################################
## EXAMPLE OF DEFINING A GENERIC FUNCTION TO ALSO BE BLOCKING-GENERIC
############################################################################################################

requires(Conversion<T, V>)
blocking:deferFn function example<T, V>(t: T, deferFn: blocking? function<V -> V>) -> V {
  return deferFn(Conversion::applyConversion(t));
}

print("----------------------------------------------------------");
print(example(100, (function<string -> string>) x -> x));

blocking function block(x: string) -> string {
  print(x);
  var res <-| fooGraph(100);
  return res;
}

graph function fooGraph(x: int) -> future<string> {
  root res <- example(@arg, (function<string -> string>) x -> x);
  # Uncomment the below line for a compile-time error preventing a deadlock.
#  root res <- example(@arg, block);
  node arg <- x;
}
var graphres <-| fooGraph(10);
print(graphres);



###########################################################################################################
## EXAMPLE OF USING GENERIC PROCEDURES AS A FIRST-CLASS OBJECT!
############################################################################################################

print("----------------------------------------------------------");
var exampleFnAsFirstClassObj: function<|int, function<string -> string>| -> string> = example;
print(exampleFnAsFirstClassObj(-100, x -> x));
var exampleBlockingFnAsFirstClassObj: blocking function<|int, blocking function<string -> string>| -> string> = example;
print(exampleBlockingFnAsFirstClassObj(100, block));

# It's invalid to reference a Generic Procedure as a first class object w/o an explicit contextual type assertion. This
# is due to monomorphization, as a result of which each specialization of a Generic Procedure is backed by unique
# generated code, so this restriction exists so that the compiler is able to statically determine with certainty which
# concrete generated procedure should be referenced. Uncomment this for a compile-time error explaining this in detail.
#var shouldFailWithAmbiguousTypes = persist;
#print(shouldFailWithAmbiguousTypes);
