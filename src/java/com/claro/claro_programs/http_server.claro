HttpService MyDemoService {
  home:  "/",
  page1: "/page1",
  page2: "/page2",
  page3: "/page3",
  page4: "/page4"

  # TODO(steving) Support the following format by generating this corresponding contract procedure signature:
  # TODO(steving)     graph function page5(userInput: string) -> future<HttpResponse>;
  # page5: "/page5/{userInput}"
}

########################################################################################################################
# For each HttpService definition, Claro you may either generate a client to communicate with a remote server, OR
# declare an `endpoint_handlers` block for the service in order to be able to generate a server that implements the
# service. This is the key power of the language's server definitions as each endpoint handler is statically *REQUIRED*
# to be implemented in a non-blocking manner to fully leverage 100% of Claro's extremely efficient multithreaded
# concurrency model.
########################################################################################################################

endpoint_handlers MyDemoService {
  # TODO(steving) Support graph functions as well so that we can pass in some sort of request body or query params or something.
  graph provider home() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- homeHandler();
  }

  graph provider page1() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- htmlPageHandler(1);
  }

  graph provider page2() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- htmlPageHandler(2);
  }

  # Let's intentionally cause an internal server error at this endpoint just to test it out.
  graph provider page3() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@causesRuntimeError);
    node causesRuntimeError <- @formattedHtml[-1];
    node formattedHtml <- htmlPageHandler(3);
  }

  graph provider page4() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForJson(@formattedHtml);
    node formattedHtml <- jsonPageHandler(4);
  }
}

graph provider homeHandler() -> future<string> {
  # TODO(steving) Claro needs multi-line strings now apparently.
  root formattedHtml <- reduce(@htmlStrParts, "", lambda (accum, curr) -> { return "{accum}{curr}"; });
  node htmlStrParts <-
    ["<!DOCTYPE html>\n",
    "<html>\n",
    "  <body>\n",
    "    <h1>Site Directory</h1>\n",
    "    <ul>\n",
    "      <li><a href=\"/page1\">Page 1</a></li>\n",
    "      <li><a href=\"/page2\">Page 2</a></li>\n",
    "      <li><a href=\"/page3\">Page 3 (will intentionally cause internal server error)</a></li>\n",
    "      <li><a href=\"/page4\">Page 4 (will return JSON)</a></li>\n",
    "    </ul>\n",
    "  </body>\n",
    "</html>\n"];
}
#
graph function htmlPageHandler(pageNum: int) -> future<string> {
  # TODO(steving) Claro needs multi-line strings now apparently.
  root formattedHtml <- reduce(@htmlStrParts, "", lambda (accum, curr) -> { return "{accum}{curr}"; });
  node htmlStrParts <-
    ["<!DOCTYPE html>\n",
    "<html>\n",
    "  <body>\n",
    "    <h1>You Made it to Page {@loggedPageNum}!</h1>\n",
    "    <ul>\n",
    "      <li><a href=\"/\">Go Back to Home</a></li>\n",
    "    </ul>\n",
    "  </body>\n",
    "</html>\n"];
  node loggedPageNum <- logAndReturnPageNum(pageNum);
}

graph function jsonPageHandler(pageNum: int) -> future<string> {
  root formattedHtml <- reduce(@jsonStrParts, "", lambda (accum, curr) -> { return "{accum}{curr}"; });
  # TODO(steving) Claro needs support for automatically converting Claro types to Json strings.
  node jsonStrParts <-
    ["\{\n",
      "  \"Page Header\": \"You Made it to Page {@loggedPageNum}!\",\n",
      "  \"Go Back to Home\": \"http://localhost:8080\"\n",
      "}"];
  node loggedPageNum <- logAndReturnPageNum(pageNum);
}

function logAndReturnPageNum(pageNum: int) -> int {
  print("Request Recieved at /page{pageNum}!");
  return pageNum;
}

function reduce<T, R>(l: [T], accumulated: R, accumulatorFn: function<|R, T| -> R>) -> R {
  for (elem in l) {
    accumulated = accumulatorFn(accumulated, elem);
  }
  return accumulated;
}


########################################################################################################################
# The builtin function `getBasicHttpServerForPort()` has the following signature:
#     function getBasicHttpServerForPort<T>(port: int) -> HttpServer<T>;
#
# As you can tell by the lack of a requires clause, this particular contract definition does rely on compiler magic that
# you couldn't directly implement in user-space in Claro in order to enforce the requirement that each concrete `T` is
# actually an HttpService. To achieve exactly this outside of the compiler, you'd need to actually do some codegen
# yourself to dynamically generate a contract definition. Claro won't support macros so this would be done at the Bazel
# genrule level. Instead, Claro provides this powerful building block out of the box!
#
# TODO(steving) This obviously needs to be presented as part of the stdlib in a module such as `HttpServers` so that the
# TODO(steving)   function must be called as `HttpServers::getBasicHttpServerForPort()` instead of as a top-level function.
########################################################################################################################

var myDemoServer: HttpServer<MyDemoService> = getBasicHttpServerForPort(8080);
startServerAndAwaitShutdown(myDemoServer);

