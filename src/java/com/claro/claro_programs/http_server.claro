HttpService MyDemoService {
  gamePage: "/",
  startNewGame: "/startNewGame",
  joinGame: "/game/{gameId}/join/{handle}",
  gameMove: "/game/{gameId}/player/{secret}/{dir}",
  getBestMoves: "/game/{gameId}/player/{secret}/getBestMoves",
  resetGame: "/game/{gameId}/player/{secret}/reset"
}

########################################################################################################################
# For each HttpService definition, Claro you may either generate a client to communicate with a remote server, OR
# declare an `endpoint_handlers` block for the service in order to be able to generate a server that implements the
# service. This is the key power of the language's server definitions as each endpoint handler is statically *REQUIRED*
# to be implemented in a non-blocking manner to fully leverage 100% of Claro's extremely efficient multithreaded
# concurrency model.
########################################################################################################################

endpoint_handlers MyDemoService {
  graph provider gamePage() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- gamePageHandler();
  }

  graph provider startNewGame() -> future<HttpResponse> {
    root res <- getOk200HttpResponseForJson(@formattedJson);
    node formattedJson <- startNewGameHandler("Jason");
  }

  graph function joinGame(gameId: string, handle: string) -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- handleBuggyResponseAsHtmlStrParts(@joinResponse)[0];
    node joinResponse <- friendsJoin(
      cast(HttpClient<BuggyBuggies>, getHttpClient("https://buggy-buggies.gigalixirapp.com")),
      gameId,
      handle
    );
  }

  graph function gameMove(gameId: string, playerSecret: string, dir: string) -> future<HttpResponse> {
    root res <- getOk200HttpResponseForHtml(@formattedHtml);
    node formattedHtml <- gameMoveHandler(gameId, playerSecret, @dirsMap[dir]);
    node dirsMap <- {"up": "N", "down": "S", "right": "E", "left": "W"};
  }

  graph function getBestMoves(gameId: string, playerSecret: string) -> future<HttpResponse> {
    root res <- getOk200HttpResponseForJson(@formattedJson);
    node formattedJson <- getBestMovesHandler(@parsedWorld);
    # TODO(steving) Figure out how to use just a singleton client.
    node parsedWorld <- worldInfo(
      cast(HttpClient<BuggyBuggies>, getHttpClient("https://buggy-buggies.gigalixirapp.com")),
      gameId,
      playerSecret
    );
  }

  graph function resetGame(gameId: string, playerSecret: string) -> future<HttpResponse> {
    root res <- getOk200HttpResponseForJson(@formattedJson);
    node formattedJson <- handleBuggyResponseAsHtmlStrParts(@resetResponse)[0];
    node resetResponse <- reset(
      cast(HttpClient<BuggyBuggies>, getHttpClient("https://buggy-buggies.gigalixirapp.com")),
      gameId,
      playerSecret
    );
  }
}

########################################################################################################################
# The builtin function `getBasicHttpServerForPort()` has the following signature:
#     function getBasicHttpServerForPort<T>(port: int) -> HttpServer<T>;
#
# As you can tell by the lack of a requires clause, this particular contract definition does rely on compiler magic that
# you couldn't directly implement in user-space in Claro in order to enforce the requirement that each concrete `T` is
# actually an HttpService. To achieve exactly this outside of the compiler, you'd need to actually do some codegen
# yourself to dynamically generate a contract definition. Claro won't support macros so this would be done at the Bazel
# genrule level. Instead, Claro provides this powerful building block out of the box!
#
# TODO(steving) This obviously needs to be presented as part of the stdlib in a module such as `HttpServers` so that the
# TODO(steving)   function must be called as `HttpServers::getBasicHttpServerForPort()` instead of as a top-level function.
########################################################################################################################

var myDemoServer: HttpServer<MyDemoService> = getBasicHttpServerForPort(8080);
startServerAndAwaitShutdown(myDemoServer);


HttpService BuggyBuggies {
  hostGame: "/api/host/{handle}",
  friendsJoin: "/api/game/{gameId}/join/{handle}",
  move: "/api/game/{gameId}/player/{secret}/move/{direction}",
  worldInfo: "/api/game/{gameId}/player/{secret}/info",
  reset: "/api/game/{gameId}/player/{secret}/reset"
}
alias MoveResponse : struct {
  reason: oneof<string, NothingType>,
  result: struct {
    players: { string : struct { x: int, y: int } },
    dimensions: struct {
      height: int,
      width: int
    },
    world: { string: string }, # E.g. ("0,6": "wall")
    you: struct {
      handle: string,
      purse: int,
      boom: boolean,
      x: int,
      y: int
    }
  },
  success: boolean
}

graph provider gamePageHandler() -> future<string> {
  # TODO(steving) Claro needs multi-line strings now apparently.
  root formattedHtml <- reduce(@htmlStrParts, "", lambda (accum, curr) -> { return "{accum}{curr}"; });
  node htmlStrParts <-
    [
        "<!DOCTYPE html>\n",
        "<html>\n",
        "<head>\n",
        "  <title>Game Page</title>\n",
        "  <style>\n",
        "    /* CSS styling */\n",
        "    body \{\n",
        "      font-family: \"Arial\", sans-serif;\n",
        "      text-align: center;\n",
        "      margin: 20px;\n",
        "    }\n",
        "    .button \{\n",
        "      background-color: #4CAF50;\n",
        "      border: none;\n",
        "      color: white;\n",
        "      padding: 15px 30px;\n",
        "      text-align: center;\n",
        "      text-decoration: none;\n",
        "      display: inline-block;\n",
        "      font-size: 16px;\n",
        "      margin: 10px;\n",
        "      cursor: pointer;\n",
        "      border-radius: 4px;\n",
        "    }\n",
        "    .button.up,\n",
        "    .button.down,\n",
        "    .button.left,\n",
        "    .button.right \{\n",
        "      width: 100px;\n",
        "    }\n",
        "    .button.left,\n",
        "    .button.right \{\n",
        "      margin: 0 10px;\n",
        "    }\n",
        "    .plus-sign \{\n",
        "      display: flex;\n",
        "      flex-direction: column;\n",
        "      align-items: center;\n",
        "    }\n",
        "    .button-section \{\n",
        "      margin-top: 20px;\n",
        "    }\n",
        "  </style>\n",
        "</head>\n",
        "<body>\n",
        "  <h1>Welcome to the Game!</h1>\n",
        "  <div class=\"button-section\">\n",
        "    <button class=\"button\" id=\"startButton\">Start New Game</button>\n",
        "    <button class=\"button\" id=\"resetButton\">Reset Game</button>\n",
        "  </div>\n",
        "\n",
        "  <div class=\"plus-sign\">\n",
        "    <button class=\"button up\">Up</button>\n",
        "    <div>\n",
        "      <button class=\"button left\">Left</button>\n",
        "      <button class=\"button right\">Right</button>\n",
        "    </div>\n",
        "    <button class=\"button down\">Down</button>\n",
        "  </div>\n",
        "\n",
        "  <div class=\"button-section\">\n",
        "    <button class=\"button\" id=\"startAiButton\">Start AI</button>\n",
        "    <button class=\"button\" id=\"stopAiButton\">Stop AI</button>\n",
        "  </div>\n",
        "  <div class=\"join-game-section\">\n",
        "    <input type=\"text\" id=\"gameIdInput\" placeholder=\"Enter game id\" onfocus=\"this.style.color='black'\">\n",
        "    <input type=\"text\" id=\"handleInput\" placeholder=\"Enter your handle\" onfocus=\"this.style.color='black'\">\n",
        "    <button class=\"button\" id=\"joinButton\">Join Existing Game</button>\n",
        "  </div>\n",
        "  <div id=\"messageSection\"></div>\n",
        "  <script>\n",
        "    // JSON data\n",
        "    var gameData = \{\n",
        "      \"baseUrl\": \"http://localhost:8080/\",\n",
        "      \"runAI\": true,\n",
        "      \"gameId\": \"\",\n",
        "      \"playerSecret\": \"\",\n",
        "    };\n",
        "\n",
        "    // JavaScript code\n",
        "    var startButton = document.getElementById(\"startButton\");\n",
        "    startButton.addEventListener(\"click\", function() \{\n",
        "      // Send request\n",
        "      sendRequest(gameData.baseUrl + \"startNewGame\")\n",
        "        .then(data => \{\n",
        "          var joinResponse = JSON.parse(data); \n",
        "          gameData.gameId = joinResponse.result.game_id;\n",
        "          gameData.playerSecret = joinResponse.result.secret;\n",
        "          console.log(gameData);\n",
        "          // Render message section\n",
        "          var messageSection = document.getElementById(\"messageSection\");\n",
        "          if (messageSection) \{\n",
        "            messageSection.innerHTML = '<p class=\"message\">' + data + '</p>';\n",
        "          }\n",
        "        })\n",
        "        .catch(error => console.log(error));\n",
        "    });\n",
        "    var resetGameButton = document.getElementById(\"resetButton\");\n",
        "    resetGameButton.addEventListener(\"click\", function() \{\n",
        "      var resetUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/player/\" + gameData.playerSecret + \"/reset\";\n",
        "      sendRequest(resetUrl);\n",
        "    });\n",
        "\n",
        "    var directionalButtons = document.querySelectorAll(\".plus-sign button\");\n",
        "    directionalButtons.forEach(function(button) \{\n",
        "      button.addEventListener(\"click\", function() \{\n",
        "        var dir = button.textContent.toLowerCase();\n",
        "        var dirUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/player/\" + gameData.playerSecret + \"/\" + dir;\n",
        "\n",
        "        sendRequest(dirUrl);\n",
        "      });\n",
        "    });\n",
        "\n",
        "    function sendRequest(url) \{\n",
        "      // Send request\n",
        "      return fetch(url)\n",
        "        .then(response => response.text())\n",
        "        .then(data => \{\n",
        "          // Render message section\n",
        "          var messageSection = document.getElementById(\"messageSection\");\n",
        "          if (messageSection) \{\n",
        "            messageSection.innerHTML = '<p class=\"message\">' + data + '</p>';\n",
        "          }\n",
        "          return data;\n",
        "        })\n",
        "        .catch(error => console.log(error));\n",
        "    }\n",
        "\n",
        "    var startAiButton = document.getElementById(\"startAiButton\");\n",
        "    startAiButton.addEventListener(\"click\", async function() \{\n",
        "      gameData.runAI = true;\n",
        "      var aiUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/player/\" + gameData.playerSecret + \"/getBestMoves\";\n",
        "      while (gameData.runAI) \{\n",
        "        await sendRequest(aiUrl)\n",
        "          .then(async (data) => \{\n",
        "            console.log(\"Going to automatically execute the best moves in order\");\n",
        "            console.log(data);\n",
        "            var bestMoves = JSON.parse(data);\n",
        "            console.log(bestMoves);\n",
        "            var dirsMap = \{'N':'up', 'S': 'down', 'E': 'right', 'W': 'left'};\n",
        "            for (let dir of JSON.parse(data)) \{\n",
        "              if (!gameData.runAI) return;\n",
        "              var dirUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/player/\" + gameData.playerSecret + \"/\";\n",
        "              sendRequest(dirUrl + dirsMap[dir]);\n",
        "              await new Promise(r => setTimeout(r, 100));\n",
        "            }\n",
        "          });\n",
        "      }\n",
        "    });\n",
        "    var stopAiButton = document.getElementById(\"stopAiButton\");\n",
        "    stopAiButton.addEventListener(\"click\", function() \{\n",
        "      gameData.runAI = false;\n",
        "    });\n",
        "    var joinButton = document.getElementById(\"joinButton\");\n",
        "    joinButton.addEventListener(\"click\", function() \{\n",
        "      gameData.gameId = document.getElementById(\"gameIdInput\").value;\n",
        "      var handle = document.getElementById(\"handleInput\").value;\n",
        "      var joinUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/join/\" + handle;\n",
        "      sendRequest(joinUrl)\n",
        "        .then(data => \{\n",
        "          var joinResponse = JSON.parse(data); \n",
        "          gameData.playerSecret = joinResponse.result.secret;\n",
        "        });\n",
        "    });\n",
        "    document.addEventListener(\"keydown\", function(event) \{\n",
        "      switch (event.key) \{\n",
        "        case \"ArrowUp\":\n",
        "          var upButton = document.querySelector(\".button.up\");\n",
        "          upButton.classList.add(\"active\");\n",
        "          var upUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/player/\" + gameData.playerSecret + \"/up\";\n",
        "          sendRequest(upUrl);\n",
        "          break;\n",
        "        case \"ArrowDown\":\n",
        "          var downButton = document.querySelector(\".button.down\");\n",
        "          downButton.classList.add(\"active\");\n",
        "          var downUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/player/\" + gameData.playerSecret + \"/down\";\n",
        "          sendRequest(downUrl);\n",
        "          break;\n",
        "        case \"ArrowLeft\":\n",
        "          var leftButton = document.querySelector(\".button.left\");\n",
        "          leftButton.classList.add(\"active\");\n",
        "          var leftUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/player/\" + gameData.playerSecret + \"/left\";\n",
        "          sendRequest(leftUrl);\n",
        "          break;\n",
        "        case \"ArrowRight\":\n",
        "          var rightButton = document.querySelector(\".button.right\");\n",
        "          rightButton.classList.add(\"active\");\n",
        "          var rightUrl = gameData.baseUrl + \"game/\" + gameData.gameId + \"/player/\" + gameData.playerSecret + \"/right\";\n",
        "          sendRequest(rightUrl);\n",
        "          break;\n",
        "      }\n",
        "    });\n",
        "\n",
        "    document.addEventListener(\"keyup\", function(event) \{\n",
        "      switch (event.key) \{\n",
        "        case \"ArrowUp\":\n",
        "          var upButton = document.querySelector(\".button.up\");\n",
        "          upButton.classList.remove(\"active\");\n",
        "          break;\n",
        "        case \"ArrowDown\":\n",
        "          var downButton = document.querySelector(\".button.down\");\n",
        "          downButton.classList.remove(\"active\");\n",
        "          break;\n",
        "        case \"ArrowLeft\":\n",
        "          var leftButton = document.querySelector(\".button.left\");\n",
        "          leftButton.classList.remove(\"active\");\n",
        "          break;\n",
        "        case \"ArrowRight\":\n",
        "          var rightButton = document.querySelector(\".button.right\");\n",
        "          rightButton.classList.remove(\"active\");\n",
        "          break;\n",
        "      }\n",
        "    });\n",
        "  </script>\n",
        "</body>\n",
        "</html>\n"
    ];
}

graph function gameMoveHandler(gameId: string, playerSecret: string, dir: string) -> future<string> {
  root formattedHtml <- reduce(@htmlStrParts, "", lambda (accum, curr) -> { return "{accum}{curr}"; });
  node htmlStrParts <- handleBuggyResponseAsHtmlStrParts(@moveBuggyResponse);
  # TODO(steving) Figure out how to use just a singleton client.
  node moveBuggyResponse <-
    move(
      cast(HttpClient<BuggyBuggies>, getHttpClient("https://buggy-buggies.gigalixirapp.com")),
      gameId,
      playerSecret,
      dir
    );
}

graph function startNewGameHandler(handle: string) -> future<string> {
  root joinRes <- handleBuggyResponseAsHtmlStrParts(@moveBuggyResponse)[0];
  # TODO(steving) Figure out how to use just a singleton client.
  node moveBuggyResponse <-
    hostGame(
      cast(HttpClient<BuggyBuggies>, getHttpClient("https://buggy-buggies.gigalixirapp.com")),
      handle
    );
}

function getBestMovesHandler(buggyResponse: oneof<string, Error<string>>) -> string {
  match (buggyResponse) {
    case string ->
      var moveResponse = unwrap(cast(ParsedJson<MoveResponse>, fromJson(buggyResponse))).result;
      match (moveResponse) {
        case MoveResponse ->
          var parsedWorld = parseWorldMap(moveResponse.result.world);
          var computedBestPath = dijkstra(parsedWorld, Position({x = moveResponse.result.you.x, y = moveResponse.result.you.y}));
          var computedMoves = ["\"{dir}\"" | dir in movesFromBestPath(computedBestPath)];
          return "{computedMoves}";
        case Error<string> ->
          return "FAILED TO PARSE CURRENT STATE OF THE WORLD:\n{moveResponse}";
      }
    case Error<string> ->
      return "FAILED TO PARSE CURRENT STATE OF THE WORLD:\n{buggyResponse}";
  }
}

function handleBuggyResponseAsHtmlStrParts(buggyResponse: oneof<string, Error<string>>) -> [string] {
  match (buggyResponse) {
    case string        -> return [buggyResponse];
    case Error<string> -> return ["GOT THE FOLLOWING ERROR:\n", unwrap(buggyResponse)];
  }
}

function reduce<T, R>(l: [T], accumulated: R, accumulatorFn: function<|R, T| -> R>) -> R {
  for (elem in l) {
    accumulated = accumulatorFn(accumulated, elem);
  }
  return accumulated;
}


####################################################################################################
# TODO(steving) Claro badly needs a module system!
# BEGIN AI.claro
####################################################################################################

function movesFromBestPath(bestPath: BestPath) -> [string] {
  var moves: mut [string] = mut [];
  var getDelta: function<int -> tuple<int, int>> =
    i -> {
      var dx = unwrap(bestPath[i]).x - unwrap(bestPath[i + 1]).x;
      var dy = unwrap(bestPath[i]).y - unwrap(bestPath[i + 1]).y;
      return (dx, dy);
    };

  var i = len(bestPath) - 2;
  while (i >= 0) {
    var delta = getDelta(i--);
    # TODO(steving) Exhaustive match would be so nice.
    if (delta == (1, 0)) {
      append(moves, "E");
    } else if (delta == (-1, 0)) {
      append(moves, "W");
    } else if (delta == (0, 1)) {
      append(moves, "S");
    } else {
      append(moves, "N");
    }
  }
  return copy(moves);
}

function parseWorldMap(world: {string: string}) -> {Position: string} {
  var parsePos: function<string -> Position> = rawPos -> {
    var xstring = rawPos[0];
    var i = 1;
    while (rawPos[i] != ",") {
      xstring = "{xstring}{rawPos[i++]}";
    }
    var ystring = rawPos[i + 1];
    i = i + 2;
    while (i < len(rawPos)) {
      ystring = "{ystring}{rawPos[i++]}";
    }
    # TODO(steving) Shouldn't have to use this ugly hack. Claro should have int parsing from string in stdlib.
    var x: oneof<int, Error<string>> = unwrap(cast(ParsedJson<int>, fromJson(xstring))).result;
    var y: oneof<int, Error<string>> = unwrap(cast(ParsedJson<int>, fromJson(ystring))).result;
    # TODO(steving) I should eventually be able to rewrite this using an exhaustive match over the tuple (x, y).
    if ((x instanceof int) and (y instanceof int)) {
      return Position({x = x, y = y});
    }
    return Position({x = -1, y = -1});
  };
  return {parsePos(e[0]) : e[1] | e in world};
}

####################################################################################################
# TODO(steving) Claro badly needs a module system!
# END AI.claro
####################################################################################################


####################################################################################################
# TODO(steving) Claro badly needs a module system!
# BEGIN Dijkstra.claro
####################################################################################################

alias DistanceVia : struct {dist: int, via: oneof<Position, NothingType>}
alias BestPath : [Position]

function dijkstra(world: {Position: string}, start: Position) -> BestPath {
  var distances: DefaultDict<Position, DistanceVia> = getDefaultDict(lambda () -> DistanceVia { return {dist = 999999, via = nothing}; }); # TODO(steving) Need some representation of INFINITY in stdlib.
  defaultDictPut(distances, start, {dist = 0, via = start});
  var pq = getHeap();
  insert(pq, {dist = 0, pos = start});
  var visited: mut {Position: boolean} = mut {}; # TODO(steving) Change to set once set operations added to stdlib.

  while (not heapIsEmpty(pq)) {
    var currPos = extract_min(pq);
    if (currPos instanceof Position) {
      if (currPos in visited) {
        continue;
      }
      visited[currPos] = true;
      for (weightedNeighbor in getWeightedNeighbors(world, currPos)) {
        var neighbor = weightedNeighbor.neighbor;
        var weight = weightedNeighbor.weight;
        if ((defaultDictGet(distances, currPos).dist + weight) < defaultDictGet(distances, neighbor).dist) {
          defaultDictPut(distances, neighbor, {dist = defaultDictGet(distances, currPos).dist + weight, via = currPos});
          insert(pq, {dist = defaultDictGet(distances, neighbor).dist, pos = neighbor});
        }
      }
    }
  }

  return rebuildBestPath(world, asMap(distances));
}

function rebuildBestPath(world: {Position: string}, distances: {Position: DistanceVia}) -> BestPath {
  var route: mut [Position] = mut [];
  var currPos = findCoinWithLowestScore(world, distances);
  while (true) {
    append(route, currPos);
    var via = distances[currPos].via;
    if (currPos == via) { # This is simply because I initialized `distances` to have the start node reference itself.
      break;
    } else if (via instanceof Position) {
      # I know for a fact it's a Position, but this is the only way to convince Claro of that.
      currPos = via;
    }
  }
  return copy(route);
}

function findCoinWithLowestScore(world: {Position: string}, distances: {Position: DistanceVia}) -> Position {
  var currBest: tuple<Position, DistanceVia> = (Position({x = -1, y = -1}), {dist = 999999, via = Position({x = -1, y = -1})}); # TODO(steving) Need some representation of INFINITY in stdlib.
  for (distEntry in distances) {
    if ((distEntry[0] in world) and (world[distEntry[0]] == "coin") and (distEntry[1].dist < currBest[1].dist)) {
      currBest = distEntry;
    }
  }
  return currBest[0];
}

function getWeightedNeighbors(world: {Position: string}, pos: Position) -> [struct {neighbor: Position, weight: int}] {
  var neighbors: mut [struct {neighbor: Position, weight: int}] = mut [];
  var updatePos: function<|int, int| -> Position> =
    lambda (dx, dy) -> Position({x = unwrap(pos).x + dx, y = unwrap(pos).y + dy});
  var validateMove: consumer<mut [struct {neighbor: Position, weight: int}], int, int> =
    lambda (l, dx, dy) -> {
      var n = updatePos(dx, dy);
      if ((not (n in world)) or (world[n] == "coin")) {
        # TODO(steving) Making every neighbor have equal weight means Dijkstra's is just an extremely complicated BFS...
        # TODO(steving) Soon, update this implementation to actually evaluate a score for moving into this position.
        append(l, {neighbor = n, weight = 1});
      }
    };

  for (dir in [(-1, 0), (1, 0), (0, -1), (0, 1)]) { # [LEFT, RIGHT, DOWN, UP]
    validateMove(neighbors, dir[0], dir[1]);
  }

  return copy(neighbors);
}

####################################################################################################
# TODO(steving) Claro badly needs a module system!
# END Dijkstra.claro
####################################################################################################

####################################################################################################
# TODO(steving) Claro badly needs a module system!
# BEGIN DefaultDict.claro
####################################################################################################

newtype DefaultDict<K,V>: struct {defaultPr: provider<V>, dict: mut {K:V}}

initializers DefaultDict {
  function getDefaultDict<K,V>(defaultPr: provider<V>) -> DefaultDict<K,V> {
    return DefaultDict({defaultPr = defaultPr, dict = mut {}});
  }
}

# TODO(steving) Claro really needs to support overloading operator[] via some Contract.
unwrappers DefaultDict {
  function defaultDictGet<K,V>(d: DefaultDict<K,V>, key: K) -> V {
    var dict = unwrap(d).dict;
    if (not (key in dict)) {
      var defPr = unwrap(d).defaultPr; # TODO(steving) Tracking bug in: https://docs.google.com/spreadsheets/d/1PvMoLlIKfcq41F0tn0WRlBsamJ_gq_3dvEIKmoOlBqk/edit#gid=0&range=C7
      dict[key] = defPr();
    }
    return dict[key];
  }

  consumer defaultDictPut<K,V>(d: DefaultDict<K,V>, key: K, value: V) {
    var dict = unwrap(d).dict;
    dict[key] = value;
  }

  function asMap<K,V>(d: DefaultDict<K,V>) -> {K: V} {
    return copy(unwrap(d).dict);
  }
}

####################################################################################################
# TODO(steving) Claro badly needs a module system!
# END DefaultDict.claro
####################################################################################################

####################################################################################################
# TODO(steving) Claro badly needs a module system!
# BEGIN Heap.claro
####################################################################################################

# This implementation is the result of asking Chat GPT to implement it in python for me and reworking it to fit in Claro
# I'm not thinking too hard about this...
newtype Position : struct {x: int, y: int}
newtype Heap: mut [struct {dist: int, pos: Position}]

initializers Heap {
  provider getHeap() -> Heap {
    return Heap(mut []);
  }
}

unwrappers Heap {
  function extract_min(heap: Heap) -> oneof<Position, Error<NothingType>> {
      if (len(unwrap(heap)) == 0) {
          return Error(nothing);
      }
      var min_value = unwrap(heap)[0];
      swap(heap, 0, len(unwrap(heap)) - 1);
      _ = remove(unwrap(heap), len(unwrap(heap)) - 1);
      heapify_down(heap, 0);

      return min_value.pos;
  }

  function parent(i: int) -> int {
      return (i - 1) / 2;
  }

  function left_child(i: int) -> int {
      return 2 * i + 1;
  }

  function right_child(i: int) -> int {
      return 2 * i + 2;
  }

  consumer swap(heap: Heap, i: int, j: int) {
      var tmp = unwrap(heap)[i];
      unwrap(heap)[i] = unwrap(heap)[j];
      unwrap(heap)[j] = tmp;
  }


  consumer insert(heap: Heap, value: struct {dist: int, pos: Position}) {
      append(unwrap(heap), value);
      heapify_up(heap, len(unwrap(heap)) - 1);
  }

  function heapIsEmpty(heap: Heap) -> boolean {
    return len(unwrap(heap)) == 0;
  }

  consumer heapify_up(heap: Heap, i: int) {
      while ((i > 0) and (unwrap(heap)[i].dist < unwrap(heap)[parent(i)].dist)) {
          swap(heap, i, parent(i));
          i = parent(i);
      }
  }

  consumer heapify_down(heap: Heap, i: int) {
      while (true) {
          var min_index = i;
          if ((left_child(i) < len(unwrap(heap))) and (unwrap(heap)[left_child(i)].dist < unwrap(heap)[min_index].dist)) {
              min_index = left_child(i);
          }
          if ((right_child(i) < len(unwrap(heap))) and (unwrap(heap)[right_child(i)].dist < unwrap(heap)[min_index].dist)) {
              min_index = right_child(i);
          }
          if (min_index != i) {
              swap(heap, i, min_index);
              i = min_index;
          } else {
            break;
          }
      }
  }
}

####################################################################################################
# TODO(steving) Claro badly needs a module system!
# END Heap.claro
####################################################################################################
