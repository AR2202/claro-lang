HttpService BuggyBuggies {
  hostGame: "/api/host/{handle}",
  friendsJoin: "/api/game/{gameId}/join/{handle}",
  move: "/api/game/{gameId}/player/{secret}/move/{direction}"
}
var buggyBuggiesClient: HttpClient<BuggyBuggies> = getHttpClient("https://buggy-buggies.gigalixirapp.com");

alias HostGameResponse : struct {
  reason: oneof<string, NothingType>,
  result: struct {
    example: string,
    game_id: string,
    secret: string,
    watch: string
  },
  success: boolean
}
alias MoveResponse : struct {
  reason: oneof<string, NothingType>,
  result: struct {
    players: { string : struct { x: int, y: int } },
    world: { string: string }, # E.g. ("0,6": "wall")
    you: struct {
      handle: string,
      purse: int,
      boom: boolean,
      x: int,
      y: int
    }
  },
  success: boolean
}

var handle = "claro has native support for http reqs!";
var gameId = "c9ba1a58-b665-4f55-857b-4ac9a5ec0ccc";
var playerSecret = "79187023-3e0d-4fbc-b0f3-4ed73e1cce5b";

if (input("Do you want to start a new game? (Y/N): ") == "Y") {
  handle = input("What's your game handle?: ");
  var rawHostGameResponse: oneof<string, Error<string>> <-| hostGame(buggyBuggiesClient, handle);
  if (rawHostGameResponse instanceof string) {
    var hostGameParsedJson: ParsedJson<HostGameResponse> = fromJson(rawHostGameResponse);
    var hostGameResponse = unwrap(hostGameParsedJson).result;
    if (hostGameResponse instanceof HostGameResponse) {
      gameId = hostGameResponse.result.game_id;
      print("Game ID: {gameId}");
      playerSecret = hostGameResponse.result.secret;
      print("Secret: {playerSecret}");
    }
  } else {
    print("The hostGame() request failed with the following response:\n{rawHostGameResponse}");
    print("Falling back to default handle/gameId/playerSecret.");
  }
  _ = input("Hit enter once you're ready to start playing!");
}

var userInput = input("Which direction do you want to move? (N/E/S/W): ");
while (true) {
  var parsedMove = parseMove(userInput);

  if (parsedMove instanceof Error<string>) {
    print(parsedMove);
  } if (parsedMove instanceof Error<EndGame>) {
    print("Good game!");
    break;
  } else if (parsedMove instanceof string) {
    _ = handleMove(buggyBuggiesClient, gameId, playerSecret, parsedMove);
  } else if (parsedMove instanceof RepeatMove) {
    repeat(unwrap(parsedMove).dist) {
      var response = handleMove(buggyBuggiesClient, gameId, playerSecret, unwrap(parsedMove).dir);
      if (response instanceof Error<string>) {
        print("Got an error response before completing full set of moves:\n{response}");
        break;
      }
    }
  }

  userInput = input("Which direction do you want to move? (N/E/S/W): ");
}

blocking function handleMove(client: HttpClient<BuggyBuggies>, gameId: string, playerSecret: string, dir: string)
    -> oneof<MoveResponse, Error<string>> {
  # Make the HTTP req.
  var rawMoveResponseOrErr <-| move(client, gameId, playerSecret, dir);
  var rawMoveResponse ?= rawMoveResponseOrErr;

  # Parse from Json.
  var moveResponseParsedJson: ParsedJson<MoveResponse> = fromJson(rawMoveResponse);
  var moveResponse = unwrap(moveResponseParsedJson).result;
  if (moveResponse instanceof MoveResponse) {
    print("Move Response:\n{moveResponse}");
  }
  return moveResponse;
}

newtype RepeatMove: struct{
  dist: int,
  dir: string
}
newtype EndGame: NothingType
function parseMove(moveInput: string) -> oneof<string, RepeatMove, Error<string>, Error<EndGame>> {
  var dirs = {"N", "E", "S", "W"};
  var numbers = {"{x}":x | x in [1,2,3,4,5,6,7,8,9]};

  if (len(moveInput) == 1) {
    if (moveInput in dirs) {
      return moveInput;
    }
  } else if ((len(moveInput) == 2) and (moveInput[0] in numbers) and (moveInput[1] in dirs)) {
    return RepeatMove({dist = numbers[moveInput[0]], dir = moveInput[1]});
  }

  if (len(moveInput) == 0) {
    return Error(EndGame(nothing));
  } else {
    return Error("Unexpected input: {moveInput}");
  }
}
