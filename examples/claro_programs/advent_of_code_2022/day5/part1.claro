# https://adventofcode.com/2022/day/5#part1

# Wishlist: This would all be much simpler with a builtin stack data type.

# Wishlist: A major current deficiency in Claro is the lack of structs. The below setup is just a gross workaround.
#  in the future I should be able to implement this much more cleanly. The list around the int is just a hack to make
#  it mutable since if this were a struct I'd be able to mutate the field.
alias Stack: tuple<[string], [int]>
provider getStack() -> Stack { # Constructor.
  return (([string]) [], [-1]);
}
function pop(s: Stack) -> string {
  var topInd = s[1][0];
  # Wishlist: I should be able to do assignment to arbitrary lhs exprs representing a collection subscript.
#  s[1][0] = topInd - 1;
  # We're never freeing memory here, this list will never shrink. That's fine for this puzzle.
  var topHolder = s[1];
  topHolder[0] = s[1][0] - 1;
  return s[0][topInd];
}
consumer push(s: Stack, val: string) {
  # Wishlist: I should be able to do assignment to arbitrary lhs exprs representing a collection subscript.
#  s[1][0] = (([int]) s[1]) + 1;
  var topHolder = s[1];
  if (topHolder[0] + 1 < len(s[0])) {
    # In this case previous push/pops have led to there already being space for this pushed val.
    var boxes = s[0];
    boxes[topHolder[0] + 1] = val;
  } else {
    # In this case, the top actually points to the last element in the [string], I need to grow it.
    append(s[0], val);
  }
  topHolder[0] = s[1][0] + 1;
}

function isStackLabelLine(line: string, charToIntMap: {string: int}) -> boolean {
  return (line[0] == " ") and (line[1] in charToIntMap);
}

provider parseAndPopulateStacks() -> [Stack] {
  # Wishlist: I really need sets in Claro so I don't need to use a Map as a hack.
  # Wishlist: I need to be able to define constants at the top of files and reference them from functions.
  var charToIntMap = {"0":0, "1":1, "2":2, "3":3, "4":4, "5":5, "6":6, "7":7, "8":8, "9":9};

  var lines: [string] = [];
  var line = input();
  while (not isStackLabelLine(line, charToIntMap)) {
    append(lines, line);
    line = input();
  }
  # Now I'm looking at the label line so I can easily check how many stacks I need.
  var numStacks = charToIntMap[line[len(line) - 1]];

  # Populate stacks.
  # Wishlist: List comprehension would be a dream.
  var stacks: [Stack] = [];
  var i = 0;
  while (i < numStacks) {
    append(stacks, getStack());
    var box = 1;
    var moreBoxes = true; # Wishlist: Claro doesn't have a `break` stmt which it obviously needs.
    while (moreBoxes and (box <= len(lines))) {
      var currLine = lines[len(lines) - box];
      if ((len(currLine) <= i * 4) or (currLine[i * 4] == " ")) {
        moreBoxes = false;
      } else { # Found another box to push onto the stack.
        push(stacks[i], currLine[1 + (i * 4)]);
      }
      ++box;
    }
    ++i;
  }

  return stacks;
}

function strToInt(s: string, start: int) -> tuple<int, int> {
  var charToIntMap = {"0":0, "1":1, "2":2, "3":3, "4":4, "5":5, "6":6, "7":7, "8":8, "9":9};
  var res = 0;
  var i = start;
  var endOfIntReached = false;
  while ((not endOfIntReached) and (i < len(s))) {
    if (not (s[i] in charToIntMap)) {
      endOfIntReached = true;
    } else {
      res = (res * 10) + charToIntMap[s[i]];
    }
    ++i;
  }
  return (res, i);
}

consumer parseAndExecuteNextCommand(stacks: [Stack]) {
  var line = input();
  # Wishlist: Tuple unpacking assignment - E.g.: `var x, y = (1, 2);`
  var numMoves = strToInt(line, 5);
  var originStack = strToInt(line, numMoves[1] + 5);
  var destStack = strToInt(line, originStack[1] + 3);

  var i = numMoves[0];
  while (i-- > 0) {
    push(stacks[destStack[0] - 1], pop(stacks[originStack[0] - 1]));
  }
}

var stacks = parseAndPopulateStacks();
_ = input();
print(stacks);
while (isInputReady()) {
  parseAndExecuteNextCommand(stacks);
  print(stacks);
}

var i = 0;
while (i < len(stacks)) {
  # Wishlist: It really is pretty annoying not being able to print something without a newline.
  print(pop(stacks[i++]));
}