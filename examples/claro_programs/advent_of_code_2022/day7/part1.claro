# https://adventofcode.com/2022/day/7#part1

# Wishlist: Claro doesn't support recursive data structures! This is a major deficiency and is about to lead to some
#   super gnarly code. Yet again structs would solve this, but I think it's reasonable for type aliases to also work.
#alias File : tuple<string, int>
#alias Dir : tuple<[File], [Dir]>

function parseFileSize(s: string) -> int {
  var charToIntMap = {"0":0, "1":1, "2":2, "3":3, "4":4, "5":5, "6":6, "7":7, "8":8, "9":9};
  var res = 0;
  var i = 0;
  while ((s[i] in charToIntMap) and (i < len(s))) {
    res = (res * 10) + charToIntMap[s[i++]];
  }
  return res;
}

function copySublist<T>(l: [T], length: int) -> [T] {
  var i = 0;
  var res: [T] = [];
  while (i < length) {
    append(res, l[i++]);
  }
  return res;
}


# Consume the first thing, I know it's the command `$ cd /`. Who cares about making this suuuper general.
# Gonna use a lame hack to just name everthing after the `cd` cmd line it was found with since I can't slice yet.
var currDir = [input()]; # Wishlist: Slices.

# Honestly, this is the most ridiculous hack of all time..I can't do string concatenation in Claro yet, so I can't use
# that to workaround the lack of recursive data type support, so I'm going to hope for the best working with a map
# keyed by a mutable list...yikes...in the future Claro should actually forbid this key, but can't do that until I have
# recursive type support.
var dirInfoMap: {[string]: int} = {currDir: 0};
# Wishlist: I really wish I could iterate the keys of a map directly, but not supported yet. Hence this ugly hack.
var dirInfoMapKeys: [[string]] = [];
var fileSystemDepth = 1;

while (isInputReady()) {
  var line = input();
  if (line[0] == "$") {
    # Parsing a command.
    # Wishlist: `match(line) { ... }`
    if (line == "$ cd /") {
      currDir = [line];
    } else if (line == "$ cd ..") {
      currDir = copySublist(currDir, len(currDir) - 1);
    } else if (line[2] == "c") { # `$ cd ...`
      # Lame hack, don't need to bother trimming the command prefix from the dir name lol.
      var newDir = copySublist(currDir, len(currDir));
      append(newDir, line);
      if (not (newDir in dirInfoMap)) {
        dirInfoMap[newDir] = 0;
        # Added a new key to the `dirInfoMap` so since Claro currently has no way of iterating keys of map directly, I
        # need to track them manually here. This is sooo hacky lol.
        append(dirInfoMapKeys, newDir);
      }
      currDir = newDir;
      if (len(currDir) > fileSystemDepth) {
        fileSystemDepth = len(currDir);
      }
    }
    # Have no use for the `$ ls` command itself.
  } else { # This is one of the output lines from `$ ls` command.
    if (line[0] != "d") { # Listing a file and its size.
      dirInfoMap[currDir] = dirInfoMap[currDir] + parseFileSize(line);
    }
  }
}

# This will be so inefficient but unfortunately I'm unable to create a recursive data structure due to Claro's current
# limitations so I'm stuck with no other choice than to iterate this flattened "tree" structure once for each "level"
# working my way up. This way I'm able to actually collect all sub-directories before finalizing a directory's size. I'd
# Obviously rather do this with a recursive algorithm, or at worst case a stack-based iterative solution...but I'm
# stuck working around Claro's deficiencies for now and that's part of the fun :).
while (fileSystemDepth > 1) {
  var i = 0;
  # Wishlist: I really wish I could iterate the keys of a map directly, but not supported yet.
  while (i < len(dirInfoMapKeys)) {
    # Iterate "bottom up" so find only the ones at the current desired fileSystemDepth.
    if (len(dirInfoMapKeys[i]) == fileSystemDepth) {
      # Propagate this dir's size to its parent.
      var parentDir = copySublist(dirInfoMapKeys[i], fileSystemDepth - 1);
      dirInfoMap[parentDir] = dirInfoMap[parentDir] + dirInfoMap[dirInfoMapKeys[i]];
    }
    ++i;
  }
  --fileSystemDepth;
}

# The final answer the puzzle wants is the sum of sizes of all Dirs whose size is lte 100000.
var i = 0;
var sumOfSizesOfDirsSmallerThan100K = 0;
while (i < len(dirInfoMapKeys)) {
  var currDirSize = dirInfoMap[dirInfoMapKeys[i++]];
  if (currDirSize <= 100000) {
    sumOfSizesOfDirsSmallerThan100K = sumOfSizesOfDirsSmallerThan100K + currDirSize;
  }
}

print("Puzzle Solution: {sumOfSizesOfDirsSmallerThan100K}");
